%!TEX root = io2d.tex

\rSec0 [glyphrun] {Class \tcode{glyph_run}}

\rSec1 [glyphrun.synopsis] {\tcode{glyph_run} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class glyph_run {
    friend ::std::experimental::io2d::font_resource;
    friend surface;
    friend path_factory;

  public:
    class glyph {
      friend glyph_run;
    public:
      typedef unsigned long index_type; // impldef
    private:
      index_type _Index = 0;
      double _X = 0.0;
      double _Y = 0.0;
      cairo_glyph_t* _Native_glyph = nullptr;
    public:
      glyph() noexcept = default;
      glyph(const glyph&) noexcept = default;
      glyph& operator=(const glyph&) noexcept = default;
      glyph(glyph&&) noexcept = default;
      glyph& operator=(glyph&&) noexcept = default;
      glyph(index_type i, double x, double y) noexcept;

      // Modifiers
      void index(index_type i) noexcept;
      void x(double val) noexcept;
      void y(double val) noexcept;

      // Observers
      index_type index() const noexcept;
      double x() const noexcept;
      double y() const noexcept;
    };

    class cluster {
      friend glyph_run;
      // Clusters are useful when dealing with ligatures and ordering in scripts that require complex text layout.
      int _Glyph_count = 0; // Note: It's possible that processing could result in a cluster where one or more characters map to zero glyphs due to the previous or next cluster.
      int _Byte_count = 0; // Note: UTF-8 is variable byte length. A single cluster can map to multiple characters. Lastly, it's possible that processing could result in a cluster with one or more glyphs map to zero characters due to the previous or next cluster.
      cairo_text_cluster_t* _Native_cluster = nullptr;
    public:
      cluster() noexcept = default;
      cluster(const cluster&) noexcept = default;
      cluster& operator=(const cluster&) noexcept = default;
      cluster(cluster&&) noexcept = default;
      cluster& operator=(cluster&&) noexcept = default;
      cluster(int glyphs, int bytes) noexcept;

      // Modifiers
      void glyph_count(int count) noexcept;
      void byte_count(int count) noexcept;

      // Observers
      int glyph_count() const noexcept;
      int byte_count() const noexcept;
    };

  private:
    ::std::string _Text_string;
    ::std::experimental::io2d::font_resource _Font_resource;
    ::std::vector<glyph> _Glyphs;
    ::std::vector<cluster> _Clusters;
    ::std::shared_ptr<cairo_glyph_t> _Cairo_glyphs;
    ::std::shared_ptr<cairo_text_cluster_t> _Cairo_text_clusters;
    vector_2d _Position;
    cairo_text_cluster_flags_t _Text_cluster_flags;

    glyph_run(const ::std::experimental::io2d::font_resource& fr, const ::std::string& utf8, const vector_2d& pos);
    glyph_run(const ::std::experimental::io2d::font_resource& fr, const ::std::string& utf8, const vector_2d& pos, ::std::error_code& ec) noexcept;

  public:
    glyph_run(const glyph_run&) = default;
    glyph_run& operator=(const glyph_run&) = default;
    glyph_run(glyph_run&&) noexcept = default;
    glyph_run& operator=(glyph_run&&) noexcept;

    // Modifiers
    ::std::vector<glyph>& glyphs() noexcept;
    ::std::vector<cluster>& clusters() noexcept;

    // Observers
    const ::std::string& original_text() const noexcept;
    const ::std::vector<glyph>& glyphs() const noexcept;
    const ::std::vector<cluster>& clusters() const noexcept;
    const ::std::experimental::io2d::font_resource& font_resource() const noexcept;
    bool reversed_clusters() const noexcept;
    vector_2d position() const noexcept;
    text_extents extents() const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [glyphrun.intro] {\tcode{glyph_run} Description}

\pnum
\indexlibrary{\idxcode{glyph_run}}
The \tcode{glyph_run} class describes ***FIXME***

\rSec1 [glyphrun.cons] {\tcode{glyph_run} constructors and assignment operators}

\indexlibrary{\idxcode{glyph_run}!constructor}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [glyphrun.modifiers] {\tcode{glyph_run} modifiers}

\indexlibrary{\idxcode{glyph_run}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{glyph_run}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [glyphrun.observers] {\tcode{glyph_run} observers}

\indexlibrary{\idxcode{glyph_run}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{glyph_run}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns

\end{itemdescr}
