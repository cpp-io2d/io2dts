%!TEX root = io2d.tex

\rSec0 [paths] {Paths}

\pnum
Paths define geometric objects which can be stroked (Table~\ref{tab:surface.rendering.operations}), filled, masked, and used to define or modify a Clip Area (Table~\ref{tab:surface.state.listing}).

\pnum
Paths are created using a \tcode{path_factory} object, which stores a path group. 

\pnum
Paths provide vector graphics functionality. As such they are particularly useful in situations where an application is intended to run on a variety of platforms whose output devices (\ref{displaysurface.intro}) span a large gamut of sizes, both in terms of measurement units and in terms of a horizontal and vertical pixel count, in that order. For example, a pixel count expressed as 1280x720 means that there are 1280 horizontal pixels per row of pixels and 720 vertical pixels per column of pixels for a total of 921600 pixels.
%
%\pnum
%For output devices, the measurement size of a pixel is determined by the physical size of the output device. Many output devices represent pixels as having the same horizontal and vertical measurement sizes. As such, when they display a rendered image which does not have the same horizontal to vertical pixel ratio as the output device, it 

\pnum
A path may contain degenerate path segments because of special rules, which are set forth below.

\pnum
A \tcode{path_group} object is an immutable resource wrapper containing a path group (\ref{pathgroup}). A \tcode{path_group} object is created from a \tcode{path_factory} object. It can also be default constructed, in which case the \tcode{path_group} object contains no paths.

\rSec1 [paths.processing] {Processing paths}

\pnum
This section is normative. It describes how to convert the path group of a properly formed \tcode{path_factory} object from a collection of \tcode{path_factory::path_data} objects to a collection of \tcode{path_factory::path_data} objects which have had their points transformed in accordance with the origin and transformation matrix of the \tcode{path_factory} object and any \tcode{path_factory::path_change_origin} and \tcode{path_factory::path_change_matrix} objects in the path group of the \tcode{path_factory} object.

\pnum
The following code shows how to properly process a \tcode{path_factory} object \tcode{p} and store the results into a \tcode{vector<path_factory::path_data>}:

\begin{codeblock}
  #include <cmath>
  #include <vector>
  #include <variant>
  #include <experimental/io2d>
  using namespace std;
  using namespace std::experimental::io2d;
  
  matrix_2d m;
  vector_2d origin;
  vector_2d currentPoint; // Tracks the untransformed current point.
  bool hasCurrentPoint = false;
  vector_2d closePoint;   // Tracks the transformed close point.
  vector<path_factory::path_data> v;
  
  for (auto val : p) {
    std::visit([&](auto&& item) {
      using T = std::remove_cv_t<std::remove_reference_t<decltype item>>;

      if constexpr(std::is_same_v<T, path_factory::path_abs_move>) {
        currentPoint = item.to();
        auto pt = m.transform_point(currentPoint - origin) + origin;
        hasCurrentPoint = true;
        v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt);
        closePoint = pt
      }
      else if constexpr(std::is_same_v<T, path_factory::path_abs_line>) {
        currentPoint = item.to();
        auto pt = m.transform_point(currentPoint - origin) + origin;
        if (hasCurrentPoint) {
          v.emplace_back(in_place_type_t<path_factory::path_abs_line>, pt);
        }
        else {
          v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt);
          v.emplace_back(in_place_type_t<path_factory::path_abs_line>, pt);
          hasCurrentPoint = true;
          closePoint = pt;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_abs_curve>) {
        auto pt1 = m.transform_point(item.control_point_1() - origin) + origin;
        auto pt2 = m.transform_point(item.control_point_2() - origin) + origin;
        auto pt3 = m.transform_point(item.end_point() - origin) + origin;
        if (!hasCurrentPoint) {
          currentPoint = item.control_point_1();
          v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt1);
          hasCurrentPoint = true;
          closePoint = pt1;
        }
        v.emplace_back(in_place_type_t<path_factory::path_abs_curve>, pt1,
          pt2, pt3);
 
        currentPoint = item.end_point();
      }
      else if constexpr(std::is_same_v<T, path_factory::path_new_path>) {
        hasCurrentPoint = false;
        v.emplace_back(in_place_type_t<path_factory::path_new_path>);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_close_path>) {
        if (hasCurrentPoint) {
          v.emplace_back(in_place_type_t<path_factory::path_close_path>);
          v.emplace_back(in_place_type_t<path_factory::path_abs_move>,
            closePoint);
          auto invM = matrix_2d{m}.invert();
          // Need to assign the untransformed closePoint value to currentPoint.
          currentPoint = invM.transform_point(closePoint - origin) + origin;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_move>) {
        currentPoint = item.to() + currentPoint;
        auto pt = m.transform_point(currentPoint - origin) + origin;
        v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt);
        hasCurrentPoint = true;
        closePoint = pt    
        n.close_point(pt);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_line>) {
        currentPoint = item.to() + currentPoint;
        auto pt = m.transform_point(currentPoint - origin) + origin;
        v.emplace_back(in_place_type_t<path_factory::path_abs_line>, pt);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_curve>) {
        auto pt1 = m.transform_point(item.control_point_1() + currentPoint -
        origin) + origin;
        auto pt2 = m.transform_point(item.control_point_2() + currentPoint -
        origin) + origin;
        auto pt3 = m.transform_point(item.end_point() + currentPoint - origin) +
          origin;
        v.emplace_back(in_place_type_t<path_factory::path_abs_curve>, pt1, pt2,
          pt3);
        currentPoint = item.end_point() + currentPoint;
      }
      else if constexpr(std::is_same_v<T, path_factory::path_arc_clockwise>) {
        auto ctr = item.center();
        auto rad = item.radius();
        auto ang1 = item.angle_1();
        auto ang2 = item.angle_2();
        while(ang2 < ang1) {
          ang2 += two_pi<double>;
        }
        vector_2d pt0, pt1, pt2, pt3;
        int bezCount = 1;
        double theta = ang2 - ang1;
        double phi;
        while (theta >= halfpi) {
          theta /= 2.0;
          bezCount += bezCount;
        }
        phi = theta / 2.0;
        auto cosPhi = cos(phi);
        auto sinPhi = sin(phi);
        pt0.x(cosPhi);
        pt0.y(-sinPhi);
        pt3.x(pt0.x());
        pt3.y(-pt0.y());
        pt1.x((4.0 - cosPhi) / 3.0);
        pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
        pt2.x(pt1.x());
        pt2.y(-pt1.y());
        phi = -phi;
        auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
          return { pt.x() * cos(a) + pt.y() * sin(a),
            -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
        };
        pt0 = rotCwFn(pt0, phi);
        pt1 = rotCwFn(pt1, phi);
        pt2 = rotCwFn(pt2, phi);
        pt3 = rotCwFn(pt3, phi);
        
        auto currTheta = ang1;
        const auto startPt =
        ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
        if (hasCurrentPoint) {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_abs_line>, pt);
        }
        else {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt);
          hasCurrentPoint = true;
          closePt = pt;
        }
        for (; bezCount > 0; bezCount--) {
          auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad }, currTheta);
          auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad },
            currTheta);
          auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad },
            currTheta);
          currentPoint = cpt3;
          cpt1 = m.transform_point(cpt1 - origin) + origin;
          cpt2 = m.transform_point(cpt2 - origin) + origin;
          cpt3 = m.transform_point(cpt3 - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_abs_curve>, cpt1,
            cpt2, cpt3);
          currTheta += theta;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_arc_counterclockwise>) {
      {
        auto ctr = item.center();
        auto rad = item.radius();
        auto ang1 = item.angle_1();
        auto ang2 = item.angle_2();
        while(ang2 > ang1) {
          ang2 -= two_pi<double>;
        }
        vector_2d pt0, pt1, pt2, pt3;
        int bezCount = 1;
        double theta = ang1 - ang2;
        double phi;
        while (theta >= halfpi) {
          theta /= 2.0;
          bezCount += bezCount;
        }
        phi = theta / 2.0;
        auto cosPhi = cos(phi);
        auto sinPhi = sin(phi);
        pt0.x(cosPhi);
        pt0.y(-sinPhi);
        pt3.x(pt0.x());
        pt3.y(-pt0.y());
        pt1.x((4.0 - cosPhi) / 3.0);
        pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
        pt2.x(pt1.x());
        pt2.y(-pt1.y());
        auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
          return { pt.x() * cos(a) + pt.y() * sin(a),
            -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
        };
        pt0 = rotCwFn(pt0, phi);
        pt1 = rotCwFn(pt1, phi);
        pt2 = rotCwFn(pt2, phi);
        pt3 = rotCwFn(pt3, phi);
        auto shflPt = pt3;
        pt3 = pt0;
        pt0 = shflPt;
        shflPt = pt2;
        pt2 = pt1;
        pt1 = shflPt;
        auto currTheta = ang1;
        const auto startPt =
          ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
        if (hasCurrentPoint) {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_abs_line>, pt);
        }
        else {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_abs_move>, pt);
          hasCurrentPoint = true;
          closePt = pt;
        }
        for (; bezCount > 0; bezCount--) {
          auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad },
            currTheta);
          auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad },
            currTheta);
          auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad },
            currTheta);
          currentPoint = cpt3;
          cpt1 = m.transform_point(cpt1 - origin) + origin;
          cpt2 = m.transform_point(cpt2 - origin) + origin;
          cpt3 = m.transform_point(cpt3 - origin) + origin;
          v.emplace_back(in_place_type_t<path_factory::path_curve_to>, cpt1,
            cpt2, cpt3);
          currTheta -= theta;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_change_matrix>) {
        m = item.matrix();
      }
      else if constexpr(std::is_same_v<T, path_factory::path_change_origin>) {
        origin = item.origin();
      }
    }, val);
  }
\end{codeblock}

%\rSec1 [pathgeometries.strokerules] {Stroking path geometries}
%
%\pnum
%The following rules shall apply when a Stroking operation (\ref{surface.stroking}) is carried out on a path geometry.
%
%\begin{enumerate}
%\item If the path geometry only contains a degenerate path segment, then if the \tcode{line_cap} value is
%\end{enumerate}
%
%\begin{enumerate}
%  \item Except as otherwise specified in these rules, the start point and end point of a path segment shall be rendered as specified by the meaning of the surface's current \tcode{line_cap} value (\ref{linecap}).
%  
%  \item If the end point of a path segment \textit{a} is set as the current point and is then used as the start point of another path segment, \textit{b}, the point where \tcode{a}'s end point meets \tcode{b}'s start point shall be rendered as specified by the meaning of the surface's current \tcode{line_join} value (\ref{linejoin}).
%  
%  \item ***FIXME***
%\end{enumerate}
%
%\rSec1 [pathgeometries.fillrules] {Filling path geometries}
%
%\pnum
%***FIXME***

\addtocounter{SectionDepthBase}{1}
%\input{path-processing}
%\input{path-data-type}
%\input{path-data-item}
\input{path}
\input{path-factory}
\addtocounter{SectionDepthBase}{1}
%\input{path-data}
\input{arc}
\input{arc-negative}
\input{change-matrix}
\input{change-origin}
\input{close-path}
\input{curve-to}
\input{line-to}
\input{move-to}
\input{new-sub-path}
\input{rel-curve-to}
\input{rel-line-to}
\input{rel-move-to}
%\input{path-data-item-get}
\addtocounter{SectionDepthBase}{-1}
\addtocounter{SectionDepthBase}{-1}
