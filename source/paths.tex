%!TEX root = io2d.tex

\rSec0 [paths] {Paths}

\pnum
Paths define geometric objects which can be stroked (Table~\ref{tab:surface.rendering.operations}), filled, masked, and used to define or modify a Clip Area (Table~\ref{tab:surface.state.listing}).

\pnum
Paths are created using a \tcode{path_factory} object, which stores a path group. 

\pnum
Paths provide vector graphics functionality. As such they are particularly useful in situations where an application is intended to run on a variety of platforms whose output devices (\ref{displaysurface.intro}) span a large gamut of sizes, both in terms of measurement units and in terms of a horizontal and vertical pixel count, in that order. For example, a pixel count expressed as 1280x720 means that there are 1280 horizontal pixels per row of pixels and 720 vertical pixels per column of pixels for a total of 921600 pixels.
%
%\pnum
%For output devices, the measurement size of a pixel is determined by the physical size of the output device. Many output devices represent pixels as having the same horizontal and vertical measurement sizes. As such, when they display a rendered image which does not have the same horizontal to vertical pixel ratio as the output device, it 

\pnum
A path may contain degenerate path segments because of special rules, which are set forth below.

\pnum
A \tcode{path_group} object is an immutable resource wrapper containing a path group (\ref{pathgroup}). A \tcode{path_group} object is created from a \tcode{path_factory} object. It can also be default constructed, in which case the \tcode{path_group} object contains no paths.

\rSec1 [paths.processing] {Processing paths}

\pnum
This section describes how to convert the path group of a a properly formed \tcode{path_factory} object from a collection of path instruction and path segments to a path group that consists entirely of path segments.

\pnum
The \tcode{native_path_group} class, described below, is informative. It is used to demonstrate how to perform this process. 

\pnum
The \tcode{native_path_group} class has the following state data, the types of which are unspecified:

\begin{libreqtab2}
	{\tcode{native_path_group} state data}
	{tab:paths.processing.natpathgroup}
	\\ \topline
	\lhdr{Name}
	& \rhdr{Use}
	\\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}
	& \rhdr{Use}
	\\ \capsep
	\endhead
	Current Point
	& The start point for a path segment that is added to the Current Path Geometry.
	\\
	Close Point
	& The start point for the initial path segment in the Current Path Geometry.
	\\
	Current Path Geometry
	& The path geometry to which path segments are added.
	\\
	Collection
	& The collection of all path geometries added to the \tcode{native_path_group} object. A new path geometry that is added to the collection is added to the end of the collection.
	\\
\end{libreqtab2}

\begin{codeblock}
	// \textit{This class is }\expos
	class native_path_group {
		public:
		void current_point(const vector_2d& pt) noexcept;
		void close_point(const vector_2d& pt) noexcept;
		void line_to(const vector_2d& pt) noexcept;
		void curve_to(const vector_2d& control1, const vector_2d& control2,
		const vector_2d& endPt) noexcept;
		void close_path() noexcept;
	};
\end{codeblock}

\begin{itemdecl}
	void current_point(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If the last member function called was not \tcode{current_point} or if the Collection contains no path geometries, a new path geometry is created, added to the Collection, and set as the Current Path Geometry.
	
	\pnum
	If a new path geometry is created and the Collection contained at least one path geometry prior to this member function being called, then unless the last member function called was \tcode{close_path}, the previous Current Path Geometry shall be an open path geometry.
	
	\pnum
	Sets \tcode{pt} as the Current Point.
\end{itemdescr}

\begin{itemdecl}
	void close_point(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\preconditions
	There is a Current Path Geometry.
	
	\pnum
	\effects
	Sets \tcode{pt} as the Close Point.
	
\end{itemdescr}

\begin{itemdecl}
	void line_to(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\preconditions
	There is a Current Path Geometry.
	
	\pnum
	\effects
	Creates a line segment from the Current Point to \tcode{pt} and adds it to the Current Path Geometry.
	
\end{itemdescr}

\begin{itemdecl}
	void curve_to(const vector_2d& cpt1, const vector_2d& cpt2,
	const vector_2d& endPt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\preconditions
	There is a Current Path Geometry.
	
	\pnum
	\effects
	Creates a cubic B\'ezier curve from the Current Point to \tcode{endPt} using \tcode{cpt1} as the first control point and \tcode{cpt2} as the second control point and adds it to the Current Path Geometry.
	
\end{itemdescr}

\begin{itemdecl}
	void close_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\preconditions
	There is a Current Path Geometry.
	
	\pnum
	\effects
	Creates a line segment from the Current Point to the Close Point.
	
	\pnum
	The Current Path Geometry becomes a closed path geometry.
	
\end{itemdescr}

\pnum
\enternote
A path geometry graphics resource that only supports rendering triangles is possible. The triangles would be used to form lines and to approximate curves. This description assumes the existence of a path geometry graphics resource that performs those actions where needed.
\exitnote

\pnum
The following code shows how to properly process a \tcode{path_factory} object \tcode{p} and store the results into \tcode{native_path_group n}:

\begin{codeblock}
  const double pi =     3.1415926535897932384626433832795;
  const double halfpi = 1.57079632679489661923132169163985;
  const double twopi =  6.283185307179586476925286766559;
  matrix_2d m;
  vector_2d origin;
  vector_2d currentPoint;
  bool hasCurrentPoint = false;
  vector_2d closePoint;
  native_geometry_group n;
  
  for (auto v : p) {
    std::visit([&](auto&& item) {
      using T = std::remove_cv_t<std::remove_reference_t<decltype item>>;

      if constexpr(std::is_same_v<T, path_factory::path_move_to>) {
        currentPoint = item.to();
        auto pt = m.transform_point(currentPoint - origin) + origin;
        n.current_point(pt);
        hasCurrentPoint = true;
        closePoint = pt
        n.close_point(pt);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_line_to>) {
        currentPoint = item.to();
        auto pt = m.transform_point(currentPoint - origin) + origin;
        if (hasCurrentPoint) {
          n.line_to(pt);
        }
        else {
          n.current_point(pt);
          hasCurrentPoint = true;
          closePoint = pt;
          n.close_point(pt);
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_curve_to>) {
        auto pt1 = m.transform_point(item.control_point_1() - origin) + origin;
        auto pt2 = m.transform_point(item.control_point_2() - origin) + origin;
        auto pt3 = m.transform_point(item.end_point() - origin) + origin;
        if (!hasCurrentPoint) {
          currentPoint = item.control_point_1();
          n.current_point(pt1);
          hasCurrentPoint = true;
          closePoint = pt1;
          n.close_point(pt1);
        }
        n.curve_to(pt1, pt2, pt3);
        currentPoint = item.end_point();
      }
      else if constexpr(std::is_same_v<T, path_factory::path_new_path>) {
        hasCurrentPoint = false;
      }
      else if constexpr(std::is_same_v<T, path_factory::path_close_path>) {
        if (hasCurrentPoint) {
          n.close_path();
          n.current_point(closePoint);
          auto invM = matrix_2d{m}.invert();
          // Need the untransformed value for currentPoint.
          currentPoint = invM.transform_point(closePoint - origin) + origin;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_move_to>) {
        currentPoint = item.to() + currentPoint;
        auto pt = m.transform_point(currentPoint - origin) + origin;
        n.current_point(pt);
        hasCurrentPoint = true;
        closePoint = pt    
        n.close_point(pt);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_line_to>) {
        currentPoint = item.to() + currentPoint;
        auto pt = m.transform_point(currentPoint - origin) + origin;
        n.line_to(pt);
      }
      else if constexpr(std::is_same_v<T, path_factory::path_rel_curve_to>) {
        auto pt1 = m.transform_point(item.control_point_1() + currentPoint -
        origin) + origin;
        auto pt2 = m.transform_point(item.control_point_2() + currentPoint -
        origin) + origin;
        auto pt3 = m.transform_point(item.end_point() + currentPoint - origin) +
        origin;
        n.curve_to(pt1, pt2, pt3);
        currentPoint = item.end_point() + currentPoint;
      }
      else if constexpr(std::is_same_v<T, path_factory::path_arc_clockwise>) {
        auto ctr = item.center();
        auto rad = item.radius();
        auto ang1 = item.angle_1();
        auto ang2 = item.angle_2();
        while(ang2 < ang1) {
          ang2 += twopi;
        }
        vector_2d pt0, pt1, pt2, pt3;
        int bezCount = 1;
        double theta = ang2 - ang1;
        double phi;
        while (theta >= halfpi) {
          theta /= 2.0;
          bezCount += bezCount;
        }
        phi = theta / 2.0;
        auto cosPhi = cos(phi);
        auto sinPhi = sin(phi);
        pt0.x(cosPhi);
        pt0.y(-sinPhi);
        pt3.x(pt0.x());
        pt3.y(-pt0.y());
        pt1.x((4.0 - cosPhi) / 3.0);
        pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
        pt2.x(pt1.x());
        pt2.y(-pt1.y());
        phi = -phi;
        auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
          return { pt.x() * cos(a) + pt.y() * sin(a),
            -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
        };
        pt0 = rotCwFn(pt0, phi);
        pt1 = rotCwFn(pt1, phi);
        pt2 = rotCwFn(pt2, phi);
        pt3 = rotCwFn(pt3, phi);
        
        auto currTheta = ang1;
        const auto startPt =
        ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
        if (hasCurrentPoint) {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          n.line_to(pt);
        }
        else {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          n.current_point(pt);
          hasCurrentPoint = true;
          closePt = pt;
          n.close_point(pt);
        }
        for (; bezCount > 0; bezCount--) {
          auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad }, currTheta);
          auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad }, currTheta);
          auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad }, currTheta);
          currentPoint = cpt3;
          cpt1 = m.transform_point(cpt1 - origin) + origin;
          cpt2 = m.transform_point(cpt2 - origin) + origin;
          cpt3 = m.transform_point(cpt3 - origin) + origin;
          n.curve_to(cpt1, cpt2, cpt3);
          currTheta += theta;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_arc_counterclockwise>) {
      {
        auto ctr = item.center();
        auto rad = item.radius();
        auto ang1 = item.angle_1();
        auto ang2 = item.angle_2();
        while(ang2 > ang1) {
          ang2 -= twopi;
        }
        vector_2d pt0, pt1, pt2, pt3;
        int bezCount = 1;
        double theta = ang1 - ang2;
        double phi;
        while (theta >= halfpi) {
          theta /= 2.0;
          bezCount += bezCount;
        }
        phi = theta / 2.0;
        auto cosPhi = cos(phi);
        auto sinPhi = sin(phi);
        pt0.x(cosPhi);
        pt0.y(-sinPhi);
        pt3.x(pt0.x());
        pt3.y(-pt0.y());
        pt1.x((4.0 - cosPhi) / 3.0);
        pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
        pt2.x(pt1.x());
        pt2.y(-pt1.y());
        auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
          return { pt.x() * cos(a) + pt.y() * sin(a),
            -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
        };
        pt0 = rotCwFn(pt0, phi);
        pt1 = rotCwFn(pt1, phi);
        pt2 = rotCwFn(pt2, phi);
        pt3 = rotCwFn(pt3, phi);
        auto shflPt = pt3;
        pt3 = pt0;
        pt0 = shflPt;
        shflPt = pt2;
        pt2 = pt1;
        pt1 = shflPt;
        auto currTheta = ang1;
        const auto startPt =
        ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
        if (hasCurrentPoint) {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          n.line_to(pt);
        }
        else {
          currentPoint = startPt;
          auto pt = m.transform_point(currentPoint - origin) + origin;
          n.current_point(pt);
          hasCurrentPoint = true;
          closePt = pt;
          n.close_point(pt);
        }
        for (; bezCount > 0; bezCount--) {
          auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad }, currTheta);
          auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad }, currTheta);
          auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad }, currTheta);
          currentPoint = cpt3;
          cpt1 = m.transform_point(cpt1 - origin) + origin;
          cpt2 = m.transform_point(cpt2 - origin) + origin;
          cpt3 = m.transform_point(cpt3 - origin) + origin;
          n.curve_to(cpt1, cpt2, cpt3);
          currTheta -= theta;
        }
      }
      else if constexpr(std::is_same_v<T, path_factory::path_change_matrix>) {
        m = item.matrix();
      }
      else if constexpr(std::is_same_v<T, path_factory::path_change_origin>) {
        origin = item.origin();
      }
    }, v);
  }
\end{codeblock}

%\rSec1 [pathgeometries.strokerules] {Stroking path geometries}
%
%\pnum
%The following rules shall apply when a Stroking operation (\ref{surface.stroking}) is carried out on a path geometry.
%
%\begin{enumerate}
%\item If the path geometry only contains a degenerate path segment, then if the \tcode{line_cap} value is
%\end{enumerate}
%
%\begin{enumerate}
%  \item Except as otherwise specified in these rules, the start point and end point of a path segment shall be rendered as specified by the meaning of the surface's current \tcode{line_cap} value (\ref{linecap}).
%  
%  \item If the end point of a path segment \textit{a} is set as the current point and is then used as the start point of another path segment, \textit{b}, the point where \tcode{a}'s end point meets \tcode{b}'s start point shall be rendered as specified by the meaning of the surface's current \tcode{line_join} value (\ref{linejoin}).
%  
%  \item ***FIXME***
%\end{enumerate}
%
%\rSec1 [pathgeometries.fillrules] {Filling path geometries}
%
%\pnum
%***FIXME***

\addtocounter{SectionDepthBase}{1}
%\input{path-processing}
%\input{path-data-type}
%\input{path-data-item}
\input{path}
\input{path-factory}
\addtocounter{SectionDepthBase}{1}
%\input{path-data}
\input{arc}
\input{arc-negative}
\input{change-matrix}
\input{change-origin}
\input{close-path}
\input{curve-to}
\input{line-to}
\input{move-to}
\input{new-sub-path}
\input{rel-curve-to}
\input{rel-line-to}
\input{rel-move-to}
%\input{path-data-item-get}
\addtocounter{SectionDepthBase}{-1}
\addtocounter{SectionDepthBase}{-1}
