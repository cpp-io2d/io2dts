%!TEX root = io2d.tex

\rSec2 [\iotwod.graphsurf.reqs.paths]{\tcode{paths} requirements}

\pnum
Paths are described in \ref{\iotwod.paths}.

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
Let \tcode{G} be \tcode{X::graphics_math_type}.

\pnum
Table~\ref{tab:\iotwod.graphsurf.paths.requirementstab} describes the observable effects of the member functions of \tcode{X::paths}.

\pnum
Table~\ref{tab:\iotwod.graphsurf.reqs.paths.typedefnamestab} defines the required \grammarterm{typedef-name}{s} in \tcode{X::paths}, which are identifiers for class types capable of storing all data required to support the corresponding class template.

\begin{libreqtab2}{\tcode{X::paths} typedef-names}{tab:\iotwod.graphsurf.reqs.paths.typedefnamestab}
\\ \topline
\lhdr{\grammarterm{typedef-name}}       &
\rhdr{Class data}   \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{\grammarterm{typedef-name}}       &
\rhdr{Class template}   \\ \capsep
\endhead
\tcode{abs_cubic_curve_data_type}	&
\tcode{basic_figure_items<X>::abs_cubic_curve}	\\ \rowsep
\tcode{abs_line_data_type}	&
\tcode{basic_figure_items<X>::abs_line}	\\ \rowsep
\tcode{abs_matrix_data_type}	&
\tcode{basic_figure_items<X>::abs_matrix}	\\ \rowsep
\tcode{abs_new_figure_data_type}	&
\tcode{basic_figure_items<X>::abs_new_figure}	\\ \rowsep
\tcode{abs_quadratic_curve_data_type}	&
\tcode{basic_figure_items<X>::abs_quadratic_curve}	\\ \rowsep
\tcode{arc_data_type}	&
\tcode{basic_figure_items<X>::arc}	\\ \rowsep
\tcode{close_figure_data_type}	&
\tcode{basic_figure_items<X>::close_data}	\\ \rowsep
\tcode{interpreted_path_data_type}	&
\tcode{basic_interpreted_path<X>}	\\ \rowsep
\tcode{rel_cubic_curve_data_type}	&
\tcode{basic_figure_items<X>::rel_cubic_curve}	\\ \rowsep
\tcode{rel_line_data_type}	&
\tcode{basic_figure_items<X>::rel_line}	\\ \rowsep
\tcode{rel_matrix_data_type}	&
\tcode{basic_figure_items<X>::rel_matrix}	\\ \rowsep
\tcode{rel_new_figure_data_type}	&
\tcode{basic_figure_items<X>::rel_new_figure}	\\ \rowsep
\tcode{rel_quadratic_curve_data_type}	&
\tcode{basic_figure_items<X>::rel_quadratic_curve}	\\ \rowsep
\tcode{revert_matrix_data_type}	&
\tcode{basic_figure_items<X>::revert_matrix}	\\
\end{libreqtab2}

\pnum
\begin{note}
An object of type \tcode{basic_interpreted_path<X>} is an immutable object. As such, the contents of the class type for which \tcode{X::paths::interpreted_path_data_type} is an identifier are able to be highly tailored to the platform and environment targeted by \tcode{X}.
\end{note}

\pnum
In Table~\ref{tab:\iotwod.graphsurf.paths.requirementstab},
\tcode{AC} denotes the type \tcode{X::paths::abs_cubic_curve_data_type}, \tcode{AL} denotes the type \tcode{X::paths::abs_line_data_type},
\tcode{AM} denotes the type \tcode{X::paths::abs_matrix_data_type},
\tcode{AN} denotes the type \tcode{X::paths::abs_new_figure_data_type},
\tcode{AQ} denotes the type \tcode{X::paths::abs_quadratic_curve_data_type},
\tcode{ARC} denotes the type \tcode{X::paths::arc_data_type},
\tcode{IP} denotes the type \tcode{X::paths::interpreted_path_data_type},
\tcode{RC} denotes the type \tcode{X::paths::rel_cubic_curve_data_type},
\tcode{RL} denotes the type \tcode{X::paths::rel_line_data_type},
\tcode{RM} denotes the type \tcode{X::paths::rel_matrix_data_type},
\tcode{RN} denotes the type \tcode{X::paths::rel_new_figure_data_type},
\tcode{RQ} denotes the type \tcode{X::paths::rel_quadratic_curve_data_type},
\tcode{M} denotes the type \tcode{basic_matrix_2d<X::graphics_math_type}, and
\tcode{P} denotes the type \tcode{basic_point_2d<X::graphics_math_type>}.

\pnum
In order to describe the observable effects of functions contained in Table~\ref{tab:\iotwod.graphsurf.paths.requirementstab}, Table~\ref{tab:\iotwod.graphsurf.paths.typememberdata} describes the types contained in \tcode{X} as-if they possessed certain member data. 

\pnum
\begin{note}
Certain types do not require any member data to describe the observable effects of the functions they are used by and thus do not appear in Table~(\ref{tab:\iotwod.graphsurf.paths.typememberdata}).
\end{note}

\begin{libiotwodreqtab3f}{\tcode{X::paths} type member data}{tab:\iotwod.graphsurf.paths.typememberdata}
\\ \topline
\lhdr{Type}		&	\chdr{Member data}	&	\rhdr{Member data type} \\ \capsep
\endfirsthead
\topline
\lhdr{Type}		&	\chdr{Member data}	&	\rhdr{Member data type} \\ \capsep
\endhead
\tcode{abs_cubic_curve_data_type}	&
\tcode{cpt1}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_cubic_curve_data_type}	&
\tcode{cpt2}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_cubic_curve_data_type}	&
\tcode{ept}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_line_data_type}	&
\tcode{pt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_matrix_data_type}	&
\tcode{m}	&
\tcode{basic_matrix_2d<G>}	\\ \rowsep
\tcode{abs_new_figure_data_type}	&
\tcode{pt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_quadratic_curve_data_type}	&
\tcode{cpt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{abs_quadratic_curve_data_type}	&
\tcode{ept}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{arc_data_type}	&
\tcode{rad}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{arc_data_type}	&
\tcode{rot}	&
\tcode{float}	\\ \rowsep
\tcode{arc_data_type}	&
\tcode{sa}	&
\tcode{float}	\\ \rowsep
\tcode{rel_cubic_curve_data_type}	&
\tcode{cpt1}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_cubic_curve_data_type}	&
\tcode{cpt2}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_cubic_curve_data_type}	&
\tcode{ept}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_line_data_type}	&
\tcode{pt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_matrix_data_type}	&
\tcode{m}	&
\tcode{basic_matrix_2d<G>}	\\ \rowsep
\tcode{rel_new_figure_data_type}	&
\tcode{pt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_quadratic_curve_data_type}	&
\tcode{cpt}	&
\tcode{basic_point_2d<G>}	\\ \rowsep
\tcode{rel_quadratic_curve_data_type}	&
\tcode{ept}	&
\tcode{basic_point_2d<G>}	\\
\end{libiotwodreqtab3f}

\begin{libreqtab4d}
{\tcode{X::paths} requirements}
{tab:\iotwod.graphsurf.paths.requirementstab}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\rhdr{Assertion/note}   \\
    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\rhdr{Assertion/note}   \\
    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
%%
%% abs_cubic_curve
%%
\tcode{X::paths::create_abs_cubic_curve()}	&
\tcode{AC}	&
\effects
Equivalent to \tcode{return create_abs_cubic_curve(P(), P(), P());}	&
	\\ \rowsep
\tcode{X::paths::create_abs_cubic_curve(const P\& cpt1, const P\& cpt2, const P\& ept)}	&
\tcode{abs_cubic_curve_data_type}	&
\returns
An object \tcode{ac}.	&
\postconditions
\tcode{ac.cpt1 == cpt1}, \tcode{ac.cpt2 == cpt2}, and \tcode{ac.ept == ept}.	\\ \rowsep
\tcode{X::paths::control_pt1(AC\& ac, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{ac.cpt1 == pt}.	\\ \rowsep
\tcode{X::paths::control_pt2(AC\& ac, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{ac.cpt2 == pt}.	\\ \rowsep
\tcode{X::paths::end_pt(AC\& ac, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{ac.ept == pt}.	\\ \rowsep
\tcode{X::paths::control_pt1(const AC\& ac)}	&
\tcode{P}	&
\returns
\tcode{ac.cpt1}.	&
	\\ \rowsep
\tcode{X::paths::control_pt2(const AC\& ac)}	&
\tcode{P}	&
\returns
\tcode{ac.cpt2}.	&
	\\ \rowsep
\tcode{X::paths::end_pt(const AC\& ac)}	&
\tcode{P}	&
\returns
\tcode{ac.ept}.	&
	\\ \rowsep
%%
%% abs_line
%%
\tcode{X::paths::create_abs_line()}	&
\tcode{AL}	&
\effects
Equivalent to \tcode{return create_abs_line(P{});}	&
	\\ \rowsep
\tcode{X::paths::create_abs_line(const P\& p)}	&
\tcode{AL}	&
\returns
An object \tcode{al}.	&
\postconditions
\tcode{al.pt == p}.	\\ \rowsep
\tcode{X::paths::to(AL\& al, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{al.pt == p}.	\\ \rowsep
\tcode{X::paths::to(const AL\& al)}	&
\tcode{P}	&
\returns
\tcode{al.pt}.	&
	\\ \rowsep
%%
%% abs_matrix
%%
\tcode{X::paths::create_abs_matrix()}	&
\tcode{AM}	&
Equivalent to \tcode{return create_abs_matrix(M());}	&
	\\ \rowsep
\tcode{X::paths::create_abs_matrix(const M\& m)}	&
\tcode{AM}	&
\returns
An object \tcode{am}.	&
\postconditions
\tcode{am.m == m}.	\\ \rowsep
\tcode{X::paths::matrix(AM\& am, const M\& m)}	&
\tcode{void}	&
	&
\postconditions
\tcode{am.m == m}.	\\ \rowsep
\tcode{X::paths::matrix(const AM\& am)}	&
\tcode{M}	&
\returns
\tcode{am.m}.	&
	\\ \rowsep
%%
%% abs_new_figure
%%
\tcode{X::paths::create_abs_new_figure()}	&
\tcode{AN}	&
\effects Equivalent to \tcode{return create_abs_new_figure(P());}	&
	\\ \rowsep
\tcode{X::paths::create_abs_new_figure(const P\& p)}	&
\tcode{AN}	&
\returns
An object \tcode{an}.	&
\postconditions
\tcode{an.pt == p}.	\\ \rowsep
\tcode{X::paths::at(AN\& an, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{an.pt == p}.	\\ \rowsep
\tcode{X::paths::at(const AN\& an)}	&
\tcode{P}	&
\returns
\tcode{an.pt}.	&
	\\ \rowsep
%%
%% abs_quadratic_curve
%%
\tcode{X::paths::create_abs_quadratic_curve()}	&
\tcode{AQ}	&
Equivalent to \tcode{return create_abs_quadratic_curve(P(), P());}	&
	\\ \rowsep
\tcode{X::paths::create_abs_quadratic_curve(const P\& cpt, const P\& ept)}	&
\tcode{AQ}	&
\returns
An object \tcode{aq}.	&
\postconditions
\tcode{aq.cpt == cpt} and \tcode{aq.ept == ept}.	\\ \rowsep
\tcode{X::paths::control_pt(AQ\& aq, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{aq.cpt == p}.	\\ \rowsep
\tcode{X::paths::end_pt(AQ\& aq, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{aq.ept == p}.	\\ \rowsep
\tcode{X::paths::control_pt(const AQ\& aq)}	&
\tcode{P}	&
\returns
\tcode{aq.cpt}.	&
	\\ \rowsep
\tcode{X::paths::end_pt(const AQ\& aq)}	&
\tcode{P}	&
\returns
\tcode{aq.ept}.	&
	\\ \rowsep
%%
%% arc
%%
\tcode{X::paths::create_arc()}	&
\tcode{ARC}	&
\effects
Equivalent to \tcode{return create_arc(P(), 0.0f, 0.0f);}	&
	\\ \rowsep
\tcode{X::paths::create_arc(const P\& rad, float rot, float sa)}	&
\tcode{ARC}	&
\returns
An object \tcode{arc}.	&
\postconditions
\tcode{arc.rad == rad}, \tcode{arc.rot == rot}, and \tcode{arc.sa == sa}.	\\ \rowsep
\tcode{X::paths::radius(ARC\& arc, const P\& rad)}	&
\tcode{void}	&
	&
\postconditions
\tcode{arc.rad == rad}.	\\ \rowsep
\tcode{X::paths::rotation(ARC\& arc, float rot)}	&
\tcode{void}	&
	&
\postconditions
\tcode{arc.rot == rot}.	\\ \rowsep
\tcode{X::paths::start_angle(ARC\& arc, float sa)}	&
\tcode{void}	&
	&
\postconditions
\tcode{arc.sa == sa}.	\\ \rowsep
\tcode{X::paths::radius(const ARC\& arc)}	&
\tcode{P}	&
\returns
\tcode{arc.rad}.	&
	\\ \rowsep
\tcode{X::paths::rotation(const ARC\& arc)}	&
\tcode{float}	&
\returns
\tcode{arc.rot}.	&
	\\ \rowsep
\tcode{X::paths::start_angle(const ARC\& arc)}	&
\tcode{float}	&
\returns
\tcode{arc.sa}.	&
	\\ \rowsep
\tcode{X::paths::center(const ARC\& arc, const P\& spt, const M\& m)}	&
\tcode{P}	&
\returns
As-if: \tcode{\newline
auto lmtx = m;\newline
lmtx.m20 = 0.0f;\newline
lmtx.m21 = 0.0f;\newline
auto ctrOffset =\newline
\hspace*{1em}point_for_angle<G>(\newline
\hspace*{1em}two_pi<float> - arc.sa,\newline
\hspace*{1em}arc.rad);\newline
ctrOffset.y(-ctrOffset.y);\newline
return spt - ctrOffset *\newline
\hspace*{1em}lmtx;}	&
\begin{note}
\tcode{spt} is the starting point of the arc. \tcode{m} is the transformation matrix being used.
\end{note}	\\ \rowsep
\tcode{X::paths::end_pt(const ARC\& arc, const P\& spt, const M\& m)}	&
\tcode{P}	&
\returns
As-if: \tcode{\newline
auto lmtx = m;\newline
lmtx.m20 = 0.0f;\newline
lmtx.m21 = 0.0f;\newline
auto tfrm = M::create_rotate(arc.sa +\newline
\hspace*{1em}arc.rot);\newline
auto pt = arc.rad * tfrm;\newline
pt.y(-pt.y());\newline
return spt + pt * lmtx;
}	&
\begin{note}
\tcode{spt} is the starting point of the arc. \tcode{m} is the transformation matrix being used.
\end{note}	\\ \rowsep
%%
%% interpreted_path
%%
\tcode{X::paths::create_interpreted_path()}	&
\tcode{IP}	&
\returns
An object \tcode{ip}.	&
\postconditions
\tcode{ip} has zero figures (See: \ref{\iotwod.paths.interpretation})	\\ \rowsep
\tcode{template <class ForwardIterator>\newline
X::paths::create_interpreted_path<ForwardIterator first, ForwardIterator last}	&
\tcode{IP}	&
\returns
An object \tcode{ip}.	&
\postconditions
\tcode{ip} contains a zero or more figure items as determined by evaluating the sequence of \tcode{figure_items::figure_item} objects beginning with \tcode{first} and ending with \tcode{last} in the manner described in \ref{\iotwod.paths.interpretation}.\newline
\remarks
The internal data of the interpreted path should be in a form that is best suited to take advantage of the platform and environment targeted by \tcode{X}.	\\ \rowsep
%%
%% rel_cubic_curve
%%
\tcode{X::paths::create_rel_cubic_curve()}	&
\tcode{RC}	&
\effects
Equivalent to \tcode{return create_rel_cubic_curve(P(), P(), P());}	&
	\\ \rowsep
\tcode{X::paths::create_rel_cubic_curve(const P\& cpt1, const P\& cpt2, const P\& ept)}	&
\tcode{RC}	&
\returns
An object \tcode{rc}.	&
\postconditions
\tcode{rc.cpt1 == cpt1}, \tcode{rc.cpt2 == cpt2}, and \tcode{rc.ept == ept}.	\\ \rowsep
\tcode{X::paths::control_pt1(RC\& rc, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rc.cpt1 == pt}.	\\ \rowsep
\tcode{X::paths::control_pt2(RC\& rc, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rc.cpt2 == pt}.	\\ \rowsep
\tcode{X::paths::end_pt(RC\& rc, const P\& pt)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rc.ept == pt}.	\\ \rowsep
\tcode{X::paths::control_pt1(const RC\& a)}	&
\tcode{P}	&
\returns
\tcode{rc.cpt1}.	&
	\\ \rowsep
\tcode{X::paths::control_pt2(const RC\& rc)}	&
\tcode{P}	&
\returns
\tcode{rc.cpt2}.	&
	\\ \rowsep
\tcode{X::paths::end_pt(const RC\& rc)}	&
\tcode{P}	&
\returns
\tcode{rc.ept}.	&
	\\ \rowsep
%%
%% rel_line
%%
\tcode{X::paths::create_rel_line()}	&
\tcode{RL}	&
\effects
Equivalent to \tcode{return create_rel_line(P{});}	&
	\\ \rowsep
\tcode{X::paths::create_rel_line(const P\& p)}	&
\tcode{RL}	&
\returns
An object \tcode{rl}.	&
\postconditions
\tcode{rl.pt == p}.	\\ \rowsep
\tcode{X::paths::to(RL\& al, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rl.pt == p}.	\\ \rowsep
\tcode{X::paths::to(const RL\& rl)}	&
\tcode{P}	&
\returns
\tcode{rl.pt}.	&
	\\ \rowsep
%%
%% rel_matrix
%%
\tcode{X::paths::create_rel_matrix()}	&
\tcode{RM}	&
Equivalent to \tcode{return create_rel_matrix(M());}	&
	\\ \rowsep
\tcode{X::paths::create_rel_matrix(const M\& m)}	&
\tcode{RM}	&
\returns
An object \tcode{rm}.	&
\postconditions
\tcode{rm.m == m}.	\\ \rowsep
\tcode{X::paths::matrix(RM\& am, const M\& m)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rm.m == m}.	\\ \rowsep
\tcode{X::paths::matrix(const RM\& rm)}	&
\tcode{M}	&
\returns
\tcode{am.m}.	&
	\\ \rowsep
%%
%% rel_new_figure
%%
\tcode{X::paths::create_rel_new_figure()}	&
\tcode{RN}	&
\effects Equivalent to \tcode{return create_rel_new_figure(P());}	&
	\\ \rowsep
\tcode{X::paths::create_rel_new_figure(const P\& p)}	&
\tcode{RN}	&
\returns
An object \tcode{rn}.	&
\postconditions
\tcode{rn.pt == p}.	\\ \rowsep
\tcode{X::paths::at(RN\& rn, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rn.pt == p}.	\\ \rowsep
\tcode{X::paths::at(const RN\& rn)}	&
\tcode{P}	&
\returns
\tcode{rn.pt}.	&
	\\ \rowsep
%%
%% rel_quadratic_curve
%%
\tcode{X::paths::create_rel_quadratic_curve()}	&
\tcode{RQ}	&
Equivalent to \tcode{return create_rel_quadratic_curve(P(), P());}	&
	\\ \rowsep
\tcode{X::paths::create_rel_quadratic_curve(const P\& cpt, const P\& ept)}	&
\tcode{RQ}	&
\returns
An object \tcode{rq}.	&
\postconditions
\tcode{rq.cpt == cpt} and \tcode{rq.ept == ept}.	\\ \rowsep
\tcode{X::paths::control_pt(RQ\& rq, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rq.cpt == p}.	\\ \rowsep
\tcode{X::paths::end_pt(RQ\& rq, const P\& p)}	&
\tcode{void}	&
	&
\postconditions
\tcode{rq.ept == p}.	\\ \rowsep
\tcode{X::paths::control_pt(const RQ\& rq)}	&
\tcode{P}	&
\returns
\tcode{rq.cpt}.	&
	\\ \rowsep
\tcode{X::paths::end_pt(const RQ\& rq)}	&
\tcode{P}	&
\returns
\tcode{rq.ept}.	&
	\\
\end{libreqtab4d}
