%!TEX root = io2d.tex
\rSec0[\iotwod.syn]{Header \tcode{<experimental/io2d>} synopsis}

\indexlibrary{\idxhdr{experimental/io2d}}%
\indextext{2D graphics!synopsis|(}%
\begin{codeblock}

namespace std { namespace experimental {
  namespace io2d { inline namespace v1 {

  using dashes = tuple<vector<float>, float>;

  enum class wrap_mode;
  enum class filter;
  enum class brush_type;
  enum class antialias;
  enum class fill_rule;
  enum class line_cap;
  enum class line_join;
  enum class compositing_op;
  enum class format;
  enum class scaling;
  enum class refresh_rate;
  enum class image_file_format;

  class rectangle;
  constexpr bool operator==(const rectangle& lhs, const rectangle& rhs) 
    noexcept;
  constexpr bool operator!=(const rectangle& lhs, const rectangle& rhs) 
    noexcept;
  class circle;
  constexpr bool operator==(const circle& lhs, const circle& rhs) noexcept;
  constexpr bool operator!=(const circle& lhs, const circle& rhs) noexcept;

  class rgba_color;
  constexpr bool operator==(const rgba_color& lhs, const rgba_color& rhs) 
    noexcept;
  constexpr bool operator!=(const rgba_color& lhs, const rgba_color& rhs) 
    noexcept;
  template <class T>
  constexpr rgba_color operator*(const rgba_color& lhs, T rhs) noexcept;
  template <class U>
  constexpr rgba_color operator*(const rgba_color& lhs, U rhs) noexcept;
  template <class T>
  constexpr rgba_color operator*(T lhs, const rgba_color& rhs) noexcept;
  template <class U>
  constexpr rgba_color operator*(U lhs, const rgba_color& rhs) noexcept;

  class point_2d;
  constexpr bool operator==(const point_2d& lhs, const point_2d& rhs) 
    noexcept;
  constexpr bool operator!=(const point_2d& lhs, const point_2d& rhs) 
    noexcept;
  constexpr point_2d operator+(const point_2d& lhs) noexcept;
  constexpr point_2d operator+(const point_2d& lhs, const point_2d& rhs) 
    noexcept;
  constexpr point_2d operator-(const point_2d& lhs) noexcept;
  constexpr point_2d operator-(const point_2d& lhs, const point_2d& rhs) 
    noexcept;
  constexpr point_2d operator*(const point_2d& lhs, float rhs) noexcept;
  constexpr point_2d operator*(float lhs, const point_2d& rhs) noexcept;

  class matrix_2d;
  constexpr matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs) 
    noexcept;
  constexpr bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) 
    noexcept;
  constexpr bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs) 
    noexcept;

  namespace path_data {
    class abs_new_path;
    constexpr bool operator==(const abs_new_path&, const abs_new_path&) 
      noexcept;
    constexpr bool operator!=(const abs_new_path&, const abs_new_path&) 
      noexcept;
    class rel_new_path;
    constexpr bool operator==(const rel_new_path&, const rel_new_path&) 
      noexcept;
    constexpr bool operator!=(const rel_new_path&, const rel_new_path&) 
      noexcept;
    class close_path;
    constexpr bool operator==(const close_path&, const close_path&) noexcept;
    constexpr bool operator!=(const close_path&, const close_path&) noexcept;
    class abs_matrix;
    constexpr bool operator==(const abs_matrix&, const abs_matrix&) noexcept;
    constexpr bool operator!=(const abs_matrix&, const abs_matrix&) noexcept;
    class rel_matrix;
    constexpr bool operator==(const rel_matrix&, const rel_matrix&) noexcept;
    constexpr bool operator!=(const rel_matrix&, const rel_matrix&) noexcept;
    class revert_matrix;
    constexpr bool operator==(const revert_matrix&, const revert_matrix&) 
      noexcept;
    constexpr bool operator!=(const revert_matrix&, const revert_matrix&) 
      noexcept;
    class abs_cubic_curve;
    constexpr bool operator==(const abs_cubic_curve&, const abs_cubic_curve&) 
      noexcept;
    constexpr bool operator!=(const abs_cubic_curve&, const abs_cubic_curve&) 
      noexcept;
    class abs_line;
    constexpr bool operator==(const abs_line&, const abs_line&) noexcept;
    constexpr bool operator!=(const abs_line&, const abs_line&) noexcept;
    class abs_quadratic_curve;
    constexpr bool operator==(const abs_quadratic_curve&,
      const abs_quadratic_curve&) noexcept;
    constexpr bool operator!=(const abs_quadratic_curve&,
      const abs_quadratic_curve&) noexcept;
    class arc;
    constexpr bool operator==(const arc&, const arc&) noexcept;
    constexpr bool operator!=(const arc&, const arc&) noexcept;
    class rel_cubic_curve;
    constexpr bool operator==(const rel_cubic_curve&, const rel_cubic_curve&) 
      noexcept;
    constexpr bool operator!=(const rel_cubic_curve&, const rel_cubic_curve&) 
      noexcept;
    class rel_line;
    constexpr bool operator==(const rel_line&, const rel_line&) noexcept;
    constexpr bool operator!=(const rel_line&, const rel_line&) noexcept;
    class rel_quadratic_curve;
    constexpr bool operator==(const rel_quadratic_curve&,
      const rel_quadratic_curve&) noexcept;
    constexpr bool operator!=(const rel_quadratic_curve&,
      const rel_quadratic_curve&) noexcept;
    using path_item = variant<abs_cubic_curve, abs_line, abs_matrix, 
      abs_new_path, abs_quadratic_curve, arc, close_path,
      rel_cubic_curve, rel_line, rel_matrix, rel_new_path, rel_quadratic_curve, 
      revert_matrix>;
  }
  
  class path_group;

  template <class Allocator = allocator<path_data::path_data_types>>
  class path_builder;

  template <class Allocator>
  bool operator==(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs) noexcept;
  template <class Allocator>
  bool operator!=(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs) noexcept;
  
  template <class Allocator>
  void swap(path_builder<Allocator>& lhs, path_builder<Allocator>& rhs)
    noexcept(noexcept(lhs.swap(rhs)));

  class color_stop;
  constexpr bool operator==(const color_stop& lhs, const color_stop& rhs)
    noexcept;
  constexpr bool operator!=(const color_stop& lhs, const color_stop& rhs)
    noexcept;
  class brush;

  class render_props;
  class brush_props;
  class clip_props;
  class stroke_props;
  class mask_props;
    
  class surface;
  class image_surface;
  class display_surface;
  class mapped_surface;
  
  template <class T>
  constexpr T pi = T(3.14159265358979323846264338327950288L);
  template <class T>
  constexpr T two_pi = T(6.28318530717958647692528676655900577L);
  template <class T>
  constexpr T half_pi = T(1.57079632679489661923132169163975144L);
  template <class T>
  constexpr T three_pi_over_two = T(4.71238898038468985769396507491925432L);

  template <class T>
  constexpr T tau = T(6.28318530717958647692528676655900577L);
  template <class T>
  constexpr T three_quarters_tau = T(4.71238898038468985769396507491925432L);
  template <class T>
  constexpr T half_tau = T(3.14159265358979323846264338327950288L);
  template <class T>
  constexpr T quarter_tau = T(1.57079632679489661923132169163975144L);

  int format_stride_for_width(format format, int width) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat,
    scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  image_surface make_image_surface(format format, int width, int height);
  image_surface make_image_surface(format format, int width, int height, 
    error_code& ec) noexcept;
  image_surface copy_image_surface(image_surface& sfc) noexcept;
  float angle_for_point(point_2d ctr, point_2d pt,
    point_2d scl = point_2d{ 1.0f, 1.0f }) noexcept;
  point_2d point_for_angle(float ang, float rad = 1.0f) noexcept;
  point_2d point_for_angle(float ang, point_2d rad) noexcept;
  point_2d arc_start(point_2d ctr, float sang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
  point_2d arc_center(point_2d cpt, float sang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
  point_2d arc_end(point_2d cpt, float eang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
} } } }

\end{codeblock}
\indextext{2D graphics!synopsis|)}%
