%!TEX root = io2d.tex
\rSec0[\iotwod.syn]{Header \tcode{<experimental/io2d>} synopsis}

\indexlibrary{\idxhdr{experimental/io2d}|(}%
\indextext{2D graphics!synopsis|(}
\begin{codeblock}

namespace std { namespace experimental {
  namespace io2d { inline namespace v1 {

  struct nullvalue_t;
  constexpr nullvalue_t nullvalue{ @\impdef@ };

  using dashes = tuple<vector<double>, double>;

  enum class io2d_error;
  enum class content;
  enum class fill_rule;
  enum class line_cap;
  enum class line_join;
  enum class compositing_op;
  enum class format;
  enum class wrap_mode;
  enum class filter;
  enum class brush_type;
  enum class scaling;
  enum class refresh_rate;

  class io2d_error_category;
  const error_category& io2d_category() noexcept;

  class rectangle;
  class circle;

  class bgra_color;

  inline namespace literals {
    double operator""ubyte(unsigned long long value);
    double operator""unorm(long double value);
  }

  class vector_2d;
  bool operator==(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  bool operator!=(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator+(const vector_2d& lhs) noexcept;
  vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator-(const vector_2d& lhs) noexcept;
  vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator*(const vector_2d& lhs, double rhs) noexcept;
  vector_2d operator*(double lhs, const vector_2d& rhs) noexcept;

  class matrix_2d;

  matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
  bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
  bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;

  namespace path_data {
    class abs_new_path;
    bool operator==(const abs_new_path&, const abs_new_path&) noexcept;
    bool operator!=(const abs_new_path&, const abs_new_path&) noexcept;
    class rel_new_path;
    bool operator==(const rel_new_path&, const rel_new_path&) noexcept;
    bool operator!=(const rel_new_path&, const rel_new_path&) noexcept;
    class close_path;
    bool operator==(const close_path&, const close_path&) noexcept;
    bool operator!=(const close_path&, const close_path&) noexcept;
    class change_matrix;
    bool operator==(const change_matrix&, const change_matrix&) noexcept;
    bool operator!=(const change_matrix&, const change_matrix&) noexcept;
    class change_origin;
    bool operator==(const change_origin&, const change_origin&) noexcept;
    bool operator!=(const change_origin&, const change_origin&) noexcept;
    class abs_cubic_curve;
    bool operator==(const abs_cubic_curve&, const abs_cubic_curve&) noexcept;
    bool operator!=(const abs_cubic_curve&, const abs_cubic_curve&) noexcept;
    class abs_line;
    bool operator==(const abs_line&, const abs_line&) noexcept;
    bool operator!=(const abs_line&, const abs_line&) noexcept;
    class abs_move;
    bool operator==(const abs_move&, const abs_move&) noexcept;
    bool operator!=(const abs_move&, const abs_move&) noexcept;
    class abs_quadratic_curve;
    bool operator==(const abs_quadratic_curve&, const abs_quadratic_curve&) 
      noexcept;
    bool operator!=(const abs_quadratic_curve&, const abs_quadratic_curve&) 
      noexcept;
    class arc;
    bool operator==(const arc&, const arc&) noexcept;
    bool operator!=(const arc&, const arc&) noexcept;
    class rel_cubic_curve;
    bool operator==(const rel_cubic_curve&, const rel_cubic_curve&) noexcept;
    bool operator!=(const rel_cubic_curve&, const rel_cubic_curve&) noexcept;
    class rel_line;
    bool operator==(const rel_line&, const rel_line&) noexcept;
    bool operator!=(const rel_line&, const rel_line&) noexcept;
    class rel_move;
    bool operator==(const rel_move&, const rel_move&) noexcept;
    bool operator!=(const rel_move&, const rel_move&) noexcept;
    class rel_quadratic_curve;
    bool operator==(const rel_quadratic_curve&, const rel_quadratic_curve&) 
      noexcept;
    bool operator!=(const rel_quadratic_curve&, const rel_quadratic_curve&) 
      noexcept;
    using path_item = variant<abs_cubic_curve, abs_line, abs_new_path,
      abs_quadratic_curve, arc, change_matrix, change_origin, close_path,
      rel_cubic_curve, rel_line, rel_new_path, rel_quadratic_curve>;
  };
  
  class path_group;

  template <class Allocator = allocator<path_data::path_data_types>>
  class path_builder;

  template <class Allocator>
  bool operator==(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs) noexcept;
  template <class Allocator>
  bool operator!=(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs) noexcept;
  
  template <class Allocator>
  void swap(path_builder<Allocator>& lhs, path_builder<Allocator>& rhs)
    noexcept(noexcept(lhs.swap(rhs)));
  
  class device;

  class brush;
  
  class surface;
  class image_surface;
  class display_surface;
  class mapped_surface;
  
  template <class T>
  constexpr T pi = T(3.14159265358979323846264338327950288L);
  
  template <class T>
  constexpr T two_pi = T(6.28318530717958647692528676655900576L);
  
  template <class T>
  constexpr T half_pi = T(1.57079632679489661923132169163975144L);
  
  template <class T>
  constexpr T three_pi_over_two = T(4.71238898038468985769396507491925432L);
  
  int format_stride_for_width(format format, int width) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat,
    scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, ::std::error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  image_surface make_image_surface(format format, int width, int height);
  image_surface make_image_surface(format format, int width, int height, 
    error_code& ec) noexcept;
} } } }

namespace std {
  template<>
  struct is_error_condition_enum<experimental::io2d::io2d_error>
    : public std::true_type{ };

  template<>
  struct is_error_code_enum<@\impdef@>
    : public true_type{ }; // \expos

  std::error_condition make_error_condition(experimental::io2d::io2d_error e) 
    noexcept;

  std::error_code make_error_code(experimental::io2d::io2d_error e) noexcept;
}

\end{codeblock}
\indextext{2D graphics!synopsis|)}%
\indexlibrary{\idxhdr{experimental/io2d}|)}
