%!TEX root = io2d.tex
\rSec0[syn]{Header \tcode{<experimental/io2d>} synopsis}

\indexlibrary{\idxhdr{experimental/io2d}|(}%
\indextext{2D graphics!synopsis|(}
\begin{codeblock}

namespace std { namespace experimental {
  namespace io2d { inline namespace v1 {

  struct nullvalue_t;
  constexpr nullvalue_t nullvalue{ @\impdef@ };

  using dashes = tuple<vector<double>, double>;

  enum class io2d_error;
  enum class antialias;
  enum class content;
  enum class fill_rule;
  enum class line_cap;
  enum class line_join;
  enum class compositing_operator;
  enum class format;
  enum class tiling;
  enum class filter;
  enum class brush_type;
  enum class subpixel_order;
  enum class scaling;
  enum class refresh_rate;

  class io2d_error_category;
  const error_category& io2d_category() noexcept;

  class rectangle;
  class circle;

  class rgba_color;

  inline namespace literals {
    double operator""ubyte(unsigned long long value);
    double operator""unorm(long double value);
  }
  
  class vector_2d;
  bool operator==(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  bool operator!=(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator+(const vector_2d& lhs) noexcept;
  vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator-(const vector_2d& lhs) noexcept;
  vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator*(const vector_2d& lhs, double rhs) noexcept;
  vector_2d operator*(double lhs, const vector_2d& rhs) noexcept;

  class matrix_2d;

  matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs);
  matrix_2d& operator*=(matrix_2d& lhs, const matrix_2d& rhs);
  bool operator==(const matrix_2d& lhs, const matrix_2d& rhs);
  bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs);

  namespace path_data {
    class arc_clockwise;
    class arc_counterclockwise;
    class change_matrix;
    class change_origin;
    class close_path;
    class abs_cubic_curve;
    class abs_quadratic_curve;
    class abs_line;
    class abs_move;
    class new_path;
    class rel_cubic_curve;
    class rel_quadratic_curve;
    class rel_line;
    class rel_move;
    using path_data_types = typename variant<abs_move, rel_move,
      abs_line, rel_line, abs_cubic_curve, rel_cubic_curve, 
      abs_quadratic_curve, rel_quadratic_curve, arc_clockwise, 
      arc_counterclockwise, new_path, close_path, change_matrix, change_origin>;
  };
  class path;
  template <Allocator = allocator<path_data::path_data_types>>
  class path_factory;
  
  class color_stop;
  template <Allocator = allocator<color_stop>>
  class color_stop_group;
  
  class device;

  class brush;
  
  class surface;
  class image_surface;
  class display_surface;
  class mapped_surface;
  
  template <class T>
  constexpr T pi = T(3.14159265358979323846264338327950288L);
  
  template <class T>
  constexpr T two_pi = T(6.28318530717958647692528676655900576L);
  
  template <class T>
  constexpr T half_pi = T(1.57079632679489661923132169163975144L);
  
  template <class T>
  constexpr T three_pi_over_two = T(4.71238898038468985769396507491925432L);
  
  int format_stride_for_width(format format, int width) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat,
    scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, ::std::error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  image_surface make_image_surface(format format, int width, int height);
  image_surface make_image_surface(format format, int width, int height, 
    error_code& ec) noexcept;
} } } }

namespace std {
  template<>
  struct is_error_condition_enum<experimental::io2d::io2d_error>
    : public std::true_type{ };

  template<>
  struct is_error_code_enum<@\impdef@>
    : public true_type{ }; // \expos

  std::error_condition make_error_condition(experimental::io2d::io2d_error e) 
    noexcept;

  std::error_code make_error_code(experimental::io2d::io2d_error e) noexcept;
}

\end{codeblock}
\indextext{2D graphics!synopsis|)}%
\indexlibrary{\idxhdr{experimental/io2d}|)}
