%!TEX root = io2d.tex
\rSec0[syn]{Header \tcode{<experimental/io2d>} synopsis}

\indexlibrary{\idxhdr{experimental/io2d}|(}%
\indextext{2D graphics!synopsis|(}
\begin{codeblock}

namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  typedef tuple<vector<double>, double> dashes;

  enum class io2d_error;
  enum class antialias;
  enum class content;
  enum class fill_rule;
  enum class line_cap;
  enum class line_join;
  enum class compositing_operator;
  enum class format;
  enum class extend;
  enum class filter;
  enum class brush_type;
  enum class font_slant;
  enum class font_weight;
  enum class subpixel_order;
  enum class path_data_type;
  enum class scaling;

  class io2d_error_category;
  const error_category& io2d_category() noexcept;

  class rectangle;

  class rgba_color;

  inline namespace literals {
    double operator""ubyte(unsigned long long value);
    double operator""unorm(long double value);
  }
  
  class point;
  bool operator==(const point& lhs, const point& rhs);
  bool operator!=(const point& lhs, const point& rhs);

  class glyph;
  class text_cluster;
  class font_extents;
  class text_extents;

  class matrix_2d;

  matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs);
  matrix_2d& operator*=(matrix_2d& lhs, const matrix_2d& rhs);
  bool operator==(const matrix_2d& lhs, const matrix_2d& rhs);
  bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs);

  class path_data;
  class move_to;
  class line_to;
  class rel_move_to;
  class rel_line_to;
  class curve_to;
  class rel_curve_to;
  class arc;
  class arc_negative;
  class new_sub_path;
  class close_path;
  class change_matrix;
  
  class path;
  class path_factory;
  
  class device;

  class font_options_factory;
  class font_options;

  class font_face;
  class simple_font_face;

  class scaled_font;

  class brush;
  class solid_color_brush_factory;
  class linear_brush_factory;
  class radial_brush_factory;
  class mesh_brush_factory;
  class surface_brush_factory;
  
  class surface;
  class image_surface;
  class display_surface;
  
  int format_stride_for_width(format fmt, int width);
  display_surface make_display_surface(int pw, int ph, format pf,
    scaling scl = scaling::letterbox);
  image_surface make_image_surface(format fmt, int width, int height);
} } } }

namespace std {
	template<>
	struct is_error_condition_enum<experimental::io2d::io2d_error>
		: public std::true_type{ };

	template<>
	struct is_error_code_enum<@\impdef@>
		: public true_type{ };

	std::error_condition make_error_condition(
	  experimental::io2d::io2d_error e) noexcept;

	std::error_code make_error_code(@\impdef@ e) noexcept;
} // namespace std

\end{codeblock}
\indextext{2D graphics!synopsis|)}%
\indexlibrary{\idxhdr{experimental/io2d}|)}
