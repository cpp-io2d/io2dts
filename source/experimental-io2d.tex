%!TEX root = io2d.tex
\rSec0[syn]{Header \tcode{<experimental/io2d>} synopsis}

\indexlibrary{\idxhdr{experimental/io2d}|(}%
\indextext{2D graphics!synopsis|(}
\begin{codeblock}

namespace std { namespace experimental {
  namespace io2d { inline namespace v1 {

  struct nullvalue_t;
  constexpr nullvalue_t nullvalue{ @\impdef@ };

  using dashes = tuple<vector<double>, double>;

  enum class io2d_error;
  enum class antialias;
  enum class content;
  enum class fill_rule;
  enum class line_cap;
  enum class line_join;
  enum class compositing_op;
  enum class format;
  enum class tiling;
  enum class filter;
  enum class brush_type;
  enum class subpixel_order;
  enum class scaling;
  enum class refresh_rate;

  class io2d_error_category;
  const error_category& io2d_category() noexcept;

  class rectangle;
  class circle;

  class rgba_color;

  inline namespace literals {
    double operator""ubyte(unsigned long long value);
    double operator""unorm(long double value);
  }
  
  class vector_2d;
  bool operator==(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  bool operator!=(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator+(const vector_2d& lhs) noexcept;
  vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator-(const vector_2d& lhs) noexcept;
  vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs) noexcept;
  vector_2d operator*(const vector_2d& lhs, double rhs) noexcept;
  vector_2d operator*(double lhs, const vector_2d& rhs) noexcept;

  class matrix_2d;

  matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs);
  matrix_2d& operator*=(matrix_2d& lhs, const matrix_2d& rhs);
  bool operator==(const matrix_2d& lhs, const matrix_2d& rhs);
  bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs);

  namespace path_data {
    class arc_clockwise;
    class arc_counterclockwise;
    class change_matrix;
    class change_origin;
    class close_path;
    class abs_cubic_curve;
    class abs_quadratic_curve;
    class abs_line;
    class abs_move;
    class new_path;
    class rel_cubic_curve;
    class rel_quadratic_curve;
    class rel_line;
    class rel_move;
    using path_data_types = typename variant<abs_move, rel_move,
      abs_line, rel_line, abs_cubic_curve, rel_cubic_curve, 
      abs_quadratic_curve, rel_quadratic_curve, arc_clockwise, 
      arc_counterclockwise, new_path, close_path, change_matrix, change_origin>;
  };
  
  class path;

  template <class Allocator = allocator<path_data::path_data_types>>
  class path_builder {
  public:
    using value_type = path_data::path_data_types;
    using allocator_type = Allocator;
    using reference = value_type&;
    using const_reference = const value_type&;
    using size_type       = @\impdefx{type of \tcode{path_builder::size_type}}@. // See [container.requirements] in \cppseventeen.
    using difference_type = @\impdefx{type of \tcode{path_builder::size_type}}@. // See [container.requirements] in \cppseventeen.
    using iterator       = @\impdefx{type of \tcode{path_builder::iterator}}@. // See [container.requirements] in \cppseventeen.
    using const_iterator = @\impdefx{type of \tcode{path_builder::const_iterator}}@. // See [container.requirements] in \cppseventeen.
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    
    // \ref{pathbuilder.cons}, construct, copy, move, destroy:
    path_builder() noexcept(noexcept(Allocator())) :
      path_builder(Allocator()) { }
    explicit path_builder(const Allocator&) noexcept;
    explicit path_builder(size_type n, const Allocator& = Allocator());
    path_builder(size_type n, const value_type& value,
      const Allocator& = Allocator());
    template <class InputIterator>
    path_builder(InputIterator first, InputIterator last,
      const Allocator& = Allocator());
    path_builder(const path_builder& x);
    path_builder(path_builder&&) noexcept;
    path_builder(const path_builder&, const Allocator&);
    path_builder(path_builder&&, const Allocator&);
    path_builder(initializer_list<value_type>, const Allocator& = Allocator());
    ~path_builder();
    path_builder& operator=(const path_builder& x);
    path_builder& operator=(path_builder&& x)
      noexcept(
      allocator_traits<Allocator>::propagate_on_container_move_assignment::value
      ||
      allocator_traits<Allocator>::is_always_equal::value);
    path_builder& operator=(initializer_list<value_type>);
    template <class InputIterator>
    void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;
    
    // \ref{pathbuilder.iterators}, iterators:
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    const_iterator cbegin() const noexcept;

    iterator end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cend() const noexcept;
    
    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crend() const noexcept;
    
    // \ref{pathbuilder.capacity}, capacity
    bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);
    void reserve(size_type n);
    void shrink_to_fit();

    // element access:
    reference operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference at(size_type n);
    reference front();
    const_reference front() const;
    reference back();
    const_reference back() const;

    // \ref{pathbuilder.modifiers}, modifiers:
    void new_path() noexcept;
    void close_path() noexcept;
    void arc_clockwise(const vector_2d& center, double radius, double angle1,
    double angle2) noexcept;
    void arc_counterclockwise(const vector_2d& center, double radius,
    double angle1, double angle2) noexcept;
    void cubic_curve_to(const vector_2d& pt0, const vector_2d& pt1,
    const vector_2d& pt2) noexcept;
    void line_to(const vector_2d& pt) noexcept;
    void move_to(const vector_2d& pt) noexcept;
    void quadratic_curve_to(const vector_2d& pt0, const vector_2d& pt2)
    noexcept;
    void rectangle(const experimental::io2d::rectangle& r) noexcept;
    void rel_cubic_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
    const vector_2d& dpt2) noexcept;
    void rel_line_to(const vector_2d& dpt) noexcept;
    void rel_move_to(const vector_2d& dpt) noexcept;
    void rel_quadratic_curve_to(const vector_2d& pt0, const vector_2d& pt2)
    noexcept;
    void transform_matrix(const matrix_2d& m) noexcept;
    void origin(const vector_2d& pt) noexcept;
    
    template <class... Args>
    reference emplace_back(Args&&... args);
    void push_back(const value_type& x);
    void push_back(value_type&& x);
    void pop_back();
    template <class... Args>
    iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
    iterator insert(const_iterator position, InputIterator first,
      InputIterator last);
    iterator insert(const_iterator position,
      initializer_list<value_type> il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(path_builder&)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value 
        || allocator_traits<Allocator>::is_always_equal::value);
    void clear() noexcept;

    // \ref{pathbuilder.observers}, observers:
    experimental::io2d::rectangle path_extents() const noexcept;
    bool has_current_point() const noexcept;
    vector_2d current_point() const;
    vector_2d current_point(error_code& ec) const noexcept;
    matrix_2d transform_matrix() const noexcept;
    vector_2d origin() const noexcept;
  }

  template <class Allocator>
  bool operator==(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs);
  template <class Allocator>
  bool operator!=(const path_builder<Allocator>& lhs, 
    const path_builder<Allocator>& rhs);
  
  // \ref{pathbuilder.special}, specialized algorithms:
  template <class Allocator>
  void swap(path_builder<Allocator>& lhs, path_builder<Allocator>& rhs)
    noexcept(noexcept(lhs.swap(rhs)));
  
  class color_stop;

  template <class Allocator = allocator<color_stop>>
  class color_stop_group {
  public:
    using value_type      = color_stop;
    using allocator_type  = Allocator;
    using pointer = typename allocator_traits<Allocator>::pointer;
    using const_pointer = typename allocator_traits<Allocator>::const_pointer;
    using reference = value_type&;
    using const_reference = const value_type&;
    using size_type       = @\impdefx{type of \tcode{color_stop_group::size_type}}@. // See [container.requirements] in \cppseventeen.
    using difference_type = @\impdefx{type of \tcode{color_stop_group::size_type}}@. // See [container.requirements] in \cppseventeen.
    using iterator        = @\impdefx{type of \tcode{color_stop_group::iterator}}@. // See [container.requirements] in \cppseventeen.
    using const_iterator  = @\impdefx{type of \tcode{color_stop_group::const_iterator}}@. // See [container.requirements] in \cppseventeen.
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;

    // \ref{colorstops.colorstopgroup.cons}, constructors:    
    color_stop_group() noexcept(noexcept(Allocator())) :
    color_stop_group(Allocator()) { }
    explicit color_stop_group(const Allocator&) noexcept;
    explicit color_stop_group(size_type n, const Allocator& = Allocator());
    color_stop_group(size_type n, const value_type& value,
      const Allocator& = Allocator());
    template <class InputIterator>
    color_stop_group(InputIterator first, InputIterator last,
    const Allocator& = Allocator());
    color_stop_group(const color_stop_group& x);
    color_stop_group(color_stop_group&&) noexcept;
    color_stop_group(const color_stop_group&, const Allocator&);
    color_stop_group(color_stop_group&&, const Allocator&);
    color_stop_group(initializer_list<value_type>,
      const Allocator& = Allocator());
    ~color_stop_group();
    color_stop_group& operator=(const color_stop_group& x);
    color_stop_group& operator=(color_stop_group&& x)
      noexcept(
      allocator_traits<Allocator>::propagate_on_container_move_assignment::value
      || allocator_traits<Allocator>::is_always_equal::value);
    color_stop_group& operator=(initializer_list<value_type>);
    template <class InputIterator>
    void assign(InputIterator first, InputIterator last);
    void assign(size_type n, const value_type& u);
    void assign(initializer_list<value_type>);
    allocator_type get_allocator() const noexcept;
    
    // \ref{colorstops.colorstopgroup.iterators}, iterators:
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    const_iterator cbegin() const noexcept;
    
    iterator end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cend() const noexcept;
    
    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator crbegin() const noexcept;
    
    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crend() const noexcept;
    
    // \ref{colorstops.colorstopgroup.capacity}, capacity
    bool empty() const noexcept;
    size_type size() const noexcept;
    size_type max_size() const noexcept;
    size_type capacity() const noexcept;
    void resize(size_type sz);
    void resize(size_type sz, const value_type& c);
    void reserve(size_type n);
    void shrink_to_fit();
    
    // element access:
    reference operator[](size_type n);
    const_reference operator[](size_type n) const;
    const_reference at(size_type n) const;
    reference at(size_type n);
    reference front();
    const_reference front() const;
    reference back();
    const_reference back() const;
    
    // \ref{colorstops.colorstopgroup.modifiers}, modifiers:
    template <class... Args>
    reference emplace_back(Args&&... args);
    void push_back(const value_type& x);
    void push_back(value_type&& x);
    void pop_back();
    template <class... Args>
    iterator emplace(const_iterator position, Args&&... args);
    iterator insert(const_iterator position, const value_type& x);
    iterator insert(const_iterator position, value_type&& x);
    iterator insert(const_iterator position, size_type n, const value_type& x);
    template <class InputIterator>
    iterator insert(const_iterator position, InputIterator first,
      InputIterator last);
    iterator insert(const_iterator position,
    initializer_list<value_type> il);
    iterator erase(const_iterator position);
    iterator erase(const_iterator first, const_iterator last);
    void swap(color_stop_group&)
      noexcept(allocator_traits<Allocator>::propagate_on_container_swap::value 
      || allocator_traits<Allocator>::is_always_equal::value);
    void clear() noexcept;
  };

  template <class Allocator>
  bool operator==(const color_stop_group<Allocator>& lhs, 
    const color_stop_group<Allocator>& rhs);
  template <class Allocator>
  bool operator!=(const color_stop_group<Allocator>& lhs, 
    const color_stop_group<Allocator>& rhs);

  // \ref{colorstops.colorstopgroup.special}, specialized algorithms:
  template <class Allocator>
  void swap(color_stop_group<Allocator>& lhs, color_stop_group<Allocator>& rhs)
    noexcept(noexcept(lhs.swap(rhs)));
  
  class device;

  class brush;
  
  class surface;
  class image_surface;
  class display_surface;
  class mapped_surface;
  
  template <class T>
  constexpr T pi = T(3.14159265358979323846264338327950288L);
  
  template <class T>
  constexpr T two_pi = T(6.28318530717958647692528676655900576L);
  
  template <class T>
  constexpr T half_pi = T(1.57079632679489661923132169163975144L);
  
  template <class T>
  constexpr T three_pi_over_two = T(4.71238898038468985769396507491925432L);
  
  int format_stride_for_width(format format, int width) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat,
    scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, scaling scl = scaling::letterbox);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, ::std::error_code& ec,
    scaling scl = scaling::letterbox) noexcept;
  image_surface make_image_surface(format format, int width, int height);
  image_surface make_image_surface(format format, int width, int height, 
    error_code& ec) noexcept;
} } } }

namespace std {
  template<>
  struct is_error_condition_enum<experimental::io2d::io2d_error>
    : public std::true_type{ };

  template<>
  struct is_error_code_enum<@\impdef@>
    : public true_type{ }; // \expos

  std::error_condition make_error_condition(experimental::io2d::io2d_error e) 
    noexcept;

  std::error_code make_error_code(experimental::io2d::io2d_error e) noexcept;
}

\end{codeblock}
\indextext{2D graphics!synopsis|)}%
\indexlibrary{\idxhdr{experimental/io2d}|)}
