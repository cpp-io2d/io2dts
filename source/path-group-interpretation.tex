%!TEX root = io2d.tex

\rSec0 [paths.interpretation]{Path group interpretation}

\pnum
This subclause describes how to interpret a path group for use in a rendering and composing operation.

\pnum
Interpreting a path group consists of evaluating a sequence of \tcode{path_data::path_item} objects and transforming them into zero or more paths as-if in the manner specified in this subclause.

\pnum
Until a \tcode{path_data::path_item} object containing a \tcode{path_data::abs_new_path} object is evaluated, a path shall only contain \tcode{path_data::path_item} objects containing \tcode{path_data::abs_matrix} or \tcode{path_data::abs_origin} objects; no diagnostic is required.

\pnum
The interpretation of a path group requires the state data specified in Table~\ref{tab:paths.interpretation.state}.

\begin{floattable}
{Path group interpretation state data}{tab:paths.interpretation.state}{llll}
\hline
\hdstyle{Name} &
\hdstyle{Description} &
\hdstyle{Type} &
\hdstyle{Initial value} \\ \hline
\tcode{mtx} &
Path group transformation matrix &
\tcode{matrix_2d} &
\tcode{matrix_2d\{ \}} \\
\tcode{currPt} &
Current point &
\tcode{vector_2d} &
\unspec \\
\tcode{lnPt} &
Last new point &
\tcode{vector_2d} &
\unspec \\
\tcode{mtxStk} &
Matrix stack &
\tcode{stack<matrix_2d>} &
\tcode{stack<matrix_2d>\{ \}} \\\hline
\end{floattable}

\FloatBarrier

\pnum
The effects of a path item contained in a \tcode{path_data::path_item} object when that object is being evaluated during path group interpretation are described in \ref{tab:paths.interpretation.effects}.

\begin{libreqtab2a} {Path item interpretation effects} {tab:paths.interpretation.effects}
\\ \topline
\lhdr{Path item} & \rhdr{Effects} \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Path item} & \rhdr{Effects} \\ \capsep
\endhead

\tcode{path_data::abs_new_path p} &
Creates a new path. Sets \tcode{currPt} to \tcode{mtx.transform_point(\{ 0.0, 0.0 \}) + p.at()}. Sets \tcode{lnPt} to \tcode{currPt}. \\ \rowsep

\tcode{path_data::rel_new_path p} &
Let \tcode{mm} equal \tcode{mtx}. Evaluate \tcode{mm.m20(0.0)} and \tcode{mm.m21(0.0)}. Creates a new path. Sets \tcode{currPt} to \tcode{currPt + p.at() * mm}. Sets \tcode{lnPt} to \tcode{currPt}. \\ \rowsep

\tcode{path_data::close_path p} &
Creates a line from \tcode{currPt} to \tcode{lnPt}. Makes the current path a closed path. Creates a new path. Sets \tcode{currPt} to \tcode{lnPt}. \\ \rowsep

\tcode{path_data::abs_matrix p} &
Calls \tcode{mtxStk.push(mtx)}. Sets \tcode{mtx} to \tcode{p.matrix()}. \\ \rowsep

\tcode{path_data::rel_matrix p} &
Calls \tcode{mtxStk.push(mtx)}. Sets \tcode{mtx} to \tcode{mtx * p.matrix()}. \\ \rowsep

\tcode{path_data::revert_matrix p} &
If \tcode{mtxStk.empty()} is \tcode{false}, sets \tcode{mtx} to \tcode{ognStk.top()} then calls \tcode{ognStk.pop()}. Otherwise sets \tcode{mtx} to its initial value as specified in Table~\ref{tab:paths.interpretation.state}. \\ \rowsep

\tcode{path_data::abs_line p} &
Let \tcode{pt} equal \tcode{mtx.transform_point(p.to() - currPt) + currPt}. Creates a line from \tcode{currPt} to \tcode{pt}. Sets \tcode{currPt} to \tcode{pt}. \\ \rowsep

\tcode{path_data::rel_line p} &
Let \tcode{mm} equal \tcode{mtx}. Evaluate \tcode{mm.m20(0.0)} and \tcode{mm.m21(0.0)}. Let \tcode{pt} equal \tcode{currPt + p.to() * mm}. Creates a line from \tcode{currPt} to \tcode{pt}. Sets \tcode{currPt} to \tcode{pt}. \\ \rowsep

\tcode{path_data::abs_quadratic_curve p} &
Let \tcode{cpt} equal \tcode{mtx.transform_point(p.control_pt() - currPt) + currPt}. Let \tcode{ept} equal \tcode{mtx.transform_point(p.end_pt() - currPt) + currPt}. Creates a quadratic \bezierlocal curve from \tcode{currPt} to \tcode{ept} using \tcode{cpt} as the curve's control point. Sets \tcode{currPt} to \tcode{ept}. \\ \rowsep

\tcode{path_data::rel_quadratic_curve p} &
Let \tcode{mm} equal \tcode{mtx}. Evaluate \tcode{mm.m20(0.0)} and \tcode{mm.m21(0.0)}. Let \tcode{cpt} equal \tcode{currPt + p.control_pt() * mm}. Let \tcode{ept} equal \tcode{currPt + p.control_pt() * mm + p.end_pt() * mm}. Creates a quadratic \bezierlocal curve from \tcode{currPt} to \tcode{ept} using \tcode{cpt} as the curve's control point. Sets \tcode{currPt} to \tcode{ept}. \\ \rowsep

\tcode{path_data::abs_cubic_curve p} &
Let \tcode{cpt1} equal \tcode{mtx.transform_point(p.control_pt1() - currPt) + currPt}. Let \tcode{cpt2} equal \tcode{mtx.transform_point(p.control_pt2() - currPt) + currPt}. Let \tcode{ept} equal \tcode{mtx.transform_point(p.end_pt() - currPt) + currPt}. Creates a cubic \bezierlocal curve from \tcode{currPt} to \tcode{ept} using \tcode{cpt1} as the curve's first control point and \tcode{cpt2} as the curve's second control point. Sets \tcode{currPt} to \tcode{ept}. \\ \rowsep

\tcode{path_data::rel_cubic_curve p} &
Let \tcode{mm} equal \tcode{mtx}. Evaluate \tcode{mm.m20(0.0)} and \tcode{mm.m21(0.0)}. Let \tcode{cpt1} equal \tcode{currPt + p.control_pt1() * mm}. Let \tcode{cpt2} equal \tcode{currPt + p.control_pt1() * mm + p.control_pt2() * mm}. Let \tcode{ept} equal \tcode{currPt + p.control_pt1() * mm + p.control_pt2() * mm + p.end_pt() * mm}. Creates a cubic \bezierlocal curve from \tcode{currPt} to \tcode{ept} using \tcode{cpt1} as the curve's first control point and \tcode{cpt2} as the curve's second control point. Sets \tcode{currPt} to \tcode{ept}. \\ \rowsep

\tcode{path_data::arc p} &
Let \tcode{mm} equal \tcode{mtx}. Evaluate \tcode{mm.m20(0.0)} and \tcode{mm.m21(0.0)}. Creates an arc. It begins at \tcode{currPt}, which is at \tcode{p.start_angle()} radians on the arc and rotates \tcode{p.rotation()} radians. If \tcode{p.rotation()} is positive, rotation is counterclockwise, otherwise it is clockwise. The center of the arc is located at \tcode{p.center(currPt, mm)}. The arc ends at \tcode{p.end_pt(currPt, mm)}. Sets \tcode{currPt} to \tcode{p.end_pt(currPt, mm)}.

\begin{note} \tcode{p.radius()}, which specifies the radius of the arc, is implicitly included in the above statement of effects by the specifications of the center of the arc and the end of the arcs. The use of the current point as the origin for the application of the path group transformation matrix is also implicitly included by the same specifications. \end{note} \\
\end{libreqtab2a}

\pnum
Excluding \tcode{path_data::abs_matrix} objects, if any, the first path item in a path group shall be an \tcode{path_data::abs_new_path} object when it is interpreted; no diagnostic is required.

\pnum
\begin{note}
The interpretation of all path items other than \tcode{path_data::abs_matrix} objects and \tcode{path_data::abs_new_path} objects requires that the current point (see: Table~\ref{tab:paths.interpretation.state}) has a value, and only a \tcode{path_data::abs_new_path} object establishes a value for the current point without needing an existing value for the current point.
\end{note}
