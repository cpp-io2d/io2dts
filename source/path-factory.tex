%!TEX root = io2d.tex
\rSec0 [pathfactory] {Class \tcode{path_factory}}

\pnum
\indexlibrary{\idxcode{path_factory}}
The class \tcode{path_factory} is a container that stores and manipulates path
geometry collection data from which \tcode{path} objects are created.

\pnum
A \tcode{path_factory} is a contiguous container. (See [container.requirements.general] in \cppseventeen.) This means that the consecutive path geometries within its path geometry collection data and the path segments contained in each of those path geometries are contiguous. As such the iterators for a \tcode{path_geometry} object present the path geometry collection data as a contiguous series of path segments.

\pnum
The type of a path segment in a \tcode{path_factory} object is  \tcode{path_factory::path_data}.

%\pnum
%Any manipulation of the path geometry collection data which results in path geometry collection data that cannot be processed in the manner specified in \ref{pathgeometries.processing} shall result in undefined behavior.
%
\rSec1 [pathfactory.synopsis] {\tcode{path_factory} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class path_factory {
  public:
    class path_abs_move {
    public:
      explicit path_abs_move(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_abs_line {
    public:
      explicit path_abs_line(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_rel_move {
    public:
      explicit path_rel_move(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_rel_line {
    public:
      explicit path_rel_line(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_abs_curve {
    public:
      path_abs_curve(const vector_2d& controlPoint1, const vector_2d& controlPoint2, const vector_2d& endPoint) noexcept;
      
      void control_point_1(const vector_2d& value) noexcept;
      void control_point_2(const vector_2d& value) noexcept;
      void end_point(const vector_2d& value) noexcept;
      
      vector_2d control_point_1() const noexcept;
      vector_2d control_point_2() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_rel_curve {
    public:
      path_rel_curve(const vector_2d& controlPoint1, const vector_2d& controlPoint2, const vector_2d& endPoint) noexcept;
      
      void control_point_1(const vector_2d& value) noexcept;
      void control_point_2(const vector_2d& value) noexcept;
      void end_point(const vector_2d& value) noexcept;
      
      vector_2d control_point_1() const noexcept;
      vector_2d control_point_2() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_arc_clockwise {
    public:
      path_arc_clockwise(const vector_2d& center, double radius, double angle1, double angle2) noexcept;
      
      void center(const vector_2d& value) noexcept;
      void radius(double value) noexcept;
      void angle_1(double radians) noexcept;
      void angle_2(double radians) noexcept;
      
      vector_2d center() const noexcept;
      double radius() const noexcept;
      double angle_1() const noexcept;
      double angle_2() const noexcept;
    };
    
    class path_arc_counterclockwise {
    public:
      path_arc_counterclockwise(const vector_2d& center, double radius, double angle1, double angle2) noexcept;
      
      void center(const vector_2d& value) noexcept;
      void radius(double value) noexcept;
      void angle_1(double radians) noexcept;
      void angle_2(double radians) noexcept;
      
      vector_2d center() const noexcept;
      double radius() const noexcept;
      double angle_1() const noexcept;
      double angle_2() const noexcept;
    };
    
    class path_new_sub_path {
    };
    
    class path_close_path {
    };
    
    class path_change_matrix {
    public:
      explicit path_change_matrix(const matrix_2d& m) noexcept;
      
      void matrix(const matrix_2d& value) noexcept;
      matrix_2d matrix() const noexcept;
    };
    
    class path_change_origin {
    public:
      explicit path_change_origin(const vector_2d& origin) noexcept;
      
      void origin(const vector_2d& value) noexcept;
      vector_2d origin() const noexcept;
    };
    
    using path_data      = typename variant<path_abs_move, path_abs_line, 
      path_rel_move, path_curve, path_rel_curve, path_arc_clockwise, 
      path_arc_counterclockwise, path_new_sub_path, path_close_path, 
      path_change_matrix, path_change_origin>;
    
    using iterator       = @\impdefx{type of \tcode{path_factory::iterator}}@. // See [container.requirements] in \cppseventeen.
    using const_iterator = @\impdefx{type of \tcode{path_factory::const_iterator}}@. // See [container.requirements] in \cppseventeen.
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    
    // \ref{pathfactory.cons}, construct/copy/destroy:
    constexpr path_factory() noexcept;
    path_factory(const path_factory&) = default;
    path_factory& operator=(const path_factory&) = default;
    path_factory(path_factory&&) noexcept = default;
    path_factory& operator=(path_factory&&) noexcept = default;
    
    // \ref{pathfactory.modifiers}, modifiers:
    void append(const path_factory& p);
    void append(const path_factory& p, error_code& ec) noexcept;
    void append(const vector<path_data_item>& p);
    void append(const vector<path_data_item>& p, error_code& ec) noexcept;
    void new_sub_path();
    void new_sub_path(error_code& ec) noexcept;
    void close_path();
    void close_path(error_code& ec) noexcept;
    void arc(const vector_2d& center, double radius, double angle1,
      double angle2);
    void arc(const vector_2d& center, double radius, double angle1,
      double angle2, error_code& ec) noexcept;
    void arc_negative(const vector_2d& center, double radius, double angle1,
      double angle2);
    void arc_negative(const vector_2d& center, double radius, double angle1,
      double angle2, error_code& ec) noexcept;
    void curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2);
    void curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2, error_code& ec) noexcept;
    void line_to(const vector_2d& pt);
    void line_to(const vector_2d& pt, error_code& ec) noexcept;
    void move_to(const vector_2d& pt);
    void move_to(const vector_2d& pt, error_code& ec) noexcept;
    void rectangle(const experimental::io2d::rectangle& r);
    void rectangle(const experimental::io2d::rectangle& r,
      error_code& ec) noexcept;
    void rel_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2);
    void rel_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2, error_code& ec) noexcept;
    void rel_line_to(const vector_2d& dpt);
    void rel_line_to(const vector_2d& dpt, error_code& ec) noexcept;
    void rel_move_to(const vector_2d& dpt);
    void rel_move_to(const vector_2d& dpt, error_code& ec) noexcept;
    void transform_matrix(const matrix_2d& m);
    void transform_matrix(const matrix_2d& m, error_code& ec) noexcept;
    void origin(const vector_2d& pt);
    void origin(const vector_2d& pt, error_code& ec) noexcept;
    void clear() noexcept;
    
    // \ref{pathfactory.observers}, observers:
    experimental::io2d::rectangle path_extents() const;
    experimental::io2d::rectangle path_extents(error_code& ec) const noexcept;
    bool has_current_point() const noexcept;
    vector_2d current_point() const;
    vector_2d current_point(error_code& ec) const noexcept;
    matrix_2d transform_matrix() const noexcept;
    vector_2d origin() const noexcept;
    vector<path_data_item> data() const;
    vector<path_data_item> data(error_code& ec) const noexcept;
    path_data_item data_item(unsigned int index) const;
    path_data_item data_item(unsigned int index, error_code& ec) const noexcept;
    const vector<path_data_item>& data_ref() const noexcept;

  private:
    vector<path_data_item> _Data;  // \expos
    bool _Has_current_point;       // \expos
    vector_2d _Current_point;      // \expos
    vector_2d _Last_move_to_point; // \expos
    matrix_2d _Transform_matrix;   // \expos
    vector_2d _Origin;             // \expos
  };
} } } }
\end{codeblock}

\rSec1 [pathfactory.cons] {\tcode{path_factory} constructors and 
assignment operators}

\indexlibrary{\idxcode{path_factory}!constructor}
\begin{itemdecl}
    path_factory();
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{path_factory}.
	
	\pnum
	\postconditions
	\tcode{_Data.empty() == true}.
	
	\pnum
	\tcode{_Has_current_point == false}.
	
	\pnum
	\tcode{_Transform_matrix == matrix_2d::init_identity()}.
	
	\pnum
	\tcode{_Origin == vector_2d{ }}.
\end{itemdescr}

\rSec1 [pathfactory.modifiers] {\tcode{path_factory} modifiers}

\indexlibrary{\idxcode{path_factory}!\idxcode{append}}
\indexlibrary{\idxcode{append}!\idxcode{path_factory}}
\begin{itemdecl}
    void append(const path_factory& p);
    void append(const path_factory& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Appends the result of calling \tcode{p.data_ref()} to \tcode{_Data} as if each \tcode{path_data_item} object was added to \tcode{*this} by calling the member function that adds a \tcode{path_data_item} of the same type to \tcode{*this}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
In the event of an error, the object shall not be modified.

\pnum
\errors
\tcode{errc::not_enough_memory} if the attempt to append the \tcode{p.data_ref()} failed. The object shall not be modified.

\pnum
\tcode{io2d_error::no_current_point} if the first item to be appended required a current point and \tcode{_Has_current_point == false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{append}}
\indexlibrary{\idxcode{append}!\idxcode{path_factory}}
\begin{itemdecl}
    void append(const vector<path_data_item>& p);
    void append(const vector<path_data_item>& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Appends the result of calling \tcode{p.data_ref()} to \tcode{_Data} as if each \tcode{path_data_item} object was added to \tcode{*this} by calling the member function that adds a \tcode{path_data_item} of the same type to \tcode{*this}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
In the event of an error, the object shall not be modified.

\pnum
\errors
\tcode{errc::not_enough_memory} if the attempt to append the \tcode{p.data_ref()} failed. The object shall not be modified.

\pnum
\tcode{io2d_error::no_current_point} if the first item to be appended required a current point and \tcode{_Has_current_point == false}.

\pnum
\tcode{io2d_error::invalid_path_data} if \tcode{p} contains one or more invalid path geometries.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{new_sub_path}}
\indexlibrary{\idxcode{new_sub_path}!\idxcode{path_factory}}
\begin{itemdecl}
    void new_sub_path();
    void new_sub_path(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::new_sub_path())}.
	
	\pnum
	\tcode{_Has_current_point = false}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{close_path}}
\indexlibrary{\idxcode{close_path}!\idxcode{path_factory}}
\begin{itemdecl}
    void close_path();
    void close_path(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If \tcode{_Has_current_point == true}:
	\begin{itemize}
	\item \tcode{_Data.emplace_back(path_data_item::close_path())}.
	
	\item \tcode{_Current_point = _Last_move_to_point}.
	\end{itemize}
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{arc}}
\indexlibrary{\idxcode{arc}!\idxcode{path_factory}}
\begin{itemdecl}
    void arc(const vector_2d& center, double radius, double angle1,
      double angle2);
    void arc(const vector_2d& center, double radius, double angle1,
      double angle2, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_factory::path_arc_clockwise(center, radius, angle1, angle2))}.
	
	\pnum
	\tcode{_Current_point == vector_2\{ radius * cos(angle2), -(radius * -sin(angle2)) \} + center}.
	
	\pnum
	If \tcode{_Has_current_point == false}:
	\begin{itemize}
	\item \tcode{_Last_move_to_point == vector_2\{ radius * cos(angle1), -(radius * -sin(angle1)) \} + center}.
	
	\item \tcode{_Has_current_point == true}.
	\end{itemize}
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{arc_negative}}
\indexlibrary{\idxcode{arc_negative}!\idxcode{path_factory}}
\begin{itemdecl}
    void arc_negative(const vector_2d& center, double radius, double angle1,
      double angle2);
    void arc_negative(const vector_2d& center, double radius, double angle1,
      double angle2, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_factory::path_arc_counterclockwise(center, radius, angle1, angle2))}.
	
	\pnum
	\tcode{_Current_point = vector_2\{ radius * cos(angle1), radius * -sin(angle1) \} + center}.
	
	\pnum
	If \tcode{_Has_current_point == false}:
	\begin{itemize}
	\item \tcode{_Last_move_to_point = vector_2\{ radius * cos(angle2), radius * -sin(angle2) \} + center}.
	
	\item \tcode{_Has_current_point = true}.
	\end{itemize}
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{curve_to}}
\indexlibrary{\idxcode{curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2);
    void curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If \tcode{_Has_current_point == false}:
	\begin{itemize}
	\item \tcode{_Data.reserve(_Data.size() + 2U)}.
	
	\item \tcode{*this.move_to(pt0)}.
	\end{itemize}
	
	\pnum
	\tcode{_Data.emplace_back(path_data_item::curve_to(pt0, pt1, pt2))}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{line_to}}
\indexlibrary{\idxcode{line_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void line_to(const vector_2d& pt);
    void line_to(const vector_2d& pt, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::line_to(pt))}.
	
	\pnum
	If \tcode{_Has_current_point == false}:
	\begin{itemize}
	\item \tcode{_Last_move_to_point = pt}.
	
	\item \tcode{_Has_current_point = true}.
	\end{itemize}
	
	\pnum
	\tcode{_Current_point = pt}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{move_to}}
\indexlibrary{\idxcode{move_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void move_to(const vector_2d& pt);
    void move_to(const vector_2d& pt, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::move_to(pt))}.
	
	\pnum
	\tcode{_Has_current_point = true}.
	
	\pnum
	\tcode{_Current_point = pt}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rectangle}}
\indexlibrary{\idxcode{rectangle}!\idxcode{path_factory}}
\begin{itemdecl}
    void rectangle(const experimental::io2d::rectangle& r);
    void rectangle(const experimental::io2d::rectangle& r, 
      error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\begin{enumerate}
	\item \tcode{_Data.reserve(_Data.size() + 5U)}.

	\item \tcode{*this.move_to(\{ r.x(), r.y() \})}.
	
	\item \tcode{*this.rel_line_to(\{ r.width(), 0.0 \})}.
	
	\item \tcode{*this.rel_line_to(\{ 0.0, r.height() \})}.
	
	\item \tcode{*this.rel_line_to(\{ -r.width(), 0.0 \})}.
	
	\item \tcode{*this.close_path()}.
	\end{enumerate}
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_curve_to}}
\indexlibrary{\idxcode{rel_curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2);
    void rel_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::rel_curve_to(dpt0, dpt1, dpt2))}.
	
	\pnum
	\tcode{_Current_point = dpt2 + _Current_point}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
	
	\pnum
	\tcode{io2d_error::no_current_point} if \tcode{_Has_current_point == false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_line_to}}
\indexlibrary{\idxcode{rel_line_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_line_to(const vector_2d& dpt);
    void rel_line_to(const vector_2d& dpt, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::rel_line_to(pt))}.
	
	\pnum
	\tcode{_Current_point = dpt + _Current_point}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
	
	\pnum
	\tcode{io2d_error::no_current_point} if \tcode{_Has_current_point == false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_move_to}}
\indexlibrary{\idxcode{rel_move_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_move_to(const vector_2d& dpt);
    void rel_move_to(const vector_2d& dpt, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::rel_move_to(dpt))}.
	
	\pnum
	\tcode{_Current_point = dpt + _Current_point}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
	
	\pnum
	\tcode{io2d_error::no_current_point} if \tcode{_Has_current_point == false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{transform_matrix}}
\indexlibrary{\idxcode{transform_matrix}!\idxcode{path_factory}}
\begin{itemdecl}
    void transform_matrix(const matrix_2d& m);
    void transform_matrix(const matrix_2d& m, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::change_matrix(m))}.
	
	\pnum
	\tcode{_Transform_matrix = m}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{origin}}
\indexlibrary{\idxcode{origin}!\idxcode{path_factory}}
\begin{itemdecl}
    void origin(const vector_2d& pt);
    void origin(const vector_2d& pt, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{_Data.emplace_back(path_data_item::change_origin(pt)))}.
	
	\pnum
	\tcode{_Origin = pt}.
	
	\pnum
	\postconditions
	\tcode{_Origin == pt}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\remarks
	In the event of an error, the object shall not be modified.

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the \tcode{path_data_item} failed.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{clear}}
\indexlibrary{\idxcode{clear}!\idxcode{path_factory}}
\begin{itemdecl}
    void clear() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Data.empty() == true}.
	
	\pnum
	\tcode{_Has_current_point == false}.
	
	\pnum
	\tcode{_Transform_matrix == matrix_2d::init_identity\{ \}}.
	
	\pnum
	\tcode{_Origin == vector_2d\{ \}}.
\end{itemdescr}

\rSec1 [pathfactory.observers] {\tcode{path_factory} observers}

\indexlibrary{\idxcode{path_factory}!\idxcode{path_extents}}
\indexlibrary{\idxcode{path_extents}!\idxcode{path_factory}}
\begin{itemdecl}
    experimental::io2d::rectangle path_extents() const;
    experimental::io2d::rectangle path_extents(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	A \tcode{rectangle} object which contains the extents of the path segments, including degenerate path segments, in \tcode{_Data} when it is processed as described in \ref{pathgeometries.processing}.
	\enternote
	By using path segments, this description intentionally excludes points established by \tcode{move_to} and \tcode{rel_move_to} operations from the extents value except where those points are subsequently used in defining a path segment.
	\exitnote

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\errors
	\tcode{io2d_error::invalid_matrix} if \tcode{_Data} includes a \tcode{change_matrix} operation which establishes a non-invertible \tcode{matrix_2d} as the transformation matrix and that matrix must subsequently be inverted in order to process the path geometries.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{has_current_point}}
\indexlibrary{\idxcode{has_current_point}!\idxcode{path_factory}}
\begin{itemdecl}
    bool has_current_point() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Has_current_point}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{current_point}}
\indexlibrary{\idxcode{current_point}!\idxcode{path_factory}}
\begin{itemdecl}
    vector_2d current_point() const;
    vector_2d current_point(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Current_point}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\errors
	\tcode{io2d_error::no_current_point} if \tcode{_Has_current_point == false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{transform_matrix}}
\indexlibrary{\idxcode{transform_matrix}!\idxcode{path_factory}}
\begin{itemdecl}
    matrix_2d transform_matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Transform_matrix}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{origin}}
\indexlibrary{\idxcode{origin}!\idxcode{path_factory}}
\begin{itemdecl}
    vector_2d origin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Origin}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{data}}
\indexlibrary{\idxcode{data}!\idxcode{path_factory}}
\begin{itemdecl}
    vector<path_data_item> data() const;
    vector<path_data_item> data(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	A copy of \tcode{_Data}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{data_item}}
\indexlibrary{\idxcode{data_item}!\idxcode{path_factory}}
\begin{itemdecl}
    path_data_item data_item(unsigned int index) const;
    path_data_item data_item(unsigned int index, error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Data.at(index)}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\errors
	\tcode{io2d_error::invalid_index} if \tcode{_Data.size() <= index}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{data_ref}}
\indexlibrary{\idxcode{data_ref}!\idxcode{path_factory}}
\begin{itemdecl}
    const vector<path_data_item>& data_ref() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Data}.
\end{itemdescr}
