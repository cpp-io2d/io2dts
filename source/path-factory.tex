%!TEX root = io2d.tex
\rSec0 [pathfactory] {Class \tcode{path_factory}}

\pnum
\indexlibrary{\idxcode{path_factory}}
The class \tcode{path_factory} is a container that stores and manipulates objects of type \tcode{path_factory::path_data} from which \tcode{path_group} objects are created.

\pnum
A \tcode{path_factory} is a contiguous container. (See [container.requirements.general] in \cppseventeen.)

\pnum
The collection of \tcode{path_factory::path_data} objects in a path factory is referred to as its path group.

\pnum
In addition to its path group, a path factory has an origin of type \tcode{vector_2d}, a transformation matrix of type \tcode{matrix_2d}, a current point of type \tcode{std::optional<vector_2d>}, and a last-move-to point of type \tcode{vector_2d}.

\pnum
When a path factory is default constructed:

\begin{itemize}
	\item The path group shall be empty.
	\item The current point shall not contain a value.
	\item The transformation matrix shall have a value of \tcode{matrix_2d::init_identity\{ \}}.
	\item The origin shall have a value of \tcode{vector_2d\{ \}}.
\end{itemize}

\rSec1 [pathfactory.synopsis] {\tcode{path_factory} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class path_factory {
  public:
    class path_abs_move {
    public:
      explicit path_abs_move(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_abs_line {
    public:
      explicit path_abs_line(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_rel_move {
    public:
      explicit path_rel_move(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_rel_line {
    public:
      explicit path_rel_line(const vector_2d& to) noexcept;
      
      vector_2d to() const noexcept;
      void to(const vector_2d& value) noexcept;
    };
    
    class path_abs_cubic_curve {
    public:
      path_abs_cubic_curve(const vector_2d& cp1, const vector_2d& cp2,
        const vector_2d& ep) noexcept;
      
      void control_point_1(const vector_2d& cp) noexcept;
      void control_point_2(const vector_2d& cp) noexcept;
      void end_point(const vector_2d& ep) noexcept;
      
      vector_2d control_point_1() const noexcept;
      vector_2d control_point_2() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_rel_cubic_curve {
    public:
      path_rel_cubic_curve(const vector_2d& cp1, const vector_2d& cp2,
        const vector_2d& ep) noexcept;
      
      void control_point_1(const vector_2d& cp) noexcept;
      void control_point_2(const vector_2d& cp) noexcept;
      void end_point(const vector_2d& ep) noexcept;
      
      vector_2d control_point_1() const noexcept;
      vector_2d control_point_2() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_abs_quadratic_curve {
    public:
      path_abs_quadratic_curve(const vector_2d& cp1, const vector_2d& cp2,
        const vector_2d& ep) noexcept;
    
      void control_point_1(const vector_2d& cp) noexcept;
      void control_point_2(const vector_2d& cp) noexcept;
      void end_point(const vector_2d& ep) noexcept;
    
      vector_2d control_point_1() const noexcept;
      vector_2d control_point_2() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_rel_quadratic_curve {
    public:
      path_rel_quadratic_curve(const vector_2d& cp, const vector_2d& ep)
        noexcept;
    
      void control_point(const vector_2d& cp) noexcept;
      void end_point(const vector_2d& ep) noexcept;
    
      vector_2d control_point() const noexcept;
      vector_2d end_point() const noexcept;
    };
    
    class path_arc_clockwise {
    public:
      path_arc_clockwise(const vector_2d& center, double radius, double angle1, double angle2) noexcept;
      
      void center(const vector_2d& value) noexcept;
      void radius(double value) noexcept;
      void angle_1(double radians) noexcept;
      void angle_2(double radians) noexcept;
      
      vector_2d center() const noexcept;
      double radius() const noexcept;
      double angle_1() const noexcept;
      double angle_2() const noexcept;
    };
    
    class path_arc_counterclockwise {
    public:
      path_arc_counterclockwise(const vector_2d& center, double radius, double angle1, double angle2) noexcept;
      
      void center(const vector_2d& value) noexcept;
      void radius(double value) noexcept;
      void angle_1(double radians) noexcept;
      void angle_2(double radians) noexcept;
      
      vector_2d center() const noexcept;
      double radius() const noexcept;
      double angle_1() const noexcept;
      double angle_2() const noexcept;
    };
    
    class path_new_path {
    };
    
    class path_close_path {
    };
    
    class path_change_matrix {
    public:
      explicit path_change_matrix(const matrix_2d& m) noexcept;
      
      void matrix(const matrix_2d& value) noexcept;
      matrix_2d matrix() const noexcept;
    };
    
    class path_change_origin {
    public:
      explicit path_change_origin(const vector_2d& origin) noexcept;
      
      void origin(const vector_2d& value) noexcept;
      vector_2d origin() const noexcept;
    };
    
    using path_data      = typename variant<path_abs_move, path_rel_move,
      path_abs_line, path_rel_line, path_abs_cubic_curve, path_rel_cubic_curve, 
      path_abs_quadratic_curve, path_rel_quadratic_curve, path_arc_clockwise, 
      path_arc_counterclockwise, path_new_path, path_close_path, 
      path_change_matrix, path_change_origin>;
    
    using iterator       = @\impdefx{type of \tcode{path_factory::iterator}}@. // See [container.requirements] in \cppseventeen.
    using const_iterator = @\impdefx{type of \tcode{path_factory::const_iterator}}@. // See [container.requirements] in \cppseventeen.
    using reverse_iterator       = std::reverse_iterator<iterator>;
    using const_reverse_iterator = std::reverse_iterator<const_iterator>;
    
    // \ref{pathfactory.modifiers}, modifiers:
    void new_path() noexcept;
    void close_path() noexcept;
    void arc_clockwise(const vector_2d& center, double radius, double angle1,
      double angle2) noexcept;
    void arc_counterclockwise(const vector_2d& center, double radius,
      double angle1, double angle2) noexcept;
    void cubic_curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2) noexcept;
    void line_to(const vector_2d& pt) noexcept;
    void move_to(const vector_2d& pt) noexcept;
    void quadratic_curve_to(const vector_2d& pt0, const vector_2d& pt2)
      noexcept;
    void rectangle(const experimental::io2d::rectangle& r) noexcept;
    void rel_cubic_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2) noexcept;
    void rel_line_to(const vector_2d& dpt) noexcept;
    void rel_move_to(const vector_2d& dpt) noexcept;
    void rel_quadratic_curve_to(const vector_2d& pt0, const vector_2d& pt2)
      noexcept;
    void transform_matrix(const matrix_2d& m) noexcept;
    void origin(const vector_2d& pt) noexcept;
    void clear() noexcept;

    // \ref{pathfactory.iterators}, iterators:
    iterator begin() noexcept;
    const_iterator begin() const noexcept;
    const_iterator cbegin() const noexcept;

    iterator end() noexcept;
    const_iterator end() const noexcept;
    const_iterator cend() const noexcept;
    
    
    reverse_iterator rbegin() noexcept;
    const_reverse_iterator rbegin() const noexcept;
    const_reverse_iterator crbegin() const noexcept;

    reverse_iterator rend() noexcept;
    const_reverse_iterator rend() const noexcept;
    const_reverse_iterator crend() const noexcept;

    
    // \ref{pathfactory.observers}, observers:
    experimental::io2d::rectangle path_extents() const noexcept;
    bool has_current_point() const noexcept;
    vector_2d current_point() const;
    vector_2d current_point(error_code& ec) const noexcept;
    matrix_2d transform_matrix() const noexcept;
    vector_2d origin() const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [pathfactory.modifiers] {\tcode{path_factory} modifiers}

\indexlibrary{\idxcode{path_factory}!\idxcode{new_path}}
\indexlibrary{\idxcode{new_path}!\idxcode{path_factory}}
\begin{itemdecl}
    void new_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_new_path()} to the end of the path group and destroys the value, if any, of the current point.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{close_path}}
\indexlibrary{\idxcode{close_path}!\idxcode{path_factory}}
\begin{itemdecl}
    void close_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_close_path()} to the end of the path group and sets the value of the current point to the value of the last-move-to point.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{arc_clockwise}}
\indexlibrary{\idxcode{arc_clockwise}!\idxcode{path_factory}}
\begin{itemdecl}
    void arc_clockwise(const vector_2d& center, double radius, double angle1,
      double angle2) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_arc_clockwise(center, radius, angle1, angle2)} to the end of the path group.
	
	\pnum
	If the current point does not contain a value, the last-move-to point shall be set to \tcode{vector_2d\{ radius * cos(angle1), -(radius * -sin(angle1)) \} + center}.
	
	\pnum
	The current point shall be set to \tcode{vector_2d\{ radius * cos(angle2), -(radius * -sin(angle2)) \} + center}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{arc_counterclockwise}}
\indexlibrary{\idxcode{arc_counterclockwise}!\idxcode{path_factory}}
\begin{itemdecl}
    void arc_counterclockwise(const vector_2d& center, double radius,
      double angle1, double angle2) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_arc_counterclockwise(center, radius, angle1, angle2)} to the end of the path group.
	
	\pnum
	If the current point does not contain a value, the last-move-to point shall be set to \tcode{vector_2d\{ radius * cos(angle2), radius * -sin(angle2) \} + center}.
	
	\pnum
	The current point shall be set to \tcode{vector_2d\{ radius * cos(angle1), radius * -sin(angle1) \} + center}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{cubic_curve_to}}
\indexlibrary{\idxcode{cubic_curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void cubic_curve_to(const vector_2d& pt0, const vector_2d& pt1,
      const vector_2d& pt2) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If the current point does not contain a value, adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_move(pt0)} to the end of the path group.
	
	\pnum
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_cubic_curve(pt0, pt1, pt2)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of \tcode{pt2}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{line_to}}
\indexlibrary{\idxcode{line_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void line_to(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If the current point does not contain a value, the last-move-to point shall be set to the value of \tcode{pt}.
	
	\pnum
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_line(pt)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of \tcode{pt}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{move_to}}
\indexlibrary{\idxcode{move_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void move_to(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_move(pt)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of \tcode{pt}. The last-move-to point shall then be set to the value of the current point.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{quadratic_curve_to}}
\indexlibrary{\idxcode{quadratic_curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
	void quadratic_curve_to(const vector_2d& pt0, const vector_2d& pt1)
	  noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	If the current point does not contain a value, adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_move(pt0)} to the end of the path group.
	
	\pnum
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_quadratic_curve(pt0, pt1)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of \tcode{pt1}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rectangle}}
\indexlibrary{\idxcode{rectangle}!\idxcode{path_factory}}
\begin{itemdecl}
    void rectangle(const experimental::io2d::rectangle& r) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\begin{enumerate}
	\item Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_abs_move(\{ r.x(), r.y() \})} to the end of the path group.
	
	\item Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_line(\{ r.width(), 0.0 \})} to the end of the path group.
	
	\item Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_line(\{ 0.0, r.height() \})} to the end of the path group.
	
	\item Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_line(\{ -r.width(), 0.0 \})} to the end of the path group.
	
	\item Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_close_path()} to the end of the path group.
	
	\item The current point shall be set to \tcode{vector_2d\{ r.x() r.y() \}}.
	
	\item The last-move-to point shall be set to \tcode{vector_2d\{ r.x() r.y() \}}.
	\end{enumerate}
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_cubic_curve_to}}
\indexlibrary{\idxcode{rel_cubic_curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_cubic_curve_to(const vector_2d& dpt0, const vector_2d& dpt1,
      const vector_2d& dpt2) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_cubic_curve(dpt0, dpt1, dpt2)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of the current point added to \tcode{dpt2}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_line_to}}
\indexlibrary{\idxcode{rel_line_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_line_to(const vector_2d& dpt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_line(pt)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of the current point added to \tcode{dpt}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_move_to}}
\indexlibrary{\idxcode{rel_move_to}!\idxcode{path_factory}}
\begin{itemdecl}
    void rel_move_to(const vector_2d& dpt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_move(dpt)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of the current point added to \tcode{dpt}.The last-move-to point shall then be set to the value of the current point.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rel_quadratic_curve_to}}
\indexlibrary{\idxcode{rel_quadratic_curve_to}!\idxcode{path_factory}}
\begin{itemdecl}
	void rel_quadratic_curve_to(const vector_2d& dpt0, const vector_2d& dpt1)
	  noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_rel_quadratic_curve(dpt0, dpt1)} to the end of the path group.
	
	\pnum
	The current point shall be set to the value of the current point added to \tcode{dpt1}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{transform_matrix}}
\indexlibrary{\idxcode{transform_matrix}!\idxcode{path_factory}}
\begin{itemdecl}
    void transform_matrix(const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The matrix \tcode{m} shall be invertible.
	
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{(path_factory::path_change_matrix(m)} to the end of the path group.
	
	\pnum
	The transformation matrix shall be set to the value of \tcode{m}.
	\tcode{_Transform_matrix = m}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{origin}}
\indexlibrary{\idxcode{origin}!\idxcode{path_factory}}
\begin{itemdecl}
    void origin(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a \tcode{path_data} object constructed from \tcode{path_factory::path_change_origin(pt)} to the end of the path group.
	
	\pnum
	The origin shall be set to the value of \tcode{pt}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{clear}}
\indexlibrary{\idxcode{clear}!\idxcode{path_factory}}
\begin{itemdecl}
    void clear() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\pnum
	The path group shall be empty.
	
	\pnum
	The current point shall not contain a value.
	
	\pnum
	The transformation matrix shall have a value of \tcode{matrix_2d::init_identity\{ \}}.
	
	\pnum
	The origin shall have a value of \tcode{vector_2d\{ \}}.
\end{itemdescr}

\rSec1 [pathfactory.iterators] {\tcode{path_factory} iterators}
    
\indexlibrary{\idxcode{path_factory}!\idxcode{begin}}
\indexlibrary{\idxcode{begin}!\idxcode{path_factory}}
\indexlibrary{\idxcode{path_factory}!\idxcode{cbegin}}
\indexlibrary{\idxcode{cbegin}!\idxcode{path_factory}}
\begin{itemdecl}
	iterator begin() noexcept;
	const_iterator begin() const noexcept;
	const_iterator cbegin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	An iterator referring to the first \tcode{path_data} item in the path group.
	
	\pnum
	\remarks
	Changing a \tcode{path_data} object or otherwise modifying the path group in a way that violates the preconditions of that \tcode{path_data} object or of any subsequent \tcode{path_data} object in the path group shall result in undefined behavior when the path group is processed as described in \ref{paths.processing} unless all of the violations are fixed prior to such processing.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{end}}
\indexlibrary{\idxcode{end}!\idxcode{path_factory}}
\indexlibrary{\idxcode{path_factory}!\idxcode{cend}}
\indexlibrary{\idxcode{cend}!\idxcode{path_factory}}
\begin{itemdecl}
	iterator end() noexcept;
	const_iterator end() const noexcept;
	const_iterator cend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	An iterator which is the past-the-end value.
	
	\pnum
	\remarks
	Changing a \tcode{path_data} object or otherwise modifying the path group in a way that violates the preconditions of that \tcode{path_data} object or of any subsequent \tcode{path_data} object in the path group shall result in undefined behavior when the path group is processed as described in \ref{paths.processing} unless all of the violations are fixed prior to such processing.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rbegin}}
\indexlibrary{\idxcode{rbegin}!\idxcode{path_factory}}
\indexlibrary{\idxcode{path_factory}!\idxcode{crbegin}}
\indexlibrary{\idxcode{crbegin}!\idxcode{path_factory}}
\begin{itemdecl}
	reverse_iterator rbegin() noexcept;
	const_reverse_iterator rbegin() const noexcept;
	const_reverse_iterator crbegin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	An iterator which is semantically equivalent to \tcode{reverse_iterator(end)}.
	
	\pnum
	\remarks
	Changing a \tcode{path_data} object or otherwise modifying the path group in a way that violates the preconditions of that \tcode{path_data} object or of any subsequent \tcode{path_data} object in the path group shall result in undefined behavior when the path group is processed as described in \ref{paths.processing} all of the violations are fixed prior to such processing.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{rend}}
\indexlibrary{\idxcode{rend}!\idxcode{path_factory}}
\indexlibrary{\idxcode{path_factory}!\idxcode{crend}}
\indexlibrary{\idxcode{crend}!\idxcode{path_factory}}
\begin{itemdecl}
	reverse_iterator rend() noexcept;
	const_reverse_iterator rend() const noexcept;
	const_reverse_iterator crend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	An iterator which is semantically equivalent to \tcode{reverse_iterator(begin)}.
	
	\pnum
	\remarks
	Changing a \tcode{path_data} object or otherwise modifying the path group in a way that violates the preconditions of that \tcode{path_data} object or of any subsequent \tcode{path_data} object in the path group shall result in undefined behavior when the path group is processed as described in \ref{paths.processing} unless all of the violations are fixed prior to such processing.
\end{itemdescr}

\rSec1 [pathfactory.observers] {\tcode{path_factory} observers}

\indexlibrary{\idxcode{path_factory}!\idxcode{path_extents}}
\indexlibrary{\idxcode{path_extents}!\idxcode{path_factory}}
\begin{itemdecl}
    experimental::io2d::rectangle path_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	A \tcode{rectangle} object which contains the extents of the path segments, including degenerate path segments, in the path group when it is processed as described in \ref{paths.processing}.
	\enternote
	By using path segments, this description intentionally excludes points established by \tcode{move_to} and \tcode{rel_move_to} operations from the extents value except where those points are subsequently used in defining a path segment.
	\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{has_current_point}}
\indexlibrary{\idxcode{has_current_point}!\idxcode{path_factory}}
\begin{itemdecl}
    bool has_current_point() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	If the current point contains a value, \tcode{true}, otherwise \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{current_point}}
\indexlibrary{\idxcode{current_point}!\idxcode{path_factory}}
\begin{itemdecl}
    vector_2d current_point() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	The current point contains a value.
	
	\pnum
	\returns
	The value of the current point.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{transform_matrix}}
\indexlibrary{\idxcode{transform_matrix}!\idxcode{path_factory}}
\begin{itemdecl}
    matrix_2d transform_matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	The value of the transformation matrix.
\end{itemdescr}

\indexlibrary{\idxcode{path_factory}!\idxcode{origin}}
\indexlibrary{\idxcode{origin}!\idxcode{path_factory}}
\begin{itemdecl}
    vector_2d origin() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	The value of the origin.
\end{itemdescr}
