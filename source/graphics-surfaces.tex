%!TEX root = io2d.tex

\rSec0 [\iotwod.graphsurf] {Graphics surfaces}

\rSec1 [\iotwod.graphsurf.general]{General}

\pnum
This \clause defines requirements on \term{\graphicssurfacestemplparamnospace} types.

\pnum
Most classes specified in \clause \ref{\iotwod.paths}, \clause \ref{\iotwod.brushes}, and \clause \ref{\iotwod.surfaces} need a set of related types and functions to complete the definition of their semantics. These types and functions are provided as a set of \grammarterm{typedef-name}{s} and member \grammarterm{typedef-name}{s} and functions contained in classes in the template parameter \tcode{\graphicssurfacestemplparamnospace} used by each such template. This \clause defines the names of the classes and the semantics of their members.

\rSec1 [\iotwod.graphsurf.reqs] {Requirements}

\rSec2 [\iotwod.graphsurf.reqs.classes] {Classes}

\pnum
A \graphicssurfacestemplparam type is a class template with one type parameter. The template type argument of an instantiation of a \graphicssurfacestemplparam specialization shall meet the requirements of a \graphicsmathtemplparam type (See: \ref{\iotwod.graphmath}).

\pnum
A \graphicssurfacestemplparam type contains a \grammarterm{typedef-name} \tcode{graphics_math_type}, which is an identifier for the template argument. It also contains a \grammarterm{typedef-name} \tcode{graphics_surfaces_type}, which is an identifier for the \graphicssurfacestemplparam type.

\pnum
\begin{example}
\begin{codeblock}
template <class GraphMath>
struct GraphSurf {
  using graphics_math_type = GraphMath;
  using graphics_surfaces_type = GraphSurf;
  // ...
};
\end{codeblock}
\end{example}

\pnum
A \graphicssurfacestemplparam is required to have the following \tcode{public} nested classes:

\begin{enumerate}
\item \tcode{additional_image_file_formats}
\item \tcode{brushes}
\item \tcode{paths}
\item \tcode{surface_states}
\item \tcode{surfaces}
\end{enumerate}

\rSec2 [\iotwod.graphsurf.reqs.addform]{\tcode{additional_image_file_formats}}

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
The \tcode{X::additional_image_file_formats} class contains zero or more \tcode{image_file_format} enumerators that represent \impldefplain{additional data formats} additional data formats that the implementation can both construct an \tcode{image_surface} object from using the appropriate constructor and save an \tcode{image_surface} object to using \tcode{image_surface::save}. These are called \term{read/write image format enumerators}.

\pnum
The values of read/write image format enumerators shall be in the range \crange{10000}{19999}.

\pnum
The \tcode{X::additional_image_file_formats} class also contains the following nested classes:

\begin{enumerate}
\item \tcode{read_only}
\item \tcode{write_only}
\end{enumerate}

\pnum
The \tcode{additional_image_file_formats} class contains zero or more \tcode{image_file_format} enumerators that represent \impldefplain{additional read only data formats} additional data formats that the implementation can construct an \tcode{image_surface} object from using the appropriate constructor but cannot save an \tcode{image_surface} object to using \tcode{image_surface::save}. These are called \term{read only image format enumerators}.

\pnum
The values of read only image format enumerators shall be in the range \crange{20000}{29999}.

\pnum
The \tcode{additional_image_file_formats::write_only} class contains zero or more \tcode{image_file_format} enumerators that represent \impldefplain{additional write only data formats} additional data formats that the implementation can construct an \tcode{image_surface} object from using the appropriate constructor and save an \tcode{image_surface} object to using \tcode{image_surface::save} but cannot construct an \tcode{image_surface} object from using any constructor. These are called \term{write only image format enumerators}.

\pnum
The values of write only image format enumerators shall be in the range \crange{30000}{39999}.

\rSec2 [\iotwod.graphsurf.reqs.brushes]{\tcode{brushes} reqs}

\pnum
Brushes are described in \ref{\iotwod.brushes}.

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
Let \tcode{M} be \tcode{X::graphics_math_type}.

\pnum
Table~\ref{tab:\iotwod.graphsurf.brushes.requirementstab} describes the observable effects of a member functions of \tcode{X::brushes}.

\pnum
\tcode{X::brushes} contains a \grammarterm{typedef-name}, 
\tcode{brush_data_type}, which is an identifier for a class type capable of
storing all data required to support a brush of any type described in
\ref{\iotwod.brushes}. \begin{note}
The information in \ref{\iotwod.brush.sampling} is particularly important.
\end{note}

\pnum
\begin{note}
Brushes are immutable objects. As such, the contents of the class type for which \tcode{X::brushes::brush_data_type} is an identifier are thus capable of being highly tailored to the \underlyingrendandpresenttechs which are used by \tcode{X}. Indeed, while it is required to report its \tcode{brush_type} by one of the member functions below, it need not even store a variable of that type so long as it can correctly provide it when that member function is called.
\end{note}

\begin{libreqtab4d}
{\tcode{X::brushes} requirements}
{tab:\iotwod.graphsurf.brushes.requirementstab}
\\ \topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\rhdr{Assertion/note}   \\
    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endfirsthead
\continuedcaption\\
\topline
\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
\rhdr{Assertion/note}   \\
    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
\endhead
\tcode{X::brushes::create_brush(const rgba_color\& c)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a solid color brush,
its visual data is \tcode{c} (See: \ref{\iotwod.brush.sampling.color}),
and \tcode{X::brushes::get_brush_type(b) == brush_type::solid_color}.
\begin{note}
Solid color does not imply opaque. The color may be translucent or even transparent.
\end{note}	\\ \rowsep
\tcode{template <class InputIterator>\newline%
create_brush(const basic_point_2d<M>\& be, const basic_point_2d<M>\& en, InputIterator first, InputIterator last)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a linear gradient brush, its begin point is \tcode{be}, its end point is \tcode{en}, its gradient stops are formed using the sequential series of \tcode{gradient_stop} objects beginning at \tcode{first} and ending at \tcode{last - 1} (See \ref{\iotwod.gradients.linear} and \ref{\iotwod.gradients.sampling}),
and \tcode{X::brushes::get_brush_type(b) == brush_type::linear}.	\\ \rowsep
\tcode{create_brush(const basic_point_2d<M>\& be, const basic_point_2d<M>\& en, initializer_list<gradient_stop> il)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a linear gradient brush, its begin point is \tcode{be}, its end point is \tcode{en}, its gradient stops are formed using the sequential series of \tcode{gradient_stop} objects in \tcode{il} (See \ref{\iotwod.gradients.linear} and \ref{\iotwod.gradients.sampling}),
and \tcode{X::brushes::get_brush_type(b) == brush_type::linear}.	\\ \rowsep
\tcode{template <class InputIterator>\newline%
create_brush(const basic_circle<M>\& be, const basic_circle<M>\& en, InputIterator first, InputIterator last)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a radial gradient brush, its start circle is \tcode{be}, its end circle is \tcode{en}, its gradient stops are formed using the sequential series of \tcode{gradient_stop} objects beginning at \tcode{first} and ending at \tcode{last - 1} (See \ref{\iotwod.gradients.radial} and \ref{\iotwod.gradients.sampling}),
and \tcode{X::brushes::get_brush_type(b) == brush_type::radial}.	\\ \rowsep
\tcode{create_brush(const basic_circle<M>\& be, const basic_circle<M>\& en, initializer_list<gradient_stop> il)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a radial gradient brush, its start circle is \tcode{be}, its end circle is \tcode{en}, its gradient stops are formed using the sequential series of \tcode{gradient_stop} objects in \tcode{il} (See \ref{\iotwod.gradients.radial} and \ref{\iotwod.gradients.sampling}),
and \tcode{X::brushes::get_brush_type(b) == brush_type::radial}.	\\ \rowsep
\tcode{create_brush(basic_image_surface<graphics_surfaces_type>\&\& i)}	&
\tcode{brush_data_type}	&
Returns an object \tcode{b}.	&
\postconditions
\tcode{b} is a surface brush, its visual data is the pixmap from \tcode{i},
and \tcode{X::brushes::get_brush_type(b) == brush_type::surface}	\\ \rowsep
%\tcode{static brush_data_type copy_brush(const brush_data_type& data)}	&
%\tcode{brush_data_type}	&
%Returns a copy of \tcode{data}. It is \unspecnorm whether the visual data of the brush is copied.	&
%	\\ \rowsep
%\tcode{X::brushes::move_brush(brush_data_type&& data)}	&
%Returns \tcode{data}.	&
%\begin{note}
%This function allows implementations to perform additional work when moving
%\end{note}	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\ \rowsep
\tcode{get_brush_type(const brush_data_type\& data)}	&
\tcode{brush_type}	&
Returns the brush type of \tcode{data}.	&
	\\
\end{libreqtab4d}


\rSec2 [\iotwod.graphsurf.reqs.paths]{\tcode{paths} reqs}

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
<TODO>

%\begin{libreqtab4d}
%{Graphics surfaces requirements}
%{tab:\iotwod.graphicssurfaces.graphicssurfaces.requirements}
%\\ \topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endfirsthead
%\continuedcaption\\
%\topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endhead
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\
%\end{libreqtab4d}

\rSec2 [\iotwod.graphsurf.reqs.surfstate]{\tcode{surface_state_props} reqs}

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
<TODO>

%\begin{libreqtab4d}
%{Graphics surfaces requirements}
%{tab:\iotwod.graphicssurfaces.graphicssurfaces.requirements}
%\\ \topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endfirsthead
%\continuedcaption\\
%\topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endhead
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\
%\end{libreqtab4d}

\rSec2 [\iotwod.graphsurf.reqs.surfaces]{\tcode{surfaces} reqs}

\pnum
Let \tcode{X} be a \graphicssurfacestemplparam type.

\pnum
<TODO>

%All expressions in Table~\ref{tab:\iotwod.graphicssurfaces.graphicssurfaces.requirements} are \tcode{noexcept}. For purposes of brevity, \tcode{noexcept} is omitted in the table.
%
%\begin{libreqtab4d}
%{Graphics surfaces requirements}
%{tab:\iotwod.graphicssurfaces.graphicssurfaces.requirements}
%\\ \topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endfirsthead
%\continuedcaption\\
%\topline
%\lhdr{Expression}       &   \chdr{Return type}  &   \chdr{Operational}  &
%\rhdr{Assertion/note}   \\
%    &   &   \chdr{semantics}    &   \rhdr{pre-/post-condition}   \\ \capsep
%\endhead
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\ \rowsep
%	&
%	&
%	&
%	\\
%\end{libreqtab4d}
