%!TEX root = io2d.tex
\rSec0 [pathgeometries] {Path geometries}

\rSec1 [pathgeometries.overview] {Overview of path geometries}

\pnum
Path geometries are most easily formed using a \tcode{path_factory} object.

\pnum
They may also be formed by directly creating and manipulating a \tcode{vector<path_data_item>} object.

\pnum
A path geometry may contain degenerate path segments.

\pnum
There are special rules concerning the rendering of degenerate path segments. As such they shall be added to a path geometry when requested and shall not be removed from a path geometry when processing it.

\pnum
A \tcode{path} object is an immutable resource wrapper containing a path geometry graphics resource (\ref{path}).

\rSec1 [pathgeometries.processing] {Processing path geometries}

\pnum
\ref{pathgeometries.processing} describes how a properly formed \tcode{vector<path_data_item>} object shall be interpreted by an implementation in order to convert it into a path geometry graphics resource.

\pnum
For purposes of exposition, the following class for forming a path geometry graphics resource object is used:

***FIXME*** Doesn't provide or properly set state data, collections, etc. XXXXXXXXXX 

\begin{codeblock}
// \expos
class native_geometry_collection {
public:
  void current_point(const vector_2d& pt) noexcept;
  void close_point(const vector_2d& pt) noexcept;
  void line_to(const vector_2d& pt) noexcept;
  void curve_to(const vector_2d& control1, const vector_2d& control2,
    const vector_2d& endPt) noexcept;
  void close_path() noexcept;
};
// \expos
\end{codeblock}

\begin{itemdecl}
  void current_point(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Stores \tcode{pt} as the current point.

\end{itemdescr}

\begin{itemdecl}
  void close_point(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Stores \tcode{pt} as the close point.

\end{itemdescr}

\begin{itemdecl}
  void line_to(const vector_2d& pt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates a line from the current point to \tcode{pt}.

\end{itemdescr}

\begin{itemdecl}
  void curve_to(const vector_2d& cpt1, const vector_2d& cpt2,
    const vector_2d& endPt) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates a cubic B\'ezier curve from the current point to \tcode{endPt} using \tcode{cpt1} as the first control point and \tcode{cpt2} as the second control point.

\end{itemdescr}

\begin{itemdecl}
  void close_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates a line from the current point to the close point. If this geometry is stroked, the point where the close point meets the line or curve that began the path geometry shall be rendered as a join in accordance with the current \tcode{line_join} value.

\end{itemdescr}

\pnum
\enternote
A path geometry graphics resource that only supports rendering triangles is possible. The triangles would be used to form lines and to approximate curves. This description assumes the existence of a path geometry graphics resource that performs those actions where needed.
\exitnote

\pnum
The following code shows how to properly process \tcode{vector<path_data_item> p} and store the results into \tcode{native_geometry_collection n}:

\begin{codeblock}
const double pi =     3.1415926535897932384626433832795;
const double halfpi = 1.57079632679489661923132169163985;
const double twopi =  6.283185307179586476925286766559;
matrix_2d m;
vector_2d origin;
vector_2d currentPoint;
bool hasCurrentPoint = false;
vector_2d closePoint;

for (const auto& item : p) {
  switch(item.type()) {
  case path_data_type::move_to:
  {
    currentPoint = item.get<move_to>().to();
    auto pt = m.transform_point(currentPoint - origin) + origin;
    n.current_point(pt);
    hasCurrentPoint = true;
    closePoint = pt
    n.close_point(pt);
  } break;
  case path_data_type::line_to:
  {
    currentPoint = item.get<line_to>().to();
    auto pt = m.transform_point(currentPoint - origin) + origin;
    if (hasCurrentPoint) {
      n.line_to(pt);
    }
    else {
      n.current_point(pt);
      hasCurrentPoint = true;
      closePoint = pt;
      n.close_point(pt);
    }
  } break;
  case path_data_type::curve_to:
  {
    auto cd = item.get<curve_to>();
    auto pt1 = m.transform_point(cd.control_point_1() - origin) + origin;
    auto pt2 = m.transform_point(cd.control_point_2() - origin) + origin;
    auto pt3 = m.transform_point(cd.end_point() - origin) + origin;
    if (!hasCurrentPoint) {
      currentPoint = cd.control_point_1();
      n.current_point(pt1);
      hasCurrentPoint = true;
      closePoint = pt1;
      n.close_point(pt1);
    }
    n.curve_to(pt1, pt2, pt3);
    currentPoint = cd.end_point();
  } break;
  case path_data_type::new_sub_path:
  {
    hasCurrentPoint = false;
  } break;
  case path_data_type::close_path:
  {
    if (!hasCurrentPoint) {
      break;
    }
    n.close_path();
    n.current_point(closePoint);
    // Invert can error so use correct overload; here is the throw version.
    auto invM = matrix_2d{m}.invert();
    // Need the untransformed value for currentPoint.
    currentPoint = invM.transform_point(closePoint - origin) + origin;
  } break;
  case path_data_type::rel_move_to:
  {
    // If !hasCurrentPoint, error is io2d_error::no_current_point;
    currentPoint = item.get<rel_move_to>().to() + currentPoint;
    auto pt = m.transform_point(currentPoint - origin) + origin;
    n.current_point(pt);
    hasCurrentPoint = true;
    closePoint = pt    
    n.close_point(pt);
  } break;
  case path_data_type::rel_line_to:
  {
    // If !hasCurrentPoint, error is io2d_error::no_current_point;
    currentPoint = item.get<rel_line_to>().to() + currentPoint;
    auto pt = m.transform_point(currentPoint - origin) + origin;
    n.line_to(pt);
  } break;
  case path_data_type::rel_curve_to:
  {
    // If !hasCurrentPoint, error is io2d_error::no_current_point;
    auto cd = item.get<rel_curve_to>();
    auto pt1 = m.transform_point(cd.control_point_1() + currentPoint -
      origin) + origin;
    auto pt2 = m.transform_point(cd.control_point_2() + currentPoint -
      origin) + origin;
    auto pt3 = m.transform_point(cd.end_point() + currentPoint - origin) +
      origin;
    n.curve_to(pt1, pt2, pt3);
    currentPoint = cd.end_point() + currentPoint;
  } break;
  case path_data_type::arc:
  {
    auto ad = item.get<arc>();
    auto ctr = ad.center();
    auto rad = ad.radius();
    auto ang1 = ad.angle_1();
    auto ang2 = ad.angle_2();
    while(ang2 < ang1) {
      ang2 += twopi;
    }
    vector_2d pt0, pt1, pt2, pt3;
    int bezCount = 1;
    double theta = ang2 - ang1;
    double phi;
    while (theta >= halfpi) {
      theta /= 2.0;
      bezCount += bezCount;
    }
    phi = theta / 2.0;
    auto cosPhi = cos(phi);
    auto sinPhi = sin(phi);
    pt0.x(cosPhi);
    pt0.y(-sinPhi);
    pt3.x(pt0.x());
    pt3.y(-pt0.y());
    pt1.x((4.0 - cosPhi) / 3.0);
    pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
    pt2.x(pt1.x());
    pt2.y(-pt1.y());
    phi = -phi;
    auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
      return { pt.x() * cos(a) + pt.y() * sin(a),
        -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
    };
    pt0 = rotCwFn(pt0, phi);
    pt1 = rotCwFn(pt1, phi);
    pt2 = rotCwFn(pt2, phi);
    pt3 = rotCwFn(pt3, phi);
    
    auto currTheta = ang1;
    const auto startPt =
      ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
    if (hasCurrentPoint) {
      currentPoint = startPt;
      auto pt = m.transform_point(currentPoint - origin) + origin;
      n.line_to(pt);
    }
    else {
      currentPoint = startPt;
      auto pt = m.transform_point(currentPoint - origin) + origin;
      n.current_point(pt);
      hasCurrentPoint = true;
      closePt = pt;
      n.close_point(pt);
    }
    for (; bezCount > 0; bezCount--) {
      auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad }, currTheta);
      auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad }, currTheta);
      auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad }, currTheta);
      currentPoint = cpt3;
      cpt1 = m.transform_point(cpt1 - origin) + origin;
      cpt2 = m.transform_point(cpt2 - origin) + origin;
      cpt3 = m.transform_point(cpt3 - origin) + origin;
      n.curve_to(cpt1, cpt2, cpt3);
      currTheta += theta;
    }
  } break;
  case path_data_type::arc_negative:
  {
    auto ad = item.get<arc_negative>();
    auto ctr = ad.center();
    auto rad = ad.radius();
    auto ang1 = ad.angle_1();
    auto ang2 = ad.angle_2();
    while(ang2 > ang1) {
      ang2 -= twopi;
    }
    vector_2d pt0, pt1, pt2, pt3;
    int bezCount = 1;
    double theta = ang1 - ang2;
    double phi;
    while (theta >= halfpi) {
      theta /= 2.0;
      bezCount += bezCount;
    }
    phi = theta / 2.0;
    auto cosPhi = cos(phi);
    auto sinPhi = sin(phi);
    pt0.x(cosPhi);
    pt0.y(-sinPhi);
    pt3.x(pt0.x());
    pt3.y(-pt0.y());
    pt1.x((4.0 - cosPhi) / 3.0);
    pt1.y(-(((1.0 - cosPhi) * (3.0 - cosPhi)) / (3.0 * sinPhi)));
    pt2.x(pt1.x());
    pt2.y(-pt1.y());
    auto rotCwFn = [](const vector_2d& pt, double a) -> vector_2d {
      return { pt.x() * cos(a) + pt.y() * sin(a),
        -(pt.x() * -(sin(a)) + pt.y() * cos(a)) };
    };
    pt0 = rotCwFn(pt0, phi);
    pt1 = rotCwFn(pt1, phi);
    pt2 = rotCwFn(pt2, phi);
    pt3 = rotCwFn(pt3, phi);
    auto shflPt = pt3;
    pt3 = pt0;
    pt0 = shflPt;
    shflPt = pt2;
    pt2 = pt1;
    pt1 = shflPt;
    auto currTheta = ang1;
    const auto startPt =
      ctr + rotCwFn({ pt0.x() * rad, pt0.y() * rad }, currTheta);
    if (hasCurrentPoint) {
      currentPoint = startPt;
      auto pt = m.transform_point(currentPoint - origin) + origin;
      n.line_to(pt);
    }
    else {
      currentPoint = startPt;
      auto pt = m.transform_point(currentPoint - origin) + origin;
      n.current_point(pt);
      hasCurrentPoint = true;
      closePt = pt;
      n.close_point(pt);
    }
    for (; bezCount > 0; bezCount--) {
      auto cpt1 = ctr + rotCwFn({ pt1.x() * rad, pt1.y() * rad }, currTheta);
      auto cpt2 = ctr + rotCwFn({ pt2.x() * rad, pt2.y() * rad }, currTheta);
      auto cpt3 = ctr + rotCwFn({ pt3.x() * rad, pt3.y() * rad }, currTheta);
      currentPoint = cpt3;
      cpt1 = m.transform_point(cpt1 - origin) + origin;
      cpt2 = m.transform_point(cpt2 - origin) + origin;
      cpt3 = m.transform_point(cpt3 - origin) + origin;
      n.curve_to(cpt1, cpt2, cpt3);
      currTheta -= theta;
    }
  } break;
  case path_data_type::change_matrix:
  {
    m = item.get<change_matrix>().matrix();
  } break;
  case path_data_type::change_origin:
  {
    origin = item.get<change_origin>().origin();
  } break;
  }
}
\end{codeblock}

\rSec1 [pathgeometries.strokerules] {Stroking path geometries}

\pnum
The following rules shall apply when a \tcode{path} object is stroked by a call to \tcode{surface::stroke} or\\
\tcode{surface::stroke_immediate}.

\begin{enumerate}
	\item Except as otherwise specified in these rules, the start point and end point of a path segment shall be rendered as specified by the meaning of the surface's current \tcode{line_cap} value (\ref{linecap}).
	
	\item If the end point of a path segment \textit{a} is set as the current point and is then used as the start point of another path segment, \textit{b}, the point where \tcode{a}'s end point meets \tcode{b}'s start point shall be rendered as specified by the meaning of the surface's current \tcode{line_join} value (\ref{linejoin}).
	
	\item ***FIXME***
\end{enumerate}

\rSec1 [pathgeometries.fillrules] {Filling path geometries}

\pnum
***FIXME***
