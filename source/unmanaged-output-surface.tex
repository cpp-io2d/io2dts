%!TEX root = io2d.tex
\rSec0 [\iotwod.unmanagedoutputsurface] {Class \tcode{basic_unmanaged_output_surface}}

\rSec1 [\iotwod.unmanagedoutputsurface.summary] {\tcode{basic_unmanaged_output_surface} summary}

\pnum
\indexlibrary{\idxcode{basic_unmanaged_output_surface}}%
<TODO>

\rSec1 [\iotwod.unmanagedoutputsurface.synopsis] {\tcode{basic_unmanaged_output_surface} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  template <class GraphicsSurfaces>
  class basic_unmanaged_output_surface {
  public:
    using graphics_math_type = typename GraphicsSurfaces::graphics_math_type;
    using data_type = typename GraphicsSurfaces::surfaces::unmanaged_output_surface_data_type;

    // \ref{\iotwod.unmanagedoutputsurface.cons}, constructor:
    basic_unmanaged_output_surface(data_type&& data) noexcept;
	
    // \ref{\iotwod.unmanagedoutputsurface.observers}, observers:
    bool has_draw_callback() const noexcept;
    bool has_size_change_callback() const noexcept;
    bool has_user_scaling_callback() const noexcept;
    io2d::format format() const noexcept;
    basic_display_point<graphics_math_type> dimensions() const noexcept;
    basic_display_point<graphics_math_type> max_dimensions() const noexcept;
    basic_display_point<graphics_math_type> display_dimensions() const noexcept;
    basic_display_point<graphics_math_type> max_display_dimensions() const noexcept;
    io2d::scaling scaling() const noexcept;
    optional<basic_brush<GraphicsSurfaces>> letterbox_brush() const noexcept;
    optional<basic_brush_props<GraphicsSurfaces>> letterbox_brush_props() const noexcept;
    bool auto_clear() const noexcept;

    // \ref{\iotwod.unmanagedoutputsurface.mofifiers}, modifiers:
    void invoke_draw_callback();
    void invoke_size_change_callback();
    basic_bounding_box<graphics_math_type> invoke_user_scaling_callback(bool& useLetterbox);
    void draw_to_output();
    void clear();
    void flush();
    void flush(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const basic_bounding_box<graphics_math_type>& extents);
    void mark_dirty(const basic_bounding_box<graphics_math_type>& extents, error_code& ec)
      noexcept;
    void paint(const basic_brush<GraphicsSurfaces>& b,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    template <class Allocator>
    void stroke(const basic_brush<GraphicsSurfaces>& b,
      const basic_path_builder<GraphicsSurfaces, Allocator>& pb,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_stroke_props<GraphicsSurfaces>>& sp = nullopt,
      const optional<basic_dashes<GraphicsSurfaces>>& d = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    void stroke(const basic_brush<GraphicsSurfaces>& b,
      const basic_interpreted_path<GraphicsSurfaces>& ip,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_stroke_props<GraphicsSurfaces>>& sp = nullopt,
      const optional<basic_dashes<GraphicsSurfaces>>& d = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    template <class Allocator>
    void fill(const basic_brush<GraphicsSurfaces>& b,
      const basic_path_builder<GraphicsSurfaces, Allocator>& pb,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    void fill(const basic_brush<GraphicsSurfaces>& b,
      const basic_interpreted_path<GraphicsSurfaces>& ip,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    void mask(const basic_brush<GraphicsSurfaces>& b,
      const basic_brush<GraphicsSurfaces>& mb,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
      const optional<basic_mask_props<GraphicsSurfaces>>& mp = nullopt,
      const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
      const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
    void draw_callback(const function<void(basic_unmanaged_output_surface& sfc)>& fn);
    void size_change_callback(const function<void(basic_unmanaged_output_surface& sfc)>& fn);
    void dimensions(basic_display_point<graphics_math_type> dp);
    void dimensions(basic_display_point<graphics_math_type> dp, error_code& ec) noexcept;
    void display_dimensions(basic_display_point<graphics_math_type> dp);
    void display_dimensions(basic_display_point<graphics_math_type> dp, error_code& ec) noexcept;
    void scaling(io2d::scaling scl) noexcept;
    void user_scaling_callback(const
      function<basic_bounding_box<graphics_math_type>(const
      basic_unmanaged_output_surface&, bool&)>& fn);
    void letterbox_brush(const optional<basic_brush<GraphicsSurfaces>>& b,
      const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt) noexcept;
    void letterbox_brush_props(const optional<basic_brush_props<GraphicsSurfaces>>& bp) noexcept;
    void auto_clear(bool val) noexcept;
    void redraw_required(bool val = true) noexcept;
  };
}
\end{codeblock}

\rSec1 [\iotwod.unmanagedoutputsurface.cons] {\tcode{basic_unmanaged_output_surface} constructor}

\indexlibrary{\idxcode{basic_unmanaged_output_surface}!constructor}%
\begin{itemdecl}
basic_unmanaged_output_surface(data_type&& data) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
<TODO>
\end{itemdescr}

\rSec1 [\iotwod.unmanagedoutputsurface.observers] {\tcode{basic_unmanaged_output_surface} observers}

\indexlibrarymember{has_draw_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
bool has_draw_callback() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{has_size_change_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
bool has_size_change_callback() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{has_user_scaling_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
bool has_user_scaling_callback() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{format}{basic_unmanaged_output_surface}%
\begin{itemdecl}
io2d::format format() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
basic_display_point<graphics_math_type> dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{max_dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
basic_display_point<graphics_math_type> max_dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{display_dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
basic_display_point<graphics_math_type> display_dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{max_display_dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
basic_display_point<graphics_math_type> max_display_dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{scaling}{basic_unmanaged_output_surface}%
\begin{itemdecl}
io2d::scaling scaling() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{letterbox_brush}{basic_unmanaged_output_surface}%
\begin{itemdecl}
optional<basic_brush<GraphicsSurfaces>> letterbox_brush() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{letterbox_brush_props}{basic_unmanaged_output_surface}%
\begin{itemdecl}
optional<basic_brush_props<GraphicsSurfaces>> letterbox_brush_props() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\indexlibrarymember{auto}{basic_unmanaged_output_surface}%
\begin{itemdecl}
bool auto_clear() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
<TODO>
\end{itemdescr}

\rSec1 [\iotwod.unmanagedoutputsurface.mofifiers] {\tcode{basic_unmanaged_output_surface} modifiers}

\indexlibrarymember{clear}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void clear();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{flush}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the surface's \underlyingsurface, this function does nothing.

\pnum
If the implementation does provide a native handle to the surface's \underlyingsurface, then the implementation performs every action necessary to ensure that all operations on the surface that produce observable effects occur.

\pnum
The implementation performs any other actions necessary to ensure that the surface will be usable again after a call to \tcode{basic_unmanaged_output_surface::mark_dirty}.

\pnum
Once a call to \tcode{basic_unmanaged_output_surface::flush} is made, \tcode{basic_unmanaged_output_surface::mark_dirty} shall be called before any other member function of the surface is called or the surface is used as an argument to any other function.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists to allow the user to take control of the underlying surface using an implementation-provided native handle without introducing a race condition. The implementation's responsibility is to ensure that the user can safely use the underlying surface.

\pnum
\errors
The potential errors are \impldefplain{basic_unmanaged_output_surface::flush errors}.

\pnum
Implementations should avoid producing errors here.

\pnum
If the implementation does not provide a native handle to the \tcode{basic_unmanaged_output_surface} object's \underlyingsurface, this function shall not produce any errors.

\pnum
\begin{note}
There are several purposes for \tcode{basic_unmanaged_output_surface::flush} and \tcode{basic_unmanaged_output_surface::mark_dirty}.

\pnum
One is to allow implementation wide latitude in how they implement the rendering and composing operations (\ref{\iotwod.surface.rendering}), such as batching calls and then sending them to the \underlyingrendandpresenttechs at appropriate times.

\pnum
Another is to give implementations the chance during the call to \tcode{basic_unmanaged_output_surface::flush} to save any internal state that might be modified by the user and then restore it during the call to \tcode{basic_unmanaged_output_surface::mark_dirty}.

\pnum
Other uses of this pair of calls are also possible.
\end{note}
\end{itemdescr}

\indexlibrarymember{mark_dirty}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const basic_bounding_box<graphics_math_type>& extents);
void mark_dirty(const basic_bounding_box<graphics_math_type>& extents, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{basic_unmanaged_output_surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{basic_unmanaged_output_surface} object's \underlyingsurface, then:
\begin{itemize}
\item If called without a \tcode{basic_bounding_box} argument, informs the implementation that external changes using a native handle were potentially made to the entire \underlyingsurface.
\item If called with a \tcode{basic_bounding_box} argument, informs the implementation that external changes using a native handle were potentially made to the \underlyingsurface within the bounds specified by the \term{bounding rectangle} \tcode{basic_bounding_box\{ round(extents.x()), round (extents.y()), round(extents.width()), round(extents.height())\}}. No part of the bounding rectangle shall be outside of the bounds of the \underlyingsurface; no diagnostic is required.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
After external changes are made to this \tcode{basic_unmanaged_output_surface} object's \underlyingsurface using a native pointer, this function shall be called before using this \tcode{basic_unmanaged_output_surface} object; no diagnostic is required.

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{basic_unmanaged_output_surface!mark_dirty}.

\pnum
If the implementation does not provide a native handle to the \tcode{basic_unmanaged_output_surface} object's \underlyingsurface, this function shall not produce any errors.
\end{itemdescr}

\indexlibrarymember{paint}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void paint(const basic_brush<GraphicsSurfaces>& b,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the painting rendering and composing operation as specified by \ref{\iotwod.surface.painting}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{basic_unmanaged_output_surface!paint}.
\end{itemdescr}

\indexlibrarymember{stroke}{basic_unmanaged_output_surface}%
\begin{itemdecl}
template <class Allocator>
void stroke(const basic_brush<GraphicsSurfaces>& b,
  const basic_path_builder<GraphicsSurfaces, Allocator>& pb,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_stroke_props<GraphicsSurfaces>>& sp = nullopt,
  const optional<basic_dashes<GraphicsSurfaces>>& d = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
void stroke(const basic_brush<GraphicsSurfaces>& b,
  const basic_interpreted_path<GraphicsSurfaces>& ip,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_stroke_props<GraphicsSurfaces>>& sp = nullopt,
  const optional<basic_dashes<GraphicsSurfaces>>& d = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the stroking rendering and composing operation as specified by \ref{\iotwod.surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{basic_unmanaged_output_surface!stroke}.
\end{itemdescr}

\indexlibrarymember{fill}{basic_unmanaged_output_surface}%
\begin{itemdecl}
template <class Allocator>
void fill(const basic_brush<GraphicsSurfaces>& b,
  const basic_path_builder<GraphicsSurfaces, Allocator>& pb,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
void fill(const basic_brush<GraphicsSurfaces>& b,
  const basic_interpreted_path<GraphicsSurfaces>& ip,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the filling rendering and composing operation as specified by \ref{\iotwod.surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{basic_unmanaged_output_surface!fill}.
\end{itemdescr}

\indexlibrarymember{mask}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void mask(const basic_brush<GraphicsSurfaces>& b,
  const basic_brush<GraphicsSurfaces>& mb,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt,
  const optional<basic_mask_props<GraphicsSurfaces>>& mp = nullopt,
  const optional<basic_render_props<GraphicsSurfaces>>& rp = nullopt,
  const optional<basic_clip_props<GraphicsSurfaces>>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the masking rendering and composing operation as specified by \ref{\iotwod.surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors

The errors, if any, produced by this function are \impldefplain{basic_unmanaged_output_surface!mask}.
\end{itemdescr}

\indexlibrarymember{draw_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void draw_callback(const function<void(basic_unmanaged_output_surface& sfc)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{size_change_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void size_change_callback(const function<void(basic_unmanaged_output_surface& sfc)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void dimensions(basic_display_point<graphics_math_type> dp);
void dimensions(basic_display_point<graphics_math_type> dp, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{display_dimensions}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void display_dimensions(basic_display_point<graphics_math_type> dp);
void display_dimensions(basic_display_point<graphics_math_type> dp, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{scaling}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void scaling(io2d::scaling scl) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{user_scaling_callback}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void user_scaling_callback(const
  function<basic_bounding_box<graphics_math_type>(const
  basic_unmanaged_output_surface&, bool&)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{letterbox_brush}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void letterbox_brush(const optional<basic_brush<GraphicsSurfaces>>& b,
  const optional<basic_brush_props<GraphicsSurfaces>>& bp = nullopt) noexcept;
void letterbox_brush_props(const optional<basic_brush_props<GraphicsSurfaces>>& bp) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{auto_clear}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void auto_clear(bool val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}

\indexlibrarymember{redraw_required}{basic_unmanaged_output_surface}%
\begin{itemdecl}
void redraw_required(bool val = true) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
<TODO>
\end{itemdescr}