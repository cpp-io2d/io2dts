%!TEX root = io2d.tex
\rSec0 [\iotwod.standalone] {Standalone functions}

\rSec1 [\iotwod.standalone.synopsis] {Standalone functions synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  int format_stride_for_width(format format, int width) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat,
    scaling scl = scaling::letterbox,
    refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, error_code& ec,
    scaling scl = scaling::letterbox,
    refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f) noexcept;
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, scaling scl = scaling::letterbox,
    refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f);
  display_surface make_display_surface(int preferredWidth,
    int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
    int preferredDisplayHeight, ::std::error_code& ec,
    scaling scl = scaling::letterbox,
    refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f) noexcept;
  image_surface make_image_surface(format format, int width, int height);
  image_surface make_image_surface(format format, int width, int height, 
    error_code& ec) noexcept;
  image_surface copy_image_surface(image_surface& sfc) noexcept;
  float angle_for_point(point_2d ctr, point_2d pt) noexcept;
  point_2d point_for_angle(float ang, float rad = 1.0f) noexcept;
  point_2d point_for_angle(float ang, point_2d rad) noexcept;
  point_2d arc_start(point_2d ctr, float sang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
  point_2d arc_center(point_2d cpt, float sang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
  point_2d arc_end(point_2d cpt, float eang, point_2d rad, 
    const matrix_2d& m = matrix_2d{}) noexcept;
}
\end{codeblock}

\rSec1 [\iotwod.standalone.formatstrideforwidth] {\tcode{format_stride_for_width}}

\indexlibrary{\idxcode{format_stride_for_width}}%
\begin{itemdecl}
int format_stride_for_width(format fmt, int width) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The size in bytes of a row of pixels with a visual data format of \tcode{fmt} that is \tcode{width} pixels wide. This value may be larger than the value obtained by multiplying the number of bytes specified by the \tcode{format} enumerator specified by \tcode{fmt} by the number of pixels specified by \tcode{width}.

\pnum
If \tcode{fmt == format::invalid}, this function shall return \tcode{0}.
\end{itemdescr}

\rSec1 [\iotwod.standalone.makedisplaysurface] {\tcode{make_display_surface}}

\indexlibrary{\idxcode{make_display_surface}}%
\begin{itemdecl}
display_surface make_display_surface(int preferredWidth,
  int preferredHeight, format preferredFormat,
  scaling scl = scaling::letterbox,
  refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f);
display_surface make_display_surface(int preferredWidth,
  int preferredHeight, format preferredFormat, error_code& ec,
  scaling scl = scaling::letterbox,
  refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f) 
  noexcept;
display_surface make_display_surface(int preferredWidth,
  int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
  int preferredDisplayHeight, scaling scl = scaling::letterbox,
  refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f);
display_surface make_display_surface(int preferredWidth,
  int preferredHeight, format preferredFormat, int preferredDisplayWidth, 
  int preferredDisplayHeight, ::std::error_code& ec,
  scaling scl = scaling::letterbox,
  refresh_rate rr = refresh_rate::as_fast_as_possible, float fps = 30.0f) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Returns a \tcode{display_surface} object that is exactly the same as-if the equivalent \tcode{display_surface} constructor was called with the same arguments.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are the same as the errors for the equivalent \tcode{display_surface} constructor (\ref{\iotwod.displaysurface.cons}).
\end{itemdescr}

\rSec1 [\iotwod.standalone.makeimagesurface] {\tcode{make_image_surface}}

\indexlibrary{\idxcode{make_image_surface}}%
\begin{itemdecl}
image_surface make_image_surface(int width, int height,
  format fmt = format::argb32);
image_surface make_image_surface(int width, int height,
  error_code& ec, format fmt = format::argb32) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Returns an \tcode{image_surface} object that is exactly the same as-if the \tcode{image_surface} constructor was called with the same arguments.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are the same as the errors for the equivalent \tcode{display_surface} constructor (\ref{\iotwod.imagesurface.cons}).
\end{itemdescr}

\rSec1 [\iotwod.standalone.copyimagesurface] {\tcode{copy_image_surface}}

\indexlibrary{\idxcode{copy_image_surface}}%
\begin{itemdecl}
image_surface copy_image_surface(image_surface& sfc) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
An exact copy of \tcode{sfc}.

\pnum
\begin{note}
The \tcode{image_surface} class intentionally does not provide copy semantics because with many modern graphics technologies, making such a copy is almost always a very time consuming operation. This function allows users to make a copy of an \tcode{image_surface} object while preserving the move-only semantics of the \tcode{image_surface} class, thus preventing unintentional copying.
\end{note}
\end{itemdescr}

\rSec1 [\iotwod.standalone.angleforpoint] {\tcode{angle_for_point}}

\indexlibrary{\idxcode{angle_for_point}}%
\begin{itemdecl}
float angle_for_point(point_2d ctr, point_2d pt,
  point_2d scl = point_2d{ 1.0f, 1.0f }) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The angle, in radians, of \tcode{pt} as a point on a circle with a center at \tcode{ctr}. If the angle is less that \tcode{pi<float> / 180000.0f}, returns \tcode{0.0f}.
\end{itemdescr}

\rSec1 [\iotwod.standalone.pointforangle] {\tcode{point_for_angle}}

\indexlibrary{\idxcode{point_for_angle}}%
\begin{itemdecl}
point_2d point_for_angle(float ang, float rad = 1.0f) noexcept;
point_2d point_for_angle(float ang, point_2d rad) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
If it is a \tcode{float}, \tcode{rad} is greater than \tcode{0.0f}. If it is a \tcode{point_2d}, \tcode{rad.x} or \tcode{rad.y} is greater than \tcode{0.0f} and neither is less than \tcode{0.0f}.

\pnum
\returns
The result of rotating the point \tcode{point_2d\{ 1.0f, 0.0f \}}, around an origin of \tcode{point_2d\{ 0.0f, 0.0f \}} by \tcode{ang} radians, with a positive value of \tcode{ang} meaning counterclockwise rotation and a negative value meaning clockwise rotation, with the result being multiplied by \tcode{rad}.
\end{itemdescr}

\rSec1 [\iotwod.standalone.arcstart] {\tcode{arc_start}}

\indexlibrary{\idxcode{arc_start}}%
\begin{itemdecl}
point_2d arc_start(point_2d ctr, float sang, point_2d rad, 
  const matrix_2d& m = matrix_2d{}) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rad.x} and \tcode{rad.y} are both greater than \tcode{0.0f}.

\pnum
\returns
As-if:
\begin{codeblock}
auto lmtx = m;
lmtx.m20 = 0.0f; lmtx.m21 = 0.0f;
auto pt = point_for_angle(sang, rad);
return ctr + pt * lmtx;
\end{codeblock}

\pnum
\begin{note}
Among other things, this function is useful for determining the point at which a new figure should begin if the first item in the figure is an arc and the user wishes to clearly define its center.
\end{note}
\end{itemdescr}

\rSec1 [\iotwod.standalone.arccenter] {\tcode{arc_center}}

\indexlibrary{\idxcode{arc_center}}%
\begin{itemdecl}
point_2d arc_center(point_2d cpt, float sang, point_2d rad, 
  const matrix_2d& m = matrix_2d{}) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rad.x} and \tcode{rad.y} are both greater than \tcode{0.0f}.

\pnum
\returns
As-if:
\begin{codeblock}
auto lmtx = m;
lmtx.m20 = 0.0f; lmtx.m21 = 0.0f;
auto centerOffset = point_for_angle(two_pi<float> - sang, rad);
centerOffset.y = -centerOffset.y;
return cpt - centerOffset * lmtx;
\end{codeblock}
\end{itemdescr}

\rSec1 [\iotwod.standalone.arcend] {\tcode{arc_end}}

\indexlibrary{\idxcode{arc_end}}%
\begin{itemdecl}
point_2d arc_end(point_2d cpt, float eang, point_2d rad, 
  const matrix_2d& m = matrix_2d{}) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rad.x} and \tcode{rad.y} are both greater than \tcode{0.0f}.

\pnum
\returns
As-if:
\begin{codeblock}
auto lmtx = m;
auto tfrm = matrix_2d::init_rotate(eang);
lmtx.m20 = 0.0f; lmtx.m21 = 0.0f;
auto pt = (rad * tfrm);
pt.y = -pt.y;
return cpt + pt * lmtx;
\end{codeblock}
\end{itemdescr}
