%!TEX root = io2d.tex
\rSec0 [linearbrushfact] {Class \tcode{linear_brush_factory}}

\rSec1 [linearbrushfact.synopsis] {\tcode{linear_brush_factory} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class linear_brush_factory {
  public:
    // \ref{linearbrushfact.cons}, construct/copy/move/destroy:
    linear_brush_factory() noexcept;
    linear_brush_factory(const linear_brush_factory&);
    linear_brush_factory& operator=(const linear_brush_factory&);
    linear_brush_factory(linear_brush_factory&& other) noexcept;
    linear_brush_factory& operator=(linear_brush_factory&& other) noexcept;
    linear_brush_factory(const vector_2d& begin, const vector_2d& end) noexcept;

    // \ref{linearbrushfact.modifiers}, modifiers:
    void add_color_stop(double offset, const rgba_color& color);
    void add_color_stop(double offset, const rgba_color& color, 
      error_code& ec) noexcept;
    void color_stop(unsigned int index, double offset,
      const rgba_color& color);
    void color_stop(unsigned int index, double offset,
      const rgba_color& color, error_code& ec) noexcept;
    void begin_point(const vector_2d& value) noexcept;
    void end_point(const vector_2d& value) noexcept;

    // \ref{linearbrushfact.observers}, observers:
    int color_stop_count() const noexcept;
    tuple<double, rgba_color> color_stop(unsigned int index) const;
    tuple<double, rgba_color> color_stop(unsigned int index,
      error_code& ec) const noexcept;
    vector_2d begin_point() const noexcept;
    vector_2d end_point() const noexcept;

  private:
    vector_2d _Begin_point;                             // \expos
    vector_2d _End_point;                               // \expos
    vector<tuple<double, rgba_color>> _Color_stops; // \expos
  };
} } } }
\end{codeblock}

\rSec1 [linearbrushfact.intro] {\tcode{linear_brush_factory} Description}

\pnum
\indexlibrary{\idxcode{linear_brush_factory}}
The class \tcode{linear_brush_factory} describes a mutable factory for creating \tcode{brush} objects with a linear gradient describing its color and alpha data.

\pnum
For more information about gradients, including linear gradients, see \ref{gradients}.

\rSec1 [linearbrushfact.cons] {\tcode{linear_brush_factory} constructors and assignment operators}

\indexlibrary{\idxcode{linear_brush_factory}!constructor}
\begin{itemdecl}
    linear_brush_factory() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{linear_brush_factory}.
	
	\pnum
	\postconditions
	\tcode{_Begin_point == vector_2d\{ \}}.

	\pnum
	\tcode{_End_point == vector_2d\{ \}}.
	
	\pnum
	\tcode{_Color_stops.empty() == true}.
	
\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!constructor}
\begin{itemdecl}
    linear_brush_factory(const vector_2d& begin, const vector_2d& end) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{linear_brush_factory}.
	
	\pnum
	\postconditions
	\tcode{_Begin_point == begin}.
	
	\pnum
	\tcode{_End_point == end}.
	
	\pnum
	\tcode{_Color_stops.empty() == true}.
	
\end{itemdescr}

\rSec1 [linearbrushfact.modifiers] {\tcode{linear_brush_factory} modifiers}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{add_color_stop}}
\indexlibrary{\idxcode{add_color_stop}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    void add_color_stop(double offset, const rgba_color& color);
    void add_color_stop(double offset, const rgba_color& color, 
      error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a color stop with an offset value of \tcode{offset} and a color value of \tcode{color}.
	
	\pnum
	\postconditions
	\tcode{_Color_stops.push_back(make_tuple(offset, color))}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the color stop fails.
	
\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{color_stop}}
\indexlibrary{\idxcode{color_stop}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    void color_stop(unsigned int index, double offset,
      const rgba_color& color);
    void color_stop(unsigned int index, double offset,
      const rgba_color& color, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	\tcode{_Color_stops.size() > index}.
	
	\pnum
	\effects
	Replaces the color stop at index \tcode{index} with a color stop with an offset of \tcode{offset} and a color of \tcode{color}.

	\pnum
	\postconditions
	\tcode{_Color_stops.at(index) == make_tuple(offset, color)}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{io2d_error::invalid_index} if \tcode{index} violated the preconditions.
\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{begin_point}}
\indexlibrary{\idxcode{begin_point}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    void begin_point(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the begin point to \tcode{value}.

	\pnum
	\postconditions
	\tcode{_Begin_point == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{end_point}}
\indexlibrary{\idxcode{end_point}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    void end_point(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the end point to \tcode{value}.
	
	\pnum
	\postconditions
	\tcode{_End_point == value}.
	
\end{itemdescr}

\rSec1 [linearbrushfact.observers] {\tcode{color_stop_count} observers}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{color_stop_count}}
\indexlibrary{\idxcode{color_stop_count}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    unsigned int color_stop_count() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{static_cast<unsigned int>(_Color_stops.size())}.

\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{color_stop}}
\indexlibrary{\idxcode{color_stop}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    tuple<double, rgba_color> color_stop(unsigned int index) const;
    tuple<double, rgba_color> color_stop(unsigned int index,
      error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	\tcode{_Color_stops.size() > index}.
	
	\pnum
	\returns
	\tcode{_Color_stops.at(index)}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{io2d_error::invalid_index} if \tcode{index} violated the preconditions.

\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{begin_point}}
\indexlibrary{\idxcode{begin_point}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    vector_2d begin_point() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Begin_point}.

\end{itemdescr}

\indexlibrary{\idxcode{linear_brush_factory}!\idxcode{end_point}}
\indexlibrary{\idxcode{end_point}!\idxcode{linear_brush_factory}}
\begin{itemdecl}
    vector_2d end_point() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_End_point}.

\end{itemdescr}
