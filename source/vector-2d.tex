%!TEX root = io2d.tex
\rSec0 [\iotwod.\vectortwod] {Class \tcode{vector_2d}}

\rSec1 [\iotwod.\vectortwod.intro] {\tcode{vector_2d} Description}

\indexlibrary{\idxcode{vector_2d}}%
\pnum
The class \tcode{vector_2d} is used as both a point and as a two-dimensional Euclidian vector.

\pnum
It has an \term{x coordinate} of type \tcode{float} and a \term{y coordinate} of type \tcode{float}.

\rSec1 [\iotwod.\vectortwod.synopsis] {\tcode{vector_2d} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class vector_2d {
  public:
    // \ref{\iotwod.\vectortwod.cons}, constructors:
    constexpr vector_2d() noexcept;
    constexpr vector_2d(float x, float y) noexcept;

    // \ref{\iotwod.\vectortwod.modifiers}, modifiers:
    constexpr void x(float val) noexcept;
    constexpr void y(float val) noexcept;
    
    // \ref{\iotwod.\vectortwod.observers}, observers:
    constexpr float x() const noexcept;
    constexpr float y() const noexcept;
    constexpr float dot(const vector_2d& other) const noexcept;
    float magnitude() const noexcept;
    constexpr float magnitude_squared() const noexcept;
    float angular_direction(const vector_2d& to) const noexcept
    vector_2d to_unit() const noexcept;
    
    // \ref{\iotwod.\vectortwod.member.ops}, member operators:
    constexpr vector_2d& operator+=(const vector_2d& rhs) noexcept;
    constexpr vector_2d& operator-=(const vector_2d& rhs) noexcept;
    constexpr vector_2d& operator*=(float rhs) noexcept;
    constexpr vector_2d& operator*=(const vector_2d& rhs) noexcept;
    constexpr vector_2d& operator/=(float rhs) noexcept;
    constexpr vector_2d& operator/=(const vector_2d& rhs) noexcept;
  };
  
  // \ref{\iotwod.\vectortwod.ops}, non-member operators:
  constexpr bool operator==(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr bool operator!=(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator+(const vector_2d& lhs) noexcept;
  constexpr vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator-(const vector_2d& lhs) noexcept;
  constexpr vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator*(const vector_2d& lhs, float rhs) noexcept;
  constexpr vector_2d operator*(float lhs, const vector_2d& rhs) noexcept;
  constexpr vector_2d operator*(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator/(const vector_2d& lhs, float rhs) noexcept;
  constexpr vector_2d operator/(float lhs, const vector_2d& rhs) noexcept;
  constexpr vector_2d operator/(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
}
\end{codeblock}

\rSec1 [\iotwod.\vectortwod.cons] {\tcode{vector_2d} constructors}

\indexlibrary{\idxcode{vector_2d}!constructor}%
\begin{itemdecl}
constexpr vector_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{vector_2d\{ 0.0f, 0.0f \}}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!constructor}%
\begin{itemdecl}
constexpr vector_2d(float x, float y) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{vector_2d}.

\pnum
The x coordinate is \tcode{x}.

\pnum
The y coordinate is \tcode{y}.
\end{itemdescr}

\rSec1 [\iotwod.\vectortwod.modifiers]{\tcode{vector_2d} modifiers}

\indexlibrarymember{x}{vector_2d}%
\begin{itemdecl}
constexpr void x(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The x coordinate is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{y}{vector_2d}%
\begin{itemdecl}
constexpr void y(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The y coordinate is \tcode{val}.
\end{itemdescr}

\rSec1 [\iotwod.\vectortwod.observers]{\tcode{vector_2d} observers}

\indexlibrarymember{x}{vector_2d}%
\begin{itemdecl}
constexpr float x() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The x coordinate.
\end{itemdescr}

\indexlibrarymember{y}{vector_2d}%
\begin{itemdecl}
constexpr float y() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The y coordinate.
\end{itemdescr}

\indexlibrarymember{dot}{vector_2d}%
\begin{itemdecl}
constexpr float dot(const vector_2d& other) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{x() * other.x() + y() * other.y()}.
\end{itemdescr}

\indexlibrarymember{magnitude}{vector_2d}%
\begin{itemdecl}
float magnitude() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{sqrt(dot(*this));}
\end{itemdescr}

\indexlibrarymember{magnitude_squared}{vector_2d}%
\begin{itemdecl}
constexpr float magnitude_squared() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{dot(*this);}
\end{itemdescr}

\indexlibrarymember{angular_direction}{vector_2d}%
\begin{itemdecl}
float angular_direction() const noexcept
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{atan2(y(), x())} if it is greater than or equal to \tcode{0.0f}.

\pnum
Otherwise, \tcode{atan2(y(), x()) + two_pi<float>}. 

\pnum
\begin{note}
The purpose of adding \tcode{two_pi<float>} if the result is negative is to produce values in the range \range{0.0f}{two_pi<float>}.
\end{note}
\end{itemdescr}

\indexlibrarymember{to_unit}{vector_2d}%
\begin{itemdecl}
vector_2d to_unit() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ x() / magnitude(), y() / magnitude()\}}.
\end{itemdescr}

\rSec1 [\iotwod.\vectortwod.member.ops] {\tcode{vector_2d} member operators}

\indexlibrarymember{operator+=}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d& operator+=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\tcode{*this = *this + rhs}.
	
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d& operator-=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this - rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*=}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d& operator*=(float rhs) noexcept;
constexpr vector_2d& operator*=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator/=}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d& operator/=(float rhs) noexcept;
constexpr vector_2d& operator/=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this / rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\vectortwod.ops] {\tcode{vector_2d} non-member operators}

\indexlibrarymember{operator==}{vector_2d}%
\begin{itemdecl}
constexpr bool operator==(const vector_2d& lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{lhs.x() == rhs.x() \&\& lhs.y() == rhs.y()}.
\end{itemdescr}

\indexlibrarymember{operator!=}{vector_2d}%
\begin{itemdecl}
constexpr bool operator!=(const vector_2d& lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrarymember{operator+}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator+(const vector_2d& lhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{lhs}.
\end{itemdescr}

\indexlibrarymember{operator+}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() + rhs.x(), lhs.y() + rhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator-}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator-(const vector_2d& lhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ -lhs.x(), -lhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator-}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() - rhs.x(), lhs.y() - rhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator*(const vector_2d& lhs, const vector_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() * rhs.x(), lhs.y() * rhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator*(const vector_2d& lhs, float rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() * rhs, lhs.y() * rhs \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator*(float lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs * rhs.x(), lhs * rhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator/(const vector_2d& lhs, const vector_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs.x()} is not \tcode{0.0f} and \tcode{rhs.y()} is not \tcode{0.0f}.

\pnum
\returns
\tcode{vector_2d\{ lhs.x() / rhs.x(), lhs.y() / rhs.y() \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator/(const vector_2d& lhs, float rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs} is not \tcode{0.0f}.

\pnum
\returns
\tcode{vector_2d\{ lhs.x() / rhs, lhs.y() / rhs \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{vector_2d}%
\begin{itemdecl}
constexpr vector_2d operator/(float lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs.x()} is not \tcode{0.0f} and \tcode{rhs.y()} is not \tcode{0.0f}.

\pnum
\returns
\tcode{vector_2d\{ lhs / rhs.x(), lhs / rhs.y() \}}.
\end{itemdescr}
