%!TEX root = io2d.tex
\rSec0 [\iotwod.\pointtwod] {Class \tcode{point_2d}}

\rSec1 [\iotwod.\pointtwod.intro] {\tcode{point_2d} description}

\indexlibrary{\idxcode{point_2d}}%
\pnum
The class \tcode{point_2d} is used as both a point and as a two-dimensional Euclidian vector.

\pnum
It has an \term{x coordinate} of type \tcode{float} and a \term{y coordinate} of type \tcode{float}.

\rSec1 [\iotwod.\pointtwod.synopsis] {\tcode{point_2d} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class point_2d {
  public:
    // \ref{\iotwod.\pointtwod.cons}, constructors:
    constexpr point_2d() noexcept;
    constexpr point_2d(float x, float y) noexcept;

    // member data:
    float x;
    float y;
    
    // \ref{\iotwod.\pointtwod.observers}, observers:
    constexpr float dot(const point_2d& other) const noexcept;
    float magnitude() const noexcept;
    constexpr float magnitude_squared() const noexcept;
    float angular_direction(const point_2d& to) const noexcept;
    point_2d to_unit() const noexcept;
    constexpr static point_2d zero() const noexcept;
    
    // \ref{\iotwod.\pointtwod.member.ops}, member operators:
    constexpr point_2d& operator+=(const point_2d& rhs) noexcept;
    constexpr point_2d& operator-=(const point_2d& rhs) noexcept;
    constexpr point_2d& operator*=(float rhs) noexcept;
    constexpr point_2d& operator*=(const point_2d& rhs) noexcept;
    constexpr point_2d& operator/=(float rhs) noexcept;
    constexpr point_2d& operator/=(const point_2d& rhs) noexcept;
  };
  
  // \ref{\iotwod.\pointtwod.ops}, non-member operators:
  constexpr bool operator==(const point_2d& lhs, const point_2d& rhs)
    noexcept;
  constexpr bool operator!=(const point_2d& lhs, const point_2d& rhs)
    noexcept;
  constexpr point_2d operator+(const point_2d& val) noexcept;
  constexpr point_2d operator+(const point_2d& lhs, const point_2d& rhs)
    noexcept;
  constexpr point_2d operator-(const point_2d& val) noexcept;
  constexpr point_2d operator-(const point_2d& lhs, const point_2d& rhs)
    noexcept;
  constexpr point_2d operator*(const point_2d& lhs, float rhs) noexcept;
  constexpr point_2d operator*(float lhs, const point_2d& rhs) noexcept;
  constexpr point_2d operator*(const point_2d& lhs, const point_2d& rhs)
    noexcept;
  constexpr point_2d operator/(const point_2d& lhs, float rhs) noexcept;
  constexpr point_2d operator/(float lhs, const point_2d& rhs) noexcept;
  constexpr point_2d operator/(const point_2d& lhs, const point_2d& rhs)
    noexcept;
}
\end{codeblock}

\rSec1 [\iotwod.\pointtwod.cons] {\tcode{point_2d} constructors}

\indexlibrary{\idxcode{point_2d}!constructor}%
\begin{itemdecl}
constexpr point_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to \tcode{point_2d\{ 0.0f, 0.0f \}}.
\end{itemdescr}

\indexlibrary{\idxcode{point_2d}!constructor}%
\begin{itemdecl}
constexpr point_2d(float x, float y) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{point_2d}.

\pnum
The x coordinate is \tcode{x}.

\pnum
The y coordinate is \tcode{y}.
\end{itemdescr}

\rSec1 [\iotwod.\pointtwod.observers]{\tcode{point_2d} observers}

\indexlibrarymember{dot}{point_2d}%
\begin{itemdecl}
constexpr float dot(const point_2d& other) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{x * other.x + y * other.y}.
\end{itemdescr}

\indexlibrarymember{magnitude}{point_2d}%
\begin{itemdecl}
float magnitude() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{sqrt(dot(*this));}
\end{itemdescr}

\indexlibrarymember{magnitude_squared}{point_2d}%
\begin{itemdecl}
constexpr float magnitude_squared() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{dot(*this);}
\end{itemdescr}

\indexlibrarymember{angular_direction}{point_2d}%
\begin{itemdecl}
float angular_direction() const noexcept
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{atan2(y, x)} if it is greater than or equal to \tcode{0.0f}.

\pnum
Otherwise, \tcode{atan2(y, x) + two_pi<float>}. 

\pnum
\begin{note}
The purpose of adding \tcode{two_pi<float>} if the result is negative is to produce values in the range \range{0.0f}{two_pi<float>}.
\end{note}
\end{itemdescr}

\indexlibrarymember{to_unit}{point_2d}%
\begin{itemdecl}
point_2d to_unit() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ x / magnitude(), y / magnitude()\}}.
\end{itemdescr}

\indexlibrarymember{zero}{point_2d}%
\begin{itemdecl}
constexpr static point_2d zero() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ 0.0f, 0.0f \}}.
\end{itemdescr}

\rSec1 [\iotwod.\pointtwod.member.ops] {\tcode{point_2d} member operators}

\indexlibrarymember{operator+=}{point_2d}%
\begin{itemdecl}
constexpr point_2d& operator+=(const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\tcode{*this = *this + rhs}.
	
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator-=}{point_2d}%
\begin{itemdecl}
constexpr point_2d& operator-=(const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this - rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator*=}{point_2d}%
\begin{itemdecl}
constexpr point_2d& operator*=(float rhs) noexcept;
constexpr point_2d& operator*=(const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{operator/=}{point_2d}%
\begin{itemdecl}
constexpr point_2d& operator/=(float rhs) noexcept;
constexpr point_2d& operator/=(const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this / rhs;}.

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\pointtwod.ops] {\tcode{point_2d} non-member operators}

\indexlibrarymember{operator==}{point_2d}%
\begin{itemdecl}
constexpr bool operator==(const point_2d& lhs, const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{lhs.x == rhs.x \&\& lhs.y == rhs.y}.
\end{itemdescr}

\indexlibrarymember{operator!=}{point_2d}%
\begin{itemdecl}
constexpr bool operator!=(const point_2d& lhs, const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrarymember{operator+}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator+(const point_2d& val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{val}.
\end{itemdescr}

\indexlibrarymember{operator+}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator+(const point_2d& lhs, const point_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ lhs.x + rhs.x, lhs.y + rhs.y \}}.
\end{itemdescr}

\indexlibrarymember{operator-}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator-(const point_2d& val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ -val.x, -val.y \}}.
\end{itemdescr}

\indexlibrarymember{operator-}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator-(const point_2d& lhs, const point_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ lhs.x - rhs.x, lhs.y - rhs.y \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator*(const point_2d& lhs, const point_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ lhs.x * rhs.x, lhs.y * rhs.y \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator*(const point_2d& lhs, float rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ lhs.x * rhs, lhs.y * rhs \}}.
\end{itemdescr}

\indexlibrarymember{operator*}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator*(float lhs, const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d\{ lhs * rhs.x, lhs * rhs.y \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator/(const point_2d& lhs, const point_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs.x} is not \tcode{0.0f} and \tcode{rhs.y} is not \tcode{0.0f}.

\pnum
\returns
\tcode{point_2d\{ lhs.x / rhs.x, lhs.y / rhs.y \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator/(const point_2d& lhs, float rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs} is not \tcode{0.0f}.

\pnum
\returns
\tcode{point_2d\{ lhs.x / rhs, lhs.y / rhs \}}.
\end{itemdescr}

\indexlibrarymember{operator/}{point_2d}%
\begin{itemdecl}
constexpr point_2d operator/(float lhs, const point_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{rhs.x} is not \tcode{0.0f} and \tcode{rhs.y} is not \tcode{0.0f}.

\pnum
\returns
\tcode{point_2d\{ lhs / rhs.x, lhs / rhs.y \}}.
\end{itemdescr}
