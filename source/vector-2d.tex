%!TEX root = io2d.tex
\rSec0 [\vectortwod] {Class \tcode{vector_2d}}

\rSec1 [\vectortwod.intro] {\tcode{vector_2d} Description}

\pnum
\indexlibrary{\idxcode{vector_2d}}
The class \tcode{vector_2d} is used as both a point and as a two-dimensional Euclidian vector.

\pnum
It has an X coordinate of type \tcode{double} and a Y coordinate of type \tcode{double}.

\rSec1 [\vectortwod.synopsis] {\tcode{vector_2d} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class vector_2d {
  public:
    // \ref{\vectortwod.cons}, construct/copy/move/destroy:
    constexpr vector_2d() noexcept;
    constexpr vector_2d(double x, double y) noexcept;
    constexpr vector_2d(const vector_2d&) noexcept = default;
    constexpr vector_2d& operator=(const vector_2d&) noexcept = default;
    vector_2d(vector_2d&&) noexcept = default;
    vector_2d& operator=(vector_2d&&) noexcept = default;

    // \ref{\vectortwod.modifiers}, modifiers:
    void x(double value) noexcept;
    void y(double value) noexcept;
    
    // \ref{\vectortwod.observers}, observers:
    constexpr double x() const noexcept;
    constexpr double y() const noexcept;
    double magnitude() const noexcept;
    constexpr double magnitude_squared() const noexcept;
    constexpr double dot(const vector_2d& other) const noexcept;
    double angular_direction(const vector_2d& to) const noexcept
    vector_2d to_unit() const noexcept;
    
    // \ref{\vectortwod.member.ops}, member operators:
    vector_2d& operator+=(const vector_2d& rhs) noexcept;
    vector_2d& operator-=(const vector_2d& rhs) noexcept;
    vector_2d& operator*=(double rhs) noexcept;
  };
  
  // \ref{\vectortwod.ops}, non-member operators:
  constexpr bool operator==(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr bool operator!=(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator+(const vector_2d& lhs) noexcept;
  constexpr vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator-(const vector_2d& lhs) noexcept;
  constexpr vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs)
    noexcept;
  constexpr vector_2d operator*(const vector_2d& lhs, double rhs) noexcept;
  constexpr vector_2d operator*(double lhs, const vector_2d& rhs) noexcept;
} } } }
\end{codeblock}

\rSec1 [\vectortwod.cons] {\tcode{vector_2d} constructors and assignment operators}

\indexlibrary{\idxcode{vector_2d}!constructor}
\begin{itemdecl}
constexpr vector_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{vector_2d}.

\pnum
The X coordinate shall be set to the value \tcode{0.0}.

\pnum
The Y coordinate shall be set to the value \tcode{0.0}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!constructor}
\begin{itemdecl}
constexpr vector_2d(double x, double y) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{vector_2d}.

\pnum
The X coordinate shall be set to the value of \tcode{x}.

\pnum
The Y coordinate shall be set to the value of \tcode{y}.
\end{itemdescr}

\rSec1 [\vectortwod.modifiers]{\tcode{vector_2d} modifiers}

\indexlibrary{\idxcode{vector_2d}!\idxcode{x}}
\indexlibrary{\idxcode{x}!\idxcode{vector_2d}}
\begin{itemdecl}
void x(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The X coordinate shall be set to the value of \tcode{x}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{y}}
\indexlibrary{\idxcode{y}!\idxcode{vector_2d}}
\begin{itemdecl}
void y(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The Y coordinate shall be set to the value of \tcode{y}.
\end{itemdescr}

\rSec1 [\vectortwod.observers]{\tcode{vector_2d} observers}

\indexlibrary{\idxcode{vector_2d}!\idxcode{x}}
\indexlibrary{\idxcode{x}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr double x() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of the X coordinate.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{y}}
\indexlibrary{\idxcode{y}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr double y() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of the Y coordinate.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{magnitude}}
\indexlibrary{\idxcode{magnitude}!\idxcode{vector_2d}}
\begin{itemdecl}
    double magnitude() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{sqrt(*this.x() * *this.x() + *this.y() * *this.y())}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{magnitude_squared}}
\indexlibrary{\idxcode{magnitude_squared}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr double magnitude_squared() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{*this.x() * *this.x() + *this.y() * *this.y()}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{dot}}
\indexlibrary{\idxcode{dot}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr double dot(const vector_2d& other) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{*this.x() * other.x() + *this.y() * other.y()}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{angular_direction}}
\indexlibrary{\idxcode{angular_direction}!\idxcode{vector_2d}}
\begin{itemdecl}
double angular_direction() const noexcept
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of \tcode{atan2(*this.y(), *this.x())} if it is greater than or equal to \tcode{0;0}.

\pnum
Otherwise, \tcode{atan2(*this.y(), *this.x()) + two_pi<double>}. 

\pnum
\realnotes
The purpose of adding $2\pi$ if the result is negative is to produce values in the range \range{0.0}{$2\pi$}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{to_unit}}
\indexlibrary{\idxcode{to_unit}!\idxcode{vector_2d}}
\begin{itemdecl}
vector_2d to_unit() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ *this.x() / magnitude(), *this.y() / magnitude()\}}.
\end{itemdescr}

\rSec1 [\vectortwod.member.ops] {\tcode{vector_2d} member operators}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator+=}}
\indexlibrary{\idxcode{operator+=}!\idxcode{vector_2d}}
\begin{itemdecl}
vector_2d& operator+=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\tcode{*this = *this + rhs}.
	
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator-=}}
\indexlibrary{\idxcode{operator-=}!\idxcode{vector_2d}}
\begin{itemdecl}
vector_2d& operator-=(const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\tcode{*this = *this - rhs}.
	
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator*=}}
\indexlibrary{\idxcode{operator*=}!\idxcode{vector_2d}}
\begin{itemdecl}
vector_2d& operator*=(double rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
\tcode{*this = *this * rhs}.
	
\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\vectortwod.ops] {\tcode{vector_2d} non-member operators}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator==}}
\indexlibrary{\idxcode{operator==}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr bool operator==(const vector_2d& lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{lhs.x() == rhs.x() \&\& lhs.y() == rhs.y()}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator!=}}
\indexlibrary{\idxcode{operator!=}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr bool operator!=(const vector_2d& lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{!(lhs == rhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator+}}
\indexlibrary{\idxcode{operator+}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator+(const vector_2d& lhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d(lhs)}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator+}}
\indexlibrary{\idxcode{operator+}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator+(const vector_2d& lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() + rhs.x(), lhs.y() + rhs.y() \}}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator-}}
\indexlibrary{\idxcode{operator-}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator-(const vector_2d& lhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ -lhs.x(), -lhs.y() \}}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator-}}
\indexlibrary{\idxcode{operator-}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator-(const vector_2d& lhs, const vector_2d& rhs) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() - rhs.x(), lhs.y() - rhs.y() \}}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator*}}
\indexlibrary{\idxcode{operator*}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator*(const vector_2d& lhs, double rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs.x() * rhs, lhs.y() * rhs \}}.
\end{itemdescr}

\indexlibrary{\idxcode{vector_2d}!\idxcode{operator*}}
\indexlibrary{\idxcode{operator*}!\idxcode{vector_2d}}
\begin{itemdecl}
constexpr vector_2d operator*(double lhs, const vector_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d\{ lhs * rhs.x(), lhs * rhs.y() \}}.
\end{itemdescr}
