%!TEX root = io2d.tex
\rSec0 [\iotwod.radialbrushfact] {Class \tcode{radial_brush_factory}}

\rSec1 [\iotwod.radialbrushfact.synopsis] {\tcode{radial_brush_factory} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class radial_brush_factory {
  public:
    // \ref{\iotwod.radialbrushfact.cons}, construct/copy/move/destroy:
    radial_brush_factory() noexcept;
    radial_brush_factory(const radial_brush_factory&);
    radial_brush_factory& operator=(const radial_brush_factory&);
    radial_brush_factory(radial_brush_factory&& other) noexcept;
    radial_brush_factory& operator=(radial_brush_factory&& other) noexcept;
    radial_brush_factory(const vector_2d& center0, double radius0,
      const vector_2d& center1, double radius1) noexcept;

    // \ref{\iotwod.radialbrushfact.modifiers}, modifiers:
    void add_color_stop(double offset, const rgba_color& color);
    void add_color_stop(double offset, const rgba_color& color,
      error_code& ec) noexcept;
    void color_stop(unsigned int index, double offset, const rgba_color& color);
    void color_stop(unsigned int index, double offset, const rgba_color& color,
      error_code& ec) noexcept;
    void radial_circles(const vector_2d& center0, double radius0,
      const vector_2d& center1, double radius1) noexcept;

    // \ref{\iotwod.radialbrushfact.observers}, observers:
    unsigned int color_stop_count() const noexcept;
    tuple<double, rgba_color> color_stop(unsigned int index) const;
    tuple<double, rgba_color> color_stop(unsigned int index,
      error_code& ec) const noexcept;
    tuple<vector_2d, double, vector_2d, double> radial_circles() const noexcept;

  private:
    vector_2d _Center0;                             // \expos
    double _Radius0;                                // \expos
    vector_2d _Center1;                             // \expos
    double _Radius1;                                // \expos
    vector<tuple<double, rgba_color>> _Color_stops; // \expos
  };
} } } }
\end{codeblock}

\rSec1 [\iotwod.radialbrushfact.intro] {\tcode{radial_brush_factory} Description}

\pnum
\indexlibrary{\idxcode{radial_brush_factory}}
The class \tcode{radial_brush_factory} describes a mutable factory for creating \tcode{brush} objects with a radial gradient describing its color and alpha data.

\pnum
For more information about gradients, including radial gradients, see \ref{\iotwod.gradients}.


***FIXME*** Need to obliterate the "start circle" and switch it to a focal point.
\pnum
\enterexample
\begin{codeblock}
auto rf = radial_brush_factory({ 100.0, 100.0}, 100.0, )
\end{codeblock}
\exitexample

\pnum
Color stops are assigned a sequentially incremented \tcode{unsigned int} index value in the order that they are added. The first color stop which is added is assigned the index value 0.

\pnum
Color stops which have been added can be replaced. A color stop which replaces another color stop assumes the index value of the color stop it replaced. Replacement does not constitute addition for purposes of assigning index values.
\enterexample
If three color stops are added and then the color stop at index 1 is replaced, the next color stop which is added will be assigned the index value 3.
\exitexample

\pnum
For any point on the line segment, its color value shall be determined according to the following rules:

\begin{itemize}
\item If there are less than two color stops or if all color stops have the same offset value, then there are no adjacent color stops and the color value of every point on the line segment shall be \tcode{rgba_color::transparent_black()}. The remaining rules are inapplicable if either of these conditions is met.

\item When no color stop has the offset value of 0.0, then, defining $n$ to be the offset value of the color stop whose offset value is nearest to 0.0, the color value of every point along the line segment in the offset range $[0, n)$ shall be \tcode{rgba_color::transparent_black()}.

\item When no color stop has the offset value of 1.0, then, defining $n$ to be the offset value of the color stop whose offset value is nearest to 1.0, the color value of every point along the line segment in the offset range $(n, 1]$ shall be \tcode{rgba_color::transparent_black()}.

\item Each color stop has, at most, two adjacent color stops: one to its left and one to its right.

\item Adjacency of color stops is initially determined by offset values. If two or more color stops have the same offset value then index values are used to conclusively determine adjacency as set forth in the remaining rules.

\item For each color stop \textit{a}, the \term{set of color stops to its left} are those color stops which have an offset value which is closer to 0.0 than \textit{a}'s offset value.
\enternote
This includes any color stops with an offset value of 0.0 provided that \textit{a}'s offset value is not 0.0.
\exitnote

\item For each color stop \textit{b}, the \term{set of color stops to its right} are those color stops which have an offset value which is closer to 1.0 than \textit{b}'s offset value.
\enternote
This includes any color stops with an offset value of 1.0 provided that \textit{b}'s offset value is not 1.0.
\exitnote

\item A color stop which has an offset value of 0.0 cannot have an adjacent color stop to its left.

\item A color stop which has an offset value of 1.0 cannot have an adjacent color stop to its right.

\item If a color stop \textit{a}'s set of color stops to its left consists of exactly one color stop, that color stop is the color stop that is adjacent to \textit{a} on its left.

\item If a color stop \textit{b}'s set of color stops to its right consists of exactly one color stop, that color stop is the color stop that is adjacent to \textit{b} on its right.

\item If two or more color stops have the same offset value then the color stop with the lowest index value is the only color stop from that set of color stops which can have a color stop that is adjacent to it on its left and the color stop with the highest index value is the only color stop from that set of color stops which can have a color stop that is adjacent to it on its right. This rule takes precedence over all of the remaining rules.

\item If a color stop can have an adjacent color stop to its left, then the color stop which is adjacent to it to its left is the color stop from the set of color stops to its left which has an offset value which is closest to its offset value. If two or more color stops meet that criteria, then the color stop which is adjacent to it to its left is the color stop which has the highest index value from the set of color stops to its left which are tied for being closest to its offset value.

\item If a color stop can have an adjacent color stop to its right, then the color stop which is adjacent to it to its right is the color stop from the set of color stops to its right which has an offset value which is closest to its offset value. If two or more color stops meet that criteria, then the color stop which is adjacent to it to its right is the color stop which has the lowest index value from the set of color stops to its right which are tied for being closest to its offset value.
\end{itemize}

\pnum
For each color stop which has at least one adjacent color stop, all points perpendicular to that color stop relative to the \tcode{linear_brush_factory}'s line segment shall have the same color.

\pnum
For each point on the line segment between adjacent color stops, the color for that point and for all points perpendicular to that point shall be a linear interpolation between the color values of the adjacent color stops.

\pnum
It is unspecified whether the linear interpolation between the colors of two adjacent color stops is performed linearly on each color channel, is performed within an RGB color space (with or without gamma correction), or is performed by a linear color interpolation algorithm implemented in hardware (typically in a graphics processing unit).

\pnum
Implementations shall interpolate between alpha channel values of adjacent color stops linearly except as provided in the following paragraph.

\pnum
A conforming implementation may use the alpha channel interpolation results from a linear color interpolation algorithm implemented in hardware even if those results differ from the results required by the previous paragraph.

\rSec1 [\iotwod.radialbrushfact.cons] {\tcode{radial_brush_factory} constructors and assignment operators}

\indexlibrary{\idxcode{radial_brush_factory}!constructor}
\begin{itemdecl}
    radial_brush_factory() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{radial_brush_factory}.
	
	\pnum
	\postconditions
	\tcode{_Center0 == vector_2d\{ \}}.

	\pnum
	\tcode{_Radius0 == 0.0}.

	\pnum
	\tcode{_Center1 == vector_2d\{ \}}.
	
	\pnum
	\tcode{_Radius1 == 0.0}.

	\pnum
	\tcode{_Color_stops.empty() == true}.
	
\end{itemdescr}

\indexlibrary{\idxcode{radial_brush_factory}!constructor}
\begin{itemdecl}
    radial_brush_factory(const vector_2d& center0, double radius0,
      const vector_2d& center1, double radius1) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{radial_brush_factory}.
	
	\pnum
	\postconditions
	\tcode{_Center0 == center0}.

	\pnum
	\tcode{_Radius0 == radius0}.

	\pnum
	\tcode{_Center1 == center1}.
	
	\pnum
	\tcode{_Radius1 == radius1}.

	\pnum
	\tcode{_Color_stops.empty() == true}.
	
\end{itemdescr}

\rSec1 [\iotwod.radialbrushfact.modifiers] {\tcode{radial_brush_factory} modifiers}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{add_color_stop}}
\indexlibrary{\idxcode{add_color_stop}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    void add_color_stop(double offset, const rgba_color& color);
    void add_color_stop(double offset, const rgba_color& color,
      error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Adds a color stop with an offset value of \tcode{offset} and a color value of \tcode{color}.
	
	\pnum
	\postconditions
	\tcode{_Color_stops.push_back(make_tuple(offset, color))}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if the attempt to add the color stop fails.
	
\end{itemdescr}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{color_stop}}
\indexlibrary{\idxcode{color_stop}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    void color_stop(unsigned int index, double offset, const rgba_color& color);
    void color_stop(unsigned int index, double offset, const rgba_color& color,
      error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	\tcode{_Color_stops.size() > index}.
	
	\pnum
	\effects
	Replaces the color stop at index \tcode{index} with a color stop with an offset of \tcode{offset} and a color of \tcode{color}.

	\pnum
	\postconditions
	\tcode{_Color_stops.at(index) == make_tuple(offset, color)}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{io2d_error::invalid_index} if \tcode{index} violated the preconditions.

\end{itemdescr}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{radial_circles}}
\indexlibrary{\idxcode{radial_circles}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    void radial_circles(const vector_2d& center0, double radius0,
      const vector_2d& center1, double radius1) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Center0 == center0}.
	
	\pnum
	\tcode{_Radius0 == radius0}.
	
	\pnum
	\tcode{_Center1 == center1}.

	\pnum
	\tcode{_Radius1 == radius1}.

\end{itemdescr}

\rSec1 [\iotwod.radialbrushfact.observers] {\tcode{radial_brush_factory} observers}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{color_stop_count}}
\indexlibrary{\idxcode{color_stop_count}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    unsigned int color_stop_count() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{static_cast<unsigned int>(_Color_stops.size())}.

\end{itemdescr}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{color_stop}}
\indexlibrary{\idxcode{color_stop}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    tuple<double, rgba_color> color_stop(unsigned int index) const;
    tuple<double, rgba_color> color_stop(unsigned int index,
      error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\preconditions
	\tcode{_Color_stops.size() > index}.
	
	\pnum
	\returns
	\tcode{_Color_stops.at(index)}.

	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{io2d_error::invalid_index} if \tcode{index} violated the preconditions.

\end{itemdescr}

\indexlibrary{\idxcode{radial_brush_factory}!\idxcode{radial_circles}}
\indexlibrary{\idxcode{radial_circles}!\idxcode{radial_brush_factory}}
\begin{itemdecl}
    tuple<vector_2d, double, vector_2d, double> radial_circles() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{make_tuple(_Center0, _Radius0, _Center1, _Radius1)}.

\end{itemdescr}
