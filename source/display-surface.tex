%!TEX root = io2d.tex
\rSec0 [\iotwod.displaysurface] {Class \tcode{display_surface}}

\rSec1 [\iotwod.displaysurface.intro] {\tcode{display_surface} description}

\pnum
\indexlibrary{\idxcode{display_surface}}%
The class \tcode{display_surface} derives from the \tcode{surface} class and provides an interface to a pixmap called the \term{back buffer} and to a second pixmap called the \term{display buffer}.

\pnum
The pixel data of the display buffer can never be accessed by the user except through a native handle, if one is provided. As such, its pixel format need not equate to any of the pixel formats described by the \tcode{experimental::io2d::format} enumerators. This is meant to give implementors more flexibility in trying to display the pixels of the back buffer in a way that is visually as close as possible to the colors of those pixels.

\pnum
The \term{draw callback} (Table~\ref{tab:\iotwod.displaysurface.state.listing}) is called by \tcode{display_surface::show} as required by the refresh rate and when otherwise needed by the implementation in order to update the pixel content of the back buffer.

\pnum
After each execution of the draw callback, the contents of the back buffer are transferred using sampling with an \unspecnorm filter to the display buffer. The display buffer is then shown to the user via the \term{output device}.
\begin{note}
The filter is \unspecnorm to allow implementations to achieve the best possible result, including by changing filters at runtime depending on factors such as whether scaling is required and by using specialty hardware if available, while maintaining a balance between quality and performance that the implementer deems acceptable.

In the absence of specialty hardware, implementers are encouraged to use a filter that is the equivalent of a nearest neighbor interpolation filter if no scaling is required and otherwise to use a filter that produces results that are at least as good as those that would be obtained by using a bilinear interpolation filter.
\end{note}

\rSec1 [\iotwod.displaysurface.synopsis] {\tcode{display_surface} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class display_surface : public surface {
  public:
    // \ref{\iotwod.displaysurface.cons}, construct/copy/move/destroy:
    display_surface(display_surface&& other) noexcept;
    display_surface& operator=(display_surface&& other) noexcept;
    
    display_surface(int preferredWidth, int preferredHeight, 
      experimental::io2d::format preferredFormat,
      experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
      experimental::io2d::refresh_rate rr =
      experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f);
    display_surface(int preferredWidth, int preferredHeight, 
      experimental::io2d::format preferredFormat, error_code& ec,
      experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
      experimental::io2d::refresh_rate rr =
      experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f) 
      noexcept;
    
    display_surface(int preferredWidth, int preferredHeight, 
      experimental::io2d::format preferredFormat,
      int preferredDisplayWidth, int preferredDisplayHeight,
      experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
      experimental::io2d::refresh_rate rr =
      experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f);
    display_surface(int preferredWidth, int preferredHeight, 
      experimental::io2d::format preferredFormat,
      int preferredDisplayWidth, int preferredDisplayHeight, error_code& ec,
      experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
      experimental::io2d::refresh_rate rr =
      experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f) 
      noexcept;
    
    ~display_surface();
    
    // \ref{\iotwod.displaysurface.modifiers}, modifiers:
    void draw_callback(const function<void(display_surface& sfc)>& fn);
    void size_change_callback(const function<void(display_surface& sfc)>& fn);
    void width(int w);
    void width(int w, error_code& ec) noexcept;
    void height(int h);
    void height(int h, error_code& ec) noexcept;
    void display_width(int w);
    void display_width(int w, error_code& ec) noexcept;
    void display_height(int h);
    void display_height(int h, error_code& ec) noexcept;
    void dimensions(int w, int h);
    void dimensions(int w, int h, error_code& ec) noexcept;
    void display_dimensions(int dw, int dh);
    void display_dimensions(int dw, int dh, error_code& ec) noexcept;
    void scaling(experimental::io2d::scaling scl) noexcept;
    void user_scaling_callback(const function<experimental::io2d::rectangle(
      const display_surface&, bool&)>& fn);
    void letterbox_brush(const optional<brush>& b,
      const optional<brush_props> = nullopt) noexcept;
    void auto_clear(bool val) noexcept;
    void refresh_rate(experimental::io2d::refresh_rate rr) noexcept;
    bool desired_frame_rate(float fps) noexcept;
    void redraw_required() noexcept;
    int begin_show();
    void end_show();
    
    // \ref{\iotwod.displaysurface.observers}, observers:
    experimental::io2d::format format() const noexcept;
    int width() const noexcept;
    int height() const noexcept;
    int display_width() const noexcept;
    int display_height() const noexcept;
    vector_2d dimensions() const noexcept;
    vector_2d display_dimensions() const noexcept;
    experimental::io2d::scaling scaling() const noexcept;
    function<experimental::io2d::rectangle(const display_surface&,
      bool&)> user_scaling_callback() const;
    function<experimental::io2d::rectangle(const display_surface&,
      bool&)> user_scaling_callback(error_code& ec) const noexcept;
    optional<brush> letterbox_brush() const noexcept;
    optional<brush_props> letterbox_brush_props() const noexcept;
    bool auto_clear() const noexcept;
    experimental::io2d::refresh_rate refresh_rate() const noexcept;
    float desired_frame_rate() const noexcept;
    float elapsed_draw_time() const noexcept;
  };
}
\end{codeblock}

\rSec1 [\iotwod.displaysurface.misc] {\tcode{display_surface} miscellaneous behavior}

\pnum
What constitutes an output device is \impldefplain{output device}, with the sole constraint being that an output device must allow the user to see the dynamically-updated contents of the display buffer.
\begin{example}
An output device might be a window in a windowing system environment or the usable screen area of a smart phone or tablet.
\end{example}

\pnum
Implementations do not need to support the simultaneous existence of multiple \tcode{display_surface} objects.

\pnum
All functions inherited from \tcode{surface} that affect its \underlyingsurface shall operate on the back buffer.

\rSec1 [\iotwod.displaysurface.state] {\tcode{display_surface} state}

\pnum
Table~\ref{tab:\iotwod.displaysurface.state.listing} specifies the name, type, function, and default value for each item of a display surface's observable state.

\begin{libreqtab4b}
	{Display surface observable state}
	{tab:\iotwod.displaysurface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	\term{Letterbox brush} &
	\tcode{brush} &
	This is the brush that shall be used as specified by \tcode{scaling::letterbox} (Table~\ref{tab:\iotwod.scaling.meanings}) &
	\tcode{brush\{ \{ rgba_color::black() \} \}} \\ \rowsep
	
	\term{Letterbox brush props} &
	\tcode{brush_props} &
	This is the brush properties for the letterbox brush &
	\tcode{brush_props\{ \}} \\ \rowsep
	
	\term{Scaling type} &
	\tcode{scaling} &
	When the user scaling callback is equal to its default value, this is the type of scaling that shall be used when transferring the back buffer to the display buffer &
	\tcode{scaling::letterbox}\\ \rowsep
	
	\term{Draw width} &
	\tcode{int} &
	The width in pixels of the back buffer. The minimum value is \tcode{1}. The maximum value is \unspecnorm. Because users can only request a preferred value for the draw width when setting and altering it, the maximum value may be a run-time determined value. If the preferred draw width exceeds the maximum value, then if a preferred draw height has also been supplied then implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the preferred draw height otherwise implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the current draw height &
	\textit{N/A}
	\begin{note}
	It is impossible to create a \tcode{display_surface} object without providing a preferred draw width value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Draw height} &
	\tcode{int} &
	The height in pixels of the back buffer. The minimum value is \tcode{1}. The maximum value is \unspecnorm. Because users can only request a preferred value for the draw height when setting and altering it, the maximum value may be a run-time determined value. If the preferred draw height exceeds the maximum value, then if a preferred draw width has also been supplied then implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the preferred draw height otherwise implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the current draw width and the preferred draw height &
	\textit{N/A}
	\begin{note}
	It is impossible to create a \tcode{display_surface} object without providing a preferred draw height value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Draw format} &
	\tcode{format} &
	The pixel format of the back buffer. When a \tcode{display_surface} object is created, a preferred pixel format value is provided. If the implementation does not support the preferred pixel format value as the value of draw format, the resulting value of draw format is \impldefplain{display_surface!unsupported draw format} &
	\textit{N/A}
	\begin{note}
	It is impossible to create a \tcode{display_surface} object without providing a preferred draw format value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Display width} &
	\tcode{int} &
	The width in pixels of the display buffer. The minimum value is \unspecnorm. The maximum value is \unspecnorm. Because users can only request a preferred value for the display width when setting and altering it, both the minimum value and the maximum value may be run-time determined values. If the preferred display width is not within the range between the minimum value and the maximum value, inclusive, then if a preferred display height has also been supplied then implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the preferred display height otherwise implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the current display height &
	\textit{N/A}
	\begin{note}
	It is impossible to create a \tcode{display_surface} object without providing a preferred display width value since in the absence of an explicit display width argument the mandatory preferred draw width argument is used as the preferred display width; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Display height} &
	\tcode{int} &
	The height in pixels of the display buffer. The minimum value is \unspecnorm. The maximum value is \unspecnorm. Because users can only request a preferred value for the display height when setting and altering it, both the minimum value and the maximum value may be run-time determined values. If the preferred display height is not within the range between the minimum value and the maximum value, inclusive, then if a preferred display width has also been supplied then implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the preferred display height otherwise implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the current display width and the preferred display height &
	\textit{N/A}
	\begin{note}
	It is impossible to create a \tcode{display_surface} object without providing a preferred display height value since in the absence of an explicit display height argument the mandatory preferred draw height argument is used as the preferred display height; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Draw callback} &
	\tcode{function<\br
	\tcode{void(}\br
	\tcode{display_surface\&)>}} &
	This function shall be called in a continuous loop when \tcode{display_surface::show} is executing. It is used to draw to the back buffer, which in turn results in the display of the drawn content to the user &
	\tcode{nullptr} \\ \rowsep
	
	\term{Size change callback} &
	\tcode{function<\br
	\tcode{void(}\br
	\tcode{display_surface\&)>}} &
	If it exists, this function shall be called whenever the display buffer has been resized. Neither the display width nor the display height shall be changed by the size change callback; no diagnostic is required
	\begin{note}
	This means that there has been a change to the display width, display height, or both. Its intent is to allow the user the opportunity to change other observable state, such as the draw width, draw height, or scaling type, in reaction to the change.
	\end{note} &
	\tcode{nullptr} \\ \rowsep
	
	\term{User scaling callback} &
	\tcode{function<\br
	\tcode{rectangle(}\br
	\tcode{const display_surface\&,}\br
	\tcode{bool\&)>}} &
	If it exists, this function shall be called whenever the contents of the back buffer need to be copied to the display buffer. The function is called with the const reference to \tcode{display_surface} object and a reference to a \tcode{bool} variable which has the value \tcode{false}. If the value of the \tcode{bool} is \tcode{true} when the function returns, the letterbox brush shall be used as specified by \tcode{scaling::letterbox} (Table~\ref{tab:\iotwod.scaling.meanings}). The function shall return a \tcode{rectangle} object that defines the area within the display buffer to which the back buffer shall be transferred. The \tcode{rectangle} may include areas outside of the bounds of the display buffer, in which case only the area of the back buffer that lies within the bounds of the display buffer will ultimately be visible to the user &
	\tcode{nullptr} \\ \rowsep
	
	\term{Auto clear} &
	\tcode{bool} &
	If \tcode{true} the implementation shall call \tcode{surface::clear}, which shall clear the back buffer, immediately before it executes the draw callback &
	\tcode{false} \\ \rowsep
	
	\term{Refresh rate} &
	\tcode{refresh_rate} &
	The \tcode{refresh_rate} value that determines when the draw callback shall be called while \tcode{display_surface::show} is being executed &
	\tcode{refresh_rate::as_fast_as_possible} \\ \rowsep
	
	\term{Desired frame rate} &
	\tcode{float} &
	This value is the number of times the draw callback shall be called per second while \tcode{display_surface::show} is being executed when the value of refresh rate is \tcode{refresh_rate::fixed}, subject to the additional requirements documented in the meaning of \tcode{refresh_rate::fixed} (Table~\ref{tab:\iotwod.refreshrate.meanings}) \\ \rowsep
	
\end{libreqtab4b}

\rSec1 [\iotwod.displaysurface.cons] {\tcode{display_surface} constructors and assignment operators}

\indexlibrary{\idxcode{display_surface}!constructor}%
\begin{itemdecl}
display_surface(int preferredWidth, int preferredHeight, 
  experimental::io2d::format preferredFormat,
  experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
  experimental::io2d::refresh_rate rr =
  experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f);
display_surface(int preferredWidth, int preferredHeight, 
  experimental::io2d::format preferredFormat, error_code& ec,
  experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
  experimental::io2d::refresh_rate rr =
  experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{preferredWidth > 0}.

\pnum
\tcode{preferredHeight > 0}.

\pnum
\tcode{preferredFormat != experimental::io2d::format::invalid}.


\pnum
\effects
Constructs an object of type \tcode{display_surface}.

\pnum
The preferredWidth parameter specifies the preferred width value for draw width and display width. The preferredHeight parameter specifies the preferred height value for draw height and display height. draw width and display width need not have the same value. draw height and display height need not have the same value.

\pnum
The preferredFormat parameter specifies the preferred pixel format value for draw format.

\pnum
The value of scaling type shall be the value of \tcode{scl}.

\pnum
The value of refresh rate shall be the value of \tcode{rr}.

\pnum
The value of desired frame rate shall be as-if \tcode{display_surface::desired_frame_rate} was called with \tcode{fps} as its argument. If \tcode{!is_finite(fps)}, then the value of desired frame rate shall be its default value.

\pnum
All other observable state data shall have their default values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_supported} if creating the \tcode{display_surface} object would exceed the maximum number of simultaneous \tcode{display_surface} objects the implementation supports.
\end{itemdescr}

\indexlibrary{\idxcode{display_surface}!constructor}%
\begin{itemdecl}
display_surface(int preferredWidth, int preferredHeight, 
  experimental::io2d::format preferredFormat,
  int preferredDisplayWidth, int preferredDisplayHeight,
  experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
    experimental::io2d::refresh_rate rr =
    experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f);
display_surface(int preferredWidth, int preferredHeight, 
  experimental::io2d::format preferredFormat,
  int preferredDisplayWidth, int preferredDisplayHeight, error_code& ec,
  experimental::io2d::scaling scl = experimental::io2d::scaling::letterbox,
    experimental::io2d::refresh_rate rr =
    experimental::io2d::refresh_rate::as_fast_as_possible, float fps = 30.0f) 
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{preferredWidth > 0}.

\pnum
\tcode{preferredHeight > 0}.

\pnum
\tcode{preferredDisplayWidth > 0}.

\pnum
\tcode{preferredDisplayHeight > 0}.

\pnum
\tcode{preferredFormat != experimental::io2d::format::invalid}.

\pnum
\effects
Constructs an object of type \tcode{display_surface}.

\pnum
The preferredWidth parameter specifies the preferred width value for draw width. The preferredDisplayWidth parameter specifies the preferred display width value for display width. The preferredHeight parameter specifies the preferred height value for draw height. The preferredDisplayHeight parameter specifies the preferred display height value for display height.

\pnum
The preferredFormat parameter specifies the preferred pixel format value for draw format.

\pnum
The value of scaling type shall be the value of \tcode{scl}.

\pnum
The value of refresh rate shall be the value of \tcode{rr}.

\pnum
The value of desired frame rate shall be as-if \tcode{display_surface::desired_frame_rate} was called with \tcode{fps} as its argument. If \tcode{!is_finite(fps)}, then the value of desired frame rate shall be its default value.

\pnum
All other observable state data shall have their default values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_supported} if creating the \tcode{display_surface} object would exceed the maximum number of simultaneous \tcode{display_surface} objects the implementation supports.
\end{itemdescr}

\rSec1 [\iotwod.displaysurface.modifiers]{\tcode{display_surface} modifiers}

\indexlibrarymember{draw_callback}{display_surface}%
\begin{itemdecl}
void draw_callback(const function<void(display_surface& sfc)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the draw callback to \tcode{fn}.
\end{itemdescr}

\indexlibrarymember{size_change_callback}{display_surface}%
\begin{itemdecl}
void size_change_callback(const function<void(display_surface& sfc)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the size change callback to \tcode{fn}.
\end{itemdescr}

\indexlibrary{width}{display_surface}%
\begin{itemdecl}
void width(int w);
void width(int w, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of draw width is the same as \tcode{w}, this function does nothing.

\pnum
Otherwise, draw width is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{w} treated as being the preferred draw width.

\pnum
If the value of draw width changes as a result, the implementation shall attempt to create a new back buffer with the updated dimensions while retaining the existing back buffer. The implementation may destroy the existing back buffer prior to creating a new back buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new back buffer or will be able to create a back buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid back buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new back buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing back buffer even if they cannot determine in advance that creating the new back buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a back buffer with the previous dimensions. Regardless, there must be a valid back buffer when this call completes.
\end{note}

\pnum
The value of the back buffer's pixel data shall be \unspecnorm upon completion of this function regardless of whether it succeeded.

\pnum
If an error occurs, the implementation shall ensure that the back buffer is valid and has the same dimensions it had prior to this call and that draw width shall retain its value prior to this call.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{w <= 0} or if the value of \tcode{w} is greater than the maximum value for draw width.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a back buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!width}.
\end{itemdescr}

\indexlibrarymember{height}{display_surface}%
\begin{itemdecl}
void height(int h);
void height(int h, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of draw height is the same as \tcode{h}, this function does nothing.

\pnum
Otherwise, draw height is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{h} treated as being the preferred draw height.

\pnum
If the value of draw height changes as a result, the implementation shall attempt to create a new back buffer with the updated dimensions while retaining the existing back buffer. The implementation may destroy the existing back buffer prior to creating a new back buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new back buffer or will be able to create a back buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid back buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new back buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing back buffer even if they cannot determine in advance that creating the new back buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a back buffer with the previous dimensions. Regardless, there must be a valid back buffer when this call completes.
\end{note}

\pnum
The value of the back buffer's pixel data shall be \unspecnorm upon completion of this function regardless of whether it succeeded.

\pnum
If an error occurs, the implementation shall ensure that the back buffer is valid and has the same dimensions it had prior to this call and that draw height shall retain its value prior to this call.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{h <= 0} or if the value of \tcode{h} is greater than the maximum value for draw height.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a back buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!height}.
\end{itemdescr}

\indexlibrarymember{display_width}{display_surface}%
\begin{itemdecl}
void display_width(int w);
void display_width(int w, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of display width is the same as \tcode{w}, this function does nothing.

\pnum
Otherwise, display width is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{w} treated as being the preferred display width.

\pnum
If the value of display width changes as a result, the implementation shall attempt to create a new display buffer with the updated dimensions while retaining the existing display buffer. The implementation may destroy the existing display buffer prior to creating a new display buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new display buffer or will be able to create a display buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid display buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new display buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing display buffer even if they cannot determine in advance that creating the new display buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a display buffer with the previous dimensions. Regardless, there must be a valid display buffer when this call completes.
\end{note}

\pnum
The value of the display buffer's pixel data shall be \unspecnorm upon completion of this function regardless of whether it succeeded.

\pnum
If an error occurs, the implementation shall ensure that the display buffer is valid and has the same dimensions it had prior to this call and that display width shall retain its value prior to this call.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if the value of \tcode{w} is less than the minimum value for display width or if the value of \tcode{w} is greater than the maximum value for display width.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a display buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!display_width}.
\end{itemdescr}

\indexlibrarymember{display_height}{display_surface}%
\begin{itemdecl}
void display_height(int h);
void display_height(int h, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of display height is the same as \tcode{h}, this function does nothing.

\pnum
Otherwise, display height is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{h} treated as being the preferred display height.

\pnum
If the value of display height changes as a result, the implementation shall attempt to create a new display buffer with the updated dimensions while retaining the existing display buffer. The implementation may destroy the existing display buffer prior to creating a new display buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new display buffer or will be able to create a display buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid display buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new display buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing display buffer even if they cannot determine in advance that creating the new display buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a display buffer with the previous dimensions. Regardless, there must be a valid display buffer when this call completes.
\end{note}

\pnum
The value of the display buffer's pixel data shall be \unspecnorm upon completion of this function regardless of whether it succeeded.

\pnum
If an error occurs, the implementation shall ensure that the display buffer is valid and has the same dimensions it had prior to this call and that display height shall retain its value prior to this call.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if the value of \tcode{h} is less than the minimum value for display height or if the value of \tcode{h} is greater than the maximum value for display height.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a display buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!display_height}.
\end{itemdescr}

\indexlibrarymember{dimensions}{display_surface}%
\begin{itemdecl}
void dimensions(int w, int h);
void dimensions(int w, int h, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of draw width is the same as \tcode{w} and the value of draw height is the same as \tcode{h}, this function does nothing.

\pnum
Otherwise, draw width is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{w} treated as being the preferred draw width and draw height is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{h} treated as being the preferred draw height.

\pnum
If the value of draw width changes as a result or the value of draw height changes as a result, the implementation shall attempt to create a new back buffer with the updated dimensions while retaining the existing back buffer. The implementation may destroy the existing back buffer prior to creating a new back buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new back buffer or will be able to create a back buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid back buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new back buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing back buffer even if they cannot determine in advance that creating the new back buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a back buffer with the previous dimensions. Regardless, there must be a valid back buffer when this call completes.
\end{note}

\pnum
The value of the back buffer's pixel data shall be \unspecnorm upon completion of this function regardless of whether it succeeded.

\pnum
If an error occurs, the implementation shall ensure that the back buffer is valid and has the same dimensions it had prior to this call and that draw width and draw height shall retain the values they had prior to this call.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{w <= 0}, if the value of \tcode{w} is greater than the maximum value for draw width, if \tcode{h <= 0} or if the value of \tcode{h} is greater than the maximum value for draw height.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a back buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!dimensions}.
\end{itemdescr}

\indexlibrarymember{display_dimensions}{display_surface}%
\begin{itemdecl}
void display_dimensions(int dw, int dh);
void display_dimensions(int dw, int dh, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the value of display width is the same as \tcode{w} and the value of display height is the same as \tcode{h}, this function does nothing.

\pnum
Otherwise, display width is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{w} treated as being the preferred display height and display height is set as specified by Table~\ref{tab:\iotwod.displaysurface.state.listing} with \tcode{h} treated as being the preferred display height.

\pnum
If the value of display width or the value of display height changes as a result, the implementation shall attempt to create a new display buffer with the updated dimensions while retaining the existing display buffer. The implementation may destroy the existing display buffer prior to creating a new display buffer with the updated dimensions only if it can guarantee that in doing so it will either succeed in creating the new display buffer or will be able to create a display buffer with the previous dimensions in the event of failure.

\pnum
\begin{note}
The intent of the previous paragraph is to ensure that, no matter the result, a valid display buffer continues to exist. Sometimes implementations will be able to determine that the new dimensions are valid but that to create the new display buffer successfully the previous one must be destroyed. The previous paragraph gives implementors that leeway. It goes even further in that it allows implementations to destroy the existing display buffer even if they cannot determine in advance that creating the new display buffer will succeed, provided that they can guarantee that if the attempt fails they can always successfully recreate a display buffer with the previous dimensions. Regardless, there must be a valid display buffer when this call completes.
\end{note}

\pnum
If an error occurs, the implementation shall ensure that the display buffer is valid and has the same dimensions it had prior to this call and that display width and display height shall retain the values they had prior to this call.

\pnum
If the display buffer has changed, even if its width and height have not changed, the draw callback shall be called.

\pnum
If the width or height of the display buffer has changed, the size change callback shall be called if it's value is not its default value.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if the value of \tcode{w} is less than the minimum value for display width, if the value of \tcode{w} is greater than the maximum value for display width, if the value of \tcode{h} is less than the minimum value for display height, or if the value of \tcode{h} is greater than the maximum value for display height.

\pnum
\tcode{errc::not_enough_memory} if there is insufficient memory to create a display buffer with the updated dimensions.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!display_dimensions}.
\end{itemdescr}

\indexlibrarymember{scaling}{display_surface}%
\begin{itemdecl}
void scaling(experimental::io2d::scaling scl) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets scaling type to the value of \tcode{scl}.
\end{itemdescr}

\indexlibrarymember{user_scaling_callback}{display_surface}%
\begin{itemdecl}
void user_scaling_callback(const function<experimental::io2d::rectangle(
  const display_surface&, bool&)>& fn);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the user scaling callback to \tcode{fn}.
\end{itemdescr}

\indexlibrarymember{letterbox_brush}{display_surface}%
\begin{itemdecl}
void letterbox_brush(const optional<brush&>b,
  const optional<brush_props>& bp = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the letterbox brush to the value contained in \tcode{b} if it contains a value, otherwise sets the letterbox brush to its default value.

\pnum
Sets the letterbox brush props to the value contained in \tcode{bp} if it contains a value, otherwise sets the letterbox brush props to its default value.
\end{itemdescr}

\indexlibrarymember{auto_clear}{display_surface}%
\begin{itemdecl}
void auto_clear(bool val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets auto clear to the value of \tcode{val}.
\end{itemdescr}

\indexlibrarymember{refresh_rate}{display_surface}%
\begin{itemdecl}
void refresh_rate(experimental::io2d::refresh_rate rr) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the refresh rate to the value of \tcode{rr}.
\end{itemdescr}

\indexlibrarymember{desired_frame_rate}{display_surface}%
\begin{itemdecl}
bool desired_frame_rate(float fps) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If \tcode{!is_finite(fps)}, this function has no effects.

\pnum
Sets the desired frame rate to an \impldefplain{display_surface!minimum frame rate} minimum frame rate if \tcode{fps} is less than the minimum frame rate, an \impldefplain{display_surface!maximum frame rate} maximum frame rate if \tcode{fps} is greater than the maximum frame rate, otherwise to the value of \tcode{fps}.

\pnum
\returns
\tcode{false} if the desired frame rate was set to the value of \tcode{fps}; otherwise \tcode{true}.
\end{itemdescr}

\indexlibrarymember{redraw_required}{display_surface}%
\begin{itemdecl}
void redraw_required() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
When \tcode{display_surface::begin_show} is executing, informs the implementation that the draw callback must be called as soon as possible.
\end{itemdescr}

\indexlibrarymember{begin_show}{display_surface}%
\begin{itemdecl}
int begin_show();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the following actions in a continuous loop:
\begin{enumerate}
	\item Handle any implementation and host environment matters. If there are no pending implementation or host environment matters to handle, proceed immediately to the next action.
	\item Run the size change callback if doing so is required by its specification and it does not have a value equivalent to its default value.
	\item If the refresh rate requires that the draw callback be called then:
	\begin{enumeratea}
		\item Evaluate auto clear and perform the actions required by its specification, if any.
		\item Run the draw callback.
		\item Ensure that all operations from the draw callback that can effect the back buffer have completed.
		\item Transfer the contents of the back buffer to the display buffer using sampling with an \unspecnorm filter. If the user scaling callback does not have a value equivalent to its default value, use it to determine the position where the contents of the back buffer shall be transferred to and whether or not the letterbox brush should be used. Otherwise use the value of scaling type to determine the position and whether the letterbox brush should be used.
	\end{enumeratea}
\end{enumerate}

\pnum
If \tcode{display_surface::end_show} is called from the draw callback, the implementation shall finish executing the draw callback and shall immediately cease to perform any actions in the continuous loop other than handling any implementation and host environment matters needed to exit the loop properly.

\pnum
No later than when this function returns, the output device shall cease to display the contents of the display buffer.

\pnum
What the output device shall display when it is not displaying the contents of the display buffer is \unspecnorm.

\pnum
\returns
The possible values and meanings of the possible values returned are \impldefplain{display_surface!begin_show return value}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
Since this function calls the draw callback and can call the size change callback and the user scaling callback, in addition to the errors documented below, any errors that the callback functions produce can also occur.

\pnum
\errors
\tcode{errc::operation_would_block} if the value of draw callback is equivalent to its default value or if it becomes equivalent to its default value before this function returns.

\pnum
Other errors, if any, produced by this function are \impldefplain{display_surface!begin_show}.
\end{itemdescr}

\indexlibrarymember{end_show}{display_surface}%
\begin{itemdecl}
void end_show();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If this function is called outside of the draw callback while it is being executed in the \tcode{display_surface::begin_show} function's continuous loop, it does nothing.

\pnum
Otherwise, the implementation initiates the process of exiting the \tcode{display_surface::begin_show} function's continuous loop.

\pnum
If possible, any procedures that the host environment requires in order to cause the \tcode{display_surface::show} function's continuous loop to stop executing without error should be followed.

\pnum
The \tcode{display_surface::begin_show} function's loop continues execution until it returns.
\end{itemdescr}

\rSec1 [\iotwod.displaysurface.observers]{\tcode{display_surface} observers}

\indexlibrarymember{format}{display_surface}%
\begin{itemdecl}
experimental::io2d::format format() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of draw format.
\end{itemdescr}

\indexlibrarymember{width}{display_surface}%
\begin{itemdecl}
int width() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The draw width.
\end{itemdescr}

\indexlibrarymember{height}{display_surface}%
\begin{itemdecl}
int height() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The draw height.
\end{itemdescr}

\indexlibrarymember{display_width}{display_surface}%
\begin{itemdecl}
int display_width() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The display width.
\end{itemdescr}

\indexlibrarymember{display_height}{display_surface}%
\begin{itemdecl}
int display_height() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The display height.
\end{itemdescr}

\indexlibrarymember{dimensions}{display_surface}%
\begin{itemdecl}
vector_2d dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{vector_2d} constructed using the draw width as the first argument and the draw height as the second argument.
\end{itemdescr}

\indexlibrarymember{display_dimensions}{display_surface}%
\begin{itemdecl}
vector_2d display_dimensions() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{vector_2d} constructed using the display width as the first argument and the display height as the second argument.
\end{itemdescr}

\indexlibrarymember{scaling}{display_surface}%
\begin{itemdecl}
experimental::io2d::scaling scaling() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The scaling type.
\end{itemdescr}

\indexlibrarymember{user_scaling_callback}{display_surface}%
\begin{itemdecl}
function<experimental::io2d::rectangle(const display_surface&, bool&)>
  user_scaling_callback() const;
function<experimental::io2d::rectangle(const display_surface&, bool&)>
  user_scaling_callback(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A copy of user scaling callback.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if a failure to allocate memory occurs.
\end{itemdescr}

\indexlibrarymember{letterbox_brush}{display_surface}%
\begin{itemdecl}
optional<brush> letterbox_brush() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
An \tcode{optional<brush>} object constructed using the user-provided letterbox brush or, if the letterbox brush is set to its default value, an empty \tcode{optional<brush>} object.
\end{itemdescr}

\indexlibrarymember{letterbox_brush_props}{display_surface}%
\begin{itemdecl}
optional<brush_props> letterbox_brush_props() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
An \tcode{optional<brush_props>} object constructed using the user-provided letterbox brush props or, if the letterbox brush props is set to its default value, an empty \tcode{optional<brush_props>} object.
\end{itemdescr}

\indexlibrarymember{auto_clear}{display_surface}%
\begin{itemdecl}
bool auto_clear() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of auto clear.
\end{itemdescr}

\indexlibrarymember{display_width}{display_surface}%
\begin{itemdecl}
float desired_framerate() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of desired framerate.
\end{itemdescr}

\indexlibrarymember{elapsed_draw_time}{display_surface}%
\begin{itemdecl}
float elapsed_draw_time() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If called from the draw callback during the execution of \tcode{display_surface::show}, the amount of time in milliseconds that has passed since the previous call to the draw callback by the current execution of \tcode{display_surface::show}; otherwise \tcode{0.0f}.
\end{itemdescr}
