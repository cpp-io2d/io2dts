%!TEX root = io2d.tex
\rSec0 [brush] {Class \tcode{brush}}

\rSec1 [brush.intro] {\tcode{brush} Description}

\pnum
\indexlibrary{\idxcode{brush}}
The class \tcode{brush} describes an opaque wrapper for a graphics data graphics resource.

\pnum
A \tcode{brush} object shall be usable with any \tcode{surface} or \tcode{surface}-derived object.

\pnum
A \tcode{brush} object's graphics data is immutable. It is observable only by the effect that it produces when the brush is used as a Source Brush (\ref{surface.sourcebrush}) or as a Mask Brush (\ref{surface.rendering} and \ref{surface.masking}).

\pnum
A \tcode{brush} object also has a tiling value of type \tcode{tiling}, a filter value of type \tcode{filter}, and a transformation matrix of type \tcode{matrix_2d}.

\pnum
A \tcode{brush} object has an immutable \tcode{brush_type} observable state data value which indicates which type of brush it is (Table~\ref{tab:brushtype.meanings}).

\pnum
The \tcode{brush} object's graphics data may have less precision than the graphics data of the brush factory object from which it was created.

\pnum
\enterexample
Several graphics and rendering technologies that are currently widely used store individual color and alpha channel data as 8-bit unsigned normalized integer values while the \tcode{double} type that is used by the \tcode{rgba_color} class for individual color and alpha is often a 64-bit value. It is precisely these situations which the preceding paragraph is intended to address.
\exitexample

\rSec1 [brush.synopsis] {\tcode{brush} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class brush {
  public:
    // \ref{brush.cons}, construct/copy/move/destroy:
    brush() = delete;
    brush(const brush&);
    brush& operator=(const brush&);
    brush(brush&& other) noexcept;
    brush& operator=(brush&& other) noexcept;
    
    brush(const rbga_color& c);
    brush(const rbga_color& c, error_code& ec) noexcept;
    template <Allocator = allocator<color_stop>>
    brush(const vector_2d& begin, const vector_2d& end,
      const color_stop_group<Allocator>& csg);
    template <Allocator = allocator<color_stop>>
    brush(const vector_2d& begin, const vector_2d& end,
      const color_stop_group<Allocator>& csg, error_code& ec) noexcept;
    template <Allocator = allocator<color_stop>>
    brush(const circle& start, const circle& end,
      const color_stop_group<Allocator>& csg);
    template <Allocator = allocator<color_stop>>
    brush(const circle& start, const circle& end,
      const color_stop_group<Allocator>& csg, error_code& ec) noexcept;
    brush(image_surface&& img);
    brush(image_surface&& img, error_code& ec) noexcept;

    // \ref{brush.modifiers}, modifiers:
    void tiling(experimental::io2d::tiling e) noexcept;
    void filter(experimental::io2d::filter f) noexcept;
    void matrix(const matrix_2d& m) noexcept;

    // \ref{brush.observers}, observers:
    experimental::io2d::tiling tiling() const noexcept;
    experimental::io2d::filter filter() const noexcept;
    matrix_2d matrix() const noexcept;
    brush_type type() const noexcept;
    const image_surface& surface() const;
    const image_surface& surface(error_code) const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [brush.sampling] {Sampling from a \tcode{brush} object}

\pnum
When sampling from a \tcode{brush} object \tcode{b}, the \tcode{brush_type} returned by calling \tcode{b.type()} shall determine how the results of sampling shall be determined:
\begin{enumerate}
\item If the result of \tcode{b.type()} is \tcode{brush_type::solid_color} then \tcode{b} is a \term{solid color brush}.
\item If the result of \tcode{b.type()} is \tcode{brush_type::surface} then \tcode{b} is a \term{surface brush}.
\item If the result of \tcode{b.type()} is \tcode{brush_type::linear} then \tcode{b} is a \term{linear gradient brush}.
\item If the result of \tcode{b.type()} is \tcode{brush_type::radial} then \tcode{b} is a \term{radial gradient brush}.
\end{enumerate}

\rSec2 [brush.sampling.color] {Sampling from a color brush}

\pnum
When \tcode{b} is a color brush, then when sampling from \tcode{b}, the visual data returned shall always be the visual data equivalent \tcode{rgba_code} which was passed in when \tcode{b} was created, regardless of the point which is to be sampled and regardless of the return values of \tcode{b.tiling()}, \tcode{b.filter()}, and \tcode{b.matrix()}.

\rSec2 [brush.sampling.linear] {Sampling from a linear gradient brush}

\pnum
When \tcode{b} is a linear gradient brush, then when sampling from \tcode{b}, the visual data returned shall be from the point \tcode{pt} in the rendered linear gradient, where \tcode{pt} is the return value when passing the point to be sampled to \tcode{b.matrix().transform_coords} and the rendered linear gradient is created as specified by \ref{gradients.linear} and \ref{gradients.sampling}, taking into account the value of \tcode{b.tiling()}.

\rSec2 [brush.sampling.radial] {Sampling from a radial gradient brush}

\pnum
When \tcode{b} is a radial gradient brush, then when sampling from \tcode{b}, the visual data returned shall be from the point \tcode{pt} in the rendered radial gradient, where \tcode{pt} is the return value when passing the point to be sampled to \tcode{b.matrix().transform_coords} and the rendered radial gradient is created as specified by \ref{gradients.radial} and \ref{gradients.sampling}, taking into account the value of \tcode{b.tiling()}.

\rSec2 [brush.sampling.surface] {Sampling from a surface brush}

\pnum
When \tcode{b} is a surface brush, then when sampling from \tcode{b}, the visual data returned shall be from the point \tcode{pt} in the graphics data of the brush, where \tcode{pt} is the return value when passing the point to be sampled to \tcode{b.matrix().transform_coords}, taking into account the value of \tcode{b.tiling()} and \tcode{b.filter()}.

\rSec1 [brush.cons] {\tcode{brush} constructors and assignment operators}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(const rbga_color& c);
brush(const rbga_color& c, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
The brush shall be a color brush.

\pnum
The brush's brush type shall be set to the value \tcode{brush_type::solid_color}.

\pnum
The brush's tiling shall be set to the value \tcode{experimental::io2d::tiling::none}.

\pnum
The brush's filter shall be set to the value \tcode{experimental::io2d::filter::fast}.

\pnum
The brush's transformation matrix shall be set to the value \tcode{matrix_2d::init_identity()}.

\pnum
The graphics data of the brush shall be created from the return value of \tcode{f.color()}. The visual data format of the graphics data shall be as if it is that specified by \tcode{format::argb}.

\pnum
\remarks
Sampling from this brush shall produce the results specified in \ref{brush.sampling.color}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
template <Allocator = allocator<color_stop>>
brush(const vector_2d& begin, const vector_2d& end,
  const color_stop_group<Allocator>& csg);
template <Allocator = allocator<color_stop>>
brush(const vector_2d& begin, const vector_2d& end,
  const color_stop_group<Allocator>& csg, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
The brush shall be a linear gradient brush.

\pnum
The brush's brush type shall be set to the value \tcode{brush_type::linear}.

\pnum
The brush's tiling shall be set to the value \tcode{experimental::io2d::tiling::none}.

\pnum
The brush's filter shall be set to the value \tcode{experimental::io2d::filter::fast}.

\pnum
The brush's transformation matrix shall be set to the value \tcode{matrix_2d::init_identity()}.

\pnum
The graphics data of the brush is nominally as specified the introductory paragraphs of \ref{gradients} and in \ref{gradients.linear}. Its color stops shall be the values contained in \tcode{csg}. However because the graphics data is not directly observable, it is \unspecnorm what data is stored and how it is stored, provided that the results of sampling from the brush are the same as if the brush's graphics data was stored as specified in the introductory paragraphs of \ref{gradients} and in \ref{gradients.linear}.

\pnum
\remarks
Sampling from this brush shall produce the results specified in \ref{brush.sampling.linear}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
template <Allocator = allocator<color_stop>>
brush(const circle& start, const circle& end,
  const color_stop_group<Allocator>& csg);
template <Allocator = allocator<color_stop>>
brush(const circle& start, const circle& end,
  const color_stop_group<Allocator>& csg, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
The brush shall be a radial gradient brush.

\pnum
The brush's brush type shall be set to the value \tcode{brush_type::radial}.

\pnum
The brush's tiling shall be set to the value \tcode{experimental::io2d::tiling::none}.

\pnum
The brush's filter shall be set to the value \tcode{experimental::io2d::filter::fast}.

\pnum
The brush's transformation matrix shall be set to the value \tcode{matrix_2d::init_identity()}.

\pnum
The graphics data of the brush is nominally as specified the introductory paragraphs of \ref{gradients} and in \ref{gradients.radial}. Its color stops shall be the values contained in \tcode{csg}. However because the graphics data is not directly observable, it is \unspecnorm what data is stored and how it is stored, provided that the results of sampling from the brush are the same as if the brush's graphics data was stored as specified in the introductory paragraphs of \ref{gradients} and in \ref{gradients.radial}.

\pnum
\remarks
Sampling from this brush shall produce the results specified in \ref{brush.sampling.radial}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(image_surface&& img);
brush(image_surface&& img, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
The brush shall be a surface brush.

\pnum
The brush's brush type shall be set to the value \tcode{brush_type::surface}.

\pnum
The brush's tiling shall be set to the value \tcode{experimental::io2d::tiling::none}.

\pnum
The brush's filter shall be set to the value \tcode{experimental::io2d::filter::good}.

\pnum
The brush's transformation matrix shall be set to the value \tcode{matrix_2d::init_identity()}.

\pnum
The graphics data of the brush shall be the \underlyingimagesurface of \tcode{img}.

\pnum
\remarks
Sampling from this brush shall produce the results specified in \ref{brush.sampling.surface}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\rSec1 [brush.modifiers]{\tcode{brush} modifiers}

\indexlibrary{\idxcode{brush}!\idxcode{tiling}}
\indexlibrary{\idxcode{tiling}!\idxcode{brush}}
\begin{itemdecl}
void tiling(experimental::io2d::tiling e) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The brush's tiling shall be set to the value of \tcode{e}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{filter}}
\indexlibrary{\idxcode{filter}!\idxcode{brush}}
\begin{itemdecl}
void filter(experimental::io2d::filter f) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The brush's filter shall be set to the value \tcode{f}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{brush}}
\begin{itemdecl}
void matrix(const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The brush's transformation matrix shall be set to the value \tcode{m}.
\end{itemdescr}

\rSec1 [brush.observers]{\tcode{brush} observers}

\indexlibrary{\idxcode{brush}!\idxcode{tiling}}
\indexlibrary{\idxcode{tiling}!\idxcode{brush}}
\begin{itemdecl}
experimental::io2d::tiling tiling() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of brush's tiling.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{filter}}
\indexlibrary{\idxcode{filter}!\idxcode{brush}}
\begin{itemdecl}
experimental::io2d::filter filter() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of the brush's filter.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{brush}}
\begin{itemdecl}
matrix_2d matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of the brush's transformation matrix.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{type}}
\indexlibrary{\idxcode{type}!\idxcode{brush}}
\begin{itemdecl}
brush_type type() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The brush's brush type.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{surface}}
\indexlibrary{\idxcode{surface}!\idxcode{brush}}
\begin{itemdecl}
	const image_surface& surface() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	\tcode{*this.type() == brush_type::surface}.
	
	\pnum
	\returns
	A constant reference to the surface brush's \tcode{image_surface}.
\end{itemdescr}
