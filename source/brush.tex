%!TEX root = io2d.tex
\rSec0 [brush] {Class \tcode{brush}}

\rSec1 [brush.synopsis] {\tcode{brush} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class brush {
  public:
    // \ref{brush.cons}, construct/copy/move/destroy:
    brush() = delete;
    brush(const brush&) noexcept;
    brush& operator=(const brush&) noexcept;
    brush(brush&& other) noexcept;
    brush& operator=(brush&& other) noexcept;
    brush(const solid_color_brush_factory& f);
    brush(const solid_color_brush_factory& f, error_code& ec) noexcept;
    brush(const linear_brush_factory& f);
    brush(const linear_brush_factory& f, error_code& ec) noexcept;
    brush(const radial_brush_factory& f);
    brush(const radial_brush_factory& f, error_code& ec) noexcept;
    brush(surface_brush_factory& f);
    brush(surface_brush_factory& f, error_code& ec) noexcept;

    // \ref{brush.modifiers}, modifiers:
    void extend(experimental::io2d::extend e) noexcept;
    void filter(experimental::io2d::filter f) noexcept;
    void matrix(const matrix_2d& m) noexcept;

    // \ref{brush.observers}, observers:
    experimental::io2d::extend extend() const noexcept;
    experimental::io2d::filter filter() const noexcept;
    matrix_2d matrix() const noexcept;
    brush_type type() const noexcept;

  private:
    experimental::io2d::extend _Extend; // \expos
    experimental::io2d::filter _Filter; // \expos
    matrix_2d _Matrix;                         // \expos
    brush_type _Brush_type;                    // \expos
  };
} } } }
\end{codeblock}

\rSec1 [brush.intro] {\tcode{brush} Description}

\pnum
\indexlibrary{\idxcode{brush}}
The class \tcode{brush} describes an opaque wrapper for a raster graphics data graphics resource.

\pnum
A \tcode{brush} object shall be usable with any \tcode{surface} or \tcode{surface}-derived object.

\pnum
A \tcode{brush} object's graphics data is immutable.

\pnum
A \tcode{brush} object also has mutable \tcode{extend}, \tcode{filter}, and \tcode{matrix_2d} values which affect how the color and alpha data is used and interpreted.

\pnum
A \tcode{brush} object has immutable \tcode{brush_type} data which indicates the type of brush factory that was used in creating the \tcode{brush} object (See Table \ref{tab:brushtype.meanings}).

\pnum
The \tcode{brush} object's graphics data may have less precision than the graphics data of the brush factory object from which it was created.

\pnum
\enterexample
Several graphics and rendering technologies that are currently widely used store individual color and alpha channel data as 8-bit unsigned normalized integer values while the \tcode{double} type that is used by the \tcode{rgba_color} class for individual color and alpha is often a 64-bit value. It is precisely these situations which the preceding paragraph is intended to address.
\exitexample

\rSec1 [brush.cons] {\tcode{brush} constructors and assignment operators}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(const solid_color_brush_factory& f);
brush(const solid_color_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
The brush has uniform color and alpha data which is created from the value of \tcode{f.color()}. The precision and storage format of the color and alpha data is unspecified. The precision may be less than that  

\pnum
\postconditions
\tcode{_Brush_type == brush_type::solid_color}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\tcode{_Filter == std::experimental::io2d::filter::fast}.

\tcode{_Matrix == matrix_2d::init_identity()}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(const linear_brush_factory& f);
brush(const linear_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
\postconditions
\tcode{_Brush_type == brush_type::linear}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\tcode{_Filter == std::experimental::io2d::extend::good}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(const radial_brush_factory& f);
brush(const radial_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
\postconditions
\tcode{_Brush_type == brush_type::radial}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\tcode{_Filter == std::experimental::io2d::extend::good}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

%\indexlibrary{\idxcode{brush}!constructor}
%\begin{itemdecl}
%brush(const mesh_brush_factory& f);
%brush(const mesh_brush_factory& f, error_code& ec) noexcept;
%\end{itemdecl}
%\begin{itemdescr}
%\pnum
%\effects
%Constructs an object of type \tcode{brush}.
%
%\pnum
%\postconditions
%\tcode{_Brush_type == brush_type::mesh}.
%
%\tcode{_Extend == std::experimental::io2d::extend::none}.
%
%\tcode{_Filter == std::experimental::io2d::extend::good}.
%
%\tcode{_Extend == std::experimental::io2d::extend::none}.
%
%\pnum
%\throws
%As specified in Error reporting (\ref{\iotwod.err.report}).
%
%\pnum
%\errors
%\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
%
%\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
%\end{itemdescr}
%
\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
brush(surface_brush_factory& f);
brush(surface_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{brush}.

\pnum
\postconditions
\tcode{_Brush_type == brush_type::surface}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\tcode{_Filter == std::experimental::io2d::extend::good}.

\tcode{_Extend == std::experimental::io2d::extend::none}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.

\tcode{io2d_error::invalid_status} if there was a failure to allocate a resource other than memory.
\end{itemdescr}

\rSec1 [brush.modifiers]{\tcode{brush} modifiers}

\indexlibrary{\idxcode{brush}!\idxcode{extend}}
\indexlibrary{\idxcode{extend}!\idxcode{brush}}
\begin{itemdecl}
void extend(experimental::io2d::extend e) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the \tcode{extend} value for the \tcode{brush} object.

\pnum
\postconditions
\tcode{_Extend == e}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{filter}}
\indexlibrary{\idxcode{filter}!\idxcode{brush}}
\begin{itemdecl}
void filter(experimental::io2d::filter f) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the \tcode{filter} value for the \tcode{brush} object.

\pnum
\postconditions
\tcode{_Filter == f}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{brush}}
\begin{itemdecl}
void matrix(const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the \tcode{matrix_2d} value for the \tcode{brush} object.

\pnum
\postconditions
\tcode{_Matrix == m}.
\end{itemdescr}

\rSec1 [brush.observers]{\tcode{brush} observers}

\indexlibrary{\idxcode{brush}!\idxcode{extend}}
\indexlibrary{\idxcode{extend}!\idxcode{brush}}
\begin{itemdecl}
experimental::io2d::extend extend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{_Extend}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{filter}}
\indexlibrary{\idxcode{filter}!\idxcode{brush}}
\begin{itemdecl}
experimental::io2d::filter filter() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{_Filter}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{brush}}
\begin{itemdecl}
matrix_2d matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{_Matrix}.
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{type}}
\indexlibrary{\idxcode{type}!\idxcode{brush}}
\begin{itemdecl}
brush_type type() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{_Brush_type}.
\end{itemdescr}
