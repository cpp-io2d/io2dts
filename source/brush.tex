%!TEX root = io2d.tex
\rSec0 [\iotwod.brush] {Class \tcode{brush}}

\rSec1 [\iotwod.brush.synopsis] {\tcode{brush} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class brush {
  public:
    // \ref{\iotwod.brush.cons}, construct/copy/move/destroy:
    brush() = delete;
    brush(const brush&) noexcept;
    brush& operator=(const brush&) noexcept;
    brush(brush&& other) noexcept;
    brush& operator=(brush&& other) noexcept;
    brush(const solid_color_brush_factory& f);
    brush(const solid_color_brush_factory& f, error_code& ec) noexcept;
    brush(const linear_brush_factory& f);
    brush(const linear_brush_factory& f, error_code& ec) noexcept;
    brush(const radial_brush_factory& f);
    brush(const radial_brush_factory& f, error_code& ec) noexcept;
    brush(const mesh_brush_factory& f);
    brush(const mesh_brush_factory& f, error_code& ec) noexcept;
    brush(surface_brush_factory& f);
    brush(surface_brush_factory& f, error_code& ec) noexcept;

    // \ref{\iotwod.brush.modifiers}, modifiers:
    void extend(experimental::io2d::extend e) noexcept;
    void filter(experimental::io2d::filter f) noexcept;
    void matrix(const matrix_2d& m) noexcept;

    // \ref{\iotwod.brush.observers}, observers:
    experimental::io2d::extend extend() const noexcept;
    experimental::io2d::filter filter() const noexcept;
    matrix_2d matrix() const noexcept;
    brush_type type() const noexcept;

  private:
    experimental::io2d::extend _Extend; // \expos
    experimental::io2d::filter _Filter; // \expos
    matrix_2d _Matrix;                         // \expos
    brush_type _Brush_type;                    // \expos
  };
} } } }
\end{codeblock}

\rSec1 [\iotwod.brush.intro] {\tcode{brush} Description}

\pnum
\indexlibrary{\idxcode{brush}}
The class \tcode{brush} describes an opaque resource wrapper for color and alpha data.

\pnum
A \tcode{brush} object shall be usable with any \tcode{surface} or \tcode{surface}-derived object.

\pnum
A \tcode{brush} object's color and alpha data is immutable.

\pnum
A \tcode{brush} object also has mutable \tcode{extend}, \tcode{filter}, and \tcode{matrix_2d} values which affect how the color and alpha data is used and interpreted.

\pnum
Lastly, a \tcode{brush} object has immutable \tcode{brush_type} data which indicates the type of brush factory which was used in creating the \tcode{brush} object.

\pnum
A \tcode{brush} object is usable as the color and alpha source for a surface's stroke, fill, mask, paint, and text rendering operations. See \ref{\iotwod.surface.modifiers.render} for more information.

\pnum
It is also usable as the mask for a surface's mask operation. Its alpha channel is used as the mask. See the description of \tcode{surface::mask} (\ref{\iotwod.surface.modifiers.render}) for more information.

\pnum
The internal storage format of a \tcode{brush} object's color and alpha data is unspecified.

\pnum
The \tcode{brush} object's color and alpha data may have less precision than the data of the brush factory object from which it was created.

\pnum
\enterexample
Several graphics and rendering technologies that are currently widely used store individual color and alpha channel data as 32-bit \tcode{float} values while \Cpp implementations that support using those technologies represent the \tcode{double} type that is used by \tcode{rgba_color} for individual color and alpha channels as a 64-bit value. It is precisely these situations which the preceding paragraph is intended to address.
\exitexample

\rSec1 [\iotwod.brush.extend] {Effects of its \tcode{extend} value on a \tcode{brush} object}

\pnum
In general, the effects of the \tcode{extend} value on a \tcode{brush} object are documented in \ref{\iotwod.extend}.

\pnum
The initial \tcode{extend} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.

\pnum
If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::mesh}, the \tcode{brush}'s \tcode{extend} value is ignored and all operations proceed as if the \tcode{extend} value is \tcode{extend::none}.

\rSec1 [\iotwod.brush.filter] {Effects of its \tcode{filter} value of a \tcode{brush} object}

\pnum
The effects of the \tcode{filter} value on a \tcode{brush} object are documented in \ref{\iotwod.filter}.

\pnum
The initial \tcode{filter} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.

\rSec1 [\iotwod.brush.matrix] {Effects of its \tcode{matrix_2d} value on a \tcode{brush} object}

\pnum
The initial \tcode{matrix_2d} value of a \tcode{brush} object is \tcode{matrix_2d::init_identity()}.

\pnum
If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::solid_color}, the brush is treated as if its data area is an infinite plane. As such\ the \tcode{brush}'s \tcode{extend}, \tcode{filter}, and \tcode{matrix_2d} values do not matter. Regardless of the coordinate from which data from the \tcode{brush} is requested, the \tcode{brush} will always return the color which the \tcode{solid_color_brush_factory} that was used to create it had at the time the \tcode{brush} was created.

\pnum
All brushes except \tcode{brush_type::solid_color} brushes are sensitive to coordinates and as such will need to have an appropriate \tcode{matrix_2d} value to achieve the desired outcome.

\pnum
\enternote
Sometimes the initial \tcode{matrix_2d} value will be the appropriate value. As such there is no requirement to set a \tcode{matrix_2d} value unless you need something other than the initial value.
\exitnote

\pnum
When it is necessary for the implementation to retrieve data from a \tcode{brush} object to calculate the resulting color value of a coordinate on a \tcode{surface}, the coordinate is first transformed using the \tcode{brush} object's \tcode{matrix_2d}.

\pnum
A \tcode{brush} object's \tcode{matrix_2d} value transforms a coordinate from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space.

\pnum
\enterexample
Take a \tcode{brush b} which has a \tcode{matrix_2d} value of \tcode{matrix_2d::init_scale(\{ 2.0, 0.25 \})}.

\pnum
If a request for data from \tcode{b} at the point \tcode{vector_2d(30.0, 18.0)} is made, by operation of \tcode{b}'s \tcode{matrix_2d}, the actual data that will be retrieved is the data at \tcode{vector_2d(60.0, 4.5)} (after application of \tcode{b}'s \tcode{extend} value as described above).

\pnum
Notice that although the \xaxis scale is set to \tcode{2.0} and the \yaxis scale is set to \tcode{0.25}, the actual effect is the same as if the \tcode{b}'s data itself had been scaled to the inverse of those values. This is because the transformation goes from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space rather than from the \tcode{brush}'s coordinate space to the \tcode{surface}'s coordinate space.
\exitexample

\pnum
\enternote
For the same reason as explained in the example above, if you wish to translate the origin point of a \tcode{brush} to the point \tcode{vector_2d p} of a \tcode{surface}, you would do so by setting \tcode{matrix_2d::init_translate(-p)} as the brush's \tcode{matrix_2d} value.
\exitnote

\rSec1 [\iotwod.brush.cons] {\tcode{brush} constructors and assignment operators}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
    brush(const solid_color_brush_factory& f);
    brush(const solid_color_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{brush}.
	
	\pnum
	The brush has uniform color and alpha data which is created from the value of \tcode{f.color()}. The precision and storage format of the color and alpha data is unspecified. The precision may be less than that  
	
	\pnum
	\postconditions
	\tcode{_Brush_type == brush_type::solid_color}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.
	
	\tcode{_Filter == std::experimental::io2d::filter::fast}.
	
	\tcode{_Matrix == matrix_2d::init_identity()}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
	
	\tcode{errc::protocol_error} if there was a failure to allocate a resource other than memory.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
    brush(const linear_brush_factory& f);
    brush(const linear_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{brush}.
	
	\pnum
	\postconditions
	\tcode{_Brush_type == brush_type::linear}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.
	
	\tcode{_Filter == std::experimental::io2d::extend::good}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
	
	\tcode{errc::protocol_error} if there was a failure to allocate a resource other than memory.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
    brush(const radial_brush_factory& f);
    brush(const radial_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{brush}.
	
	\pnum
	\postconditions
	\tcode{_Brush_type == brush_type::radial}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.
	
	\tcode{_Filter == std::experimental::io2d::extend::good}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
	
	\tcode{errc::protocol_error} if there was a failure to allocate a resource other than memory.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
    brush(const mesh_brush_factory& f);
    brush(const mesh_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{brush}.
	
	\pnum
	\postconditions
	\tcode{_Brush_type == brush_type::mesh}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.
	
	\tcode{_Filter == std::experimental::io2d::extend::good}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
	
	\tcode{errc::protocol_error} if there was a failure to allocate a resource other than memory.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!constructor}
\begin{itemdecl}
    brush(surface_brush_factory& f);
    brush(surface_brush_factory& f, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{brush}.
	
	\pnum
	\postconditions
	\tcode{_Brush_type == brush_type::surface}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.
	
	\tcode{_Filter == std::experimental::io2d::extend::good}.
	
	\tcode{_Extend == std::experimental::io2d::extend::none}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
	
	\tcode{errc::protocol_error} if there was a failure to allocate a resource other than memory.
	
\end{itemdescr}

\rSec1 [\iotwod.brush.modifiers]{\tcode{brush} modifiers}

\indexlibrary{\idxcode{brush}!\idxcode{extend}}
\indexlibrary{\idxcode{extend}!\idxcode{brush}}
\begin{itemdecl}
    void extend(experimental::io2d::extend e) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the \tcode{extend} value for the brush.
	
	\pnum
	\postconditions
	\tcode{_Extend == e}.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{filter}}
\indexlibrary{\idxcode{filter}!\idxcode{brush}}
\begin{itemdecl}
    void filter(experimental::io2d::filter f) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the \tcode{filter} value for the brush.
	
	\pnum
	\postconditions
	\tcode{_Filter == f}.
	
\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{brush}}
\begin{itemdecl}
    void matrix(const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the \tcode{matrix_2d} value for the brush.
	
	\pnum
	\postconditions
	\tcode{_Matrix == m}.
	
\end{itemdescr}

\rSec1 [\iotwod.brush.observers]{\tcode{brush} observers}

\indexlibrary{\idxcode{brush}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{brush}}
\begin{itemdecl}
    experimental::io2d::extend extend() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Extend}.

\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{brush}}
\begin{itemdecl}
    experimental::io2d::filter filter() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Filter}.

\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{brush}}
\begin{itemdecl}
    matrix_2d matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Matrix}.

\end{itemdescr}

\indexlibrary{\idxcode{brush}!\idxcode{type}}
\indexlibrary{\idxcode{type}!\idxcode{brush}}
\begin{itemdecl}
    brush_type type() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Brush_type}.

\end{itemdescr}
