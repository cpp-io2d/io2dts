%!TEX root = io2d.tex
\rSec0 [\iotwod.\matrixtwod] {Class \tcode{matrix_2d}}

\rSec1 [\iotwod.\matrixtwod.intro] {\tcode{matrix_2d} description}

\indexlibrary{\idxcode{matrix_2d}}%
\pnum
The \tcode{matrix_2d} class represents a three row by three column matrix. Its purpose is to perform affine transformations.

\pnum
The matrix is composed of nine \tcode{float} values: \tcode{m00}, \tcode{m01}, \tcode{m02}, \tcode{m10}, \tcode{m11}, \tcode{m12}, \tcode{m20}, \tcode{m21}, and \tcode{m22}. The ordering of these \tcode{float} values in the \tcode{matrix_2d} class is unspecified.

\pnum
The specification of the \tcode{matrix_2d} class, as described in this subclause, uses the following ordering: \\
$
~[~[~m00~m01~m02~]~] \\
~[~[~m10~m11~m12~]~] \\
~[~[~m20~m21~m22~]~]$

\pnum
\begin{note}
The naming convention and the layout shown above are consistent with a row-major layout. Though the naming convention is fixed, the unspecified layout allows for a column-major layout (or any other layout, though row-major and column-major are the only layouts typically used).
\end{note}

\pnum
The performance of any mathematical operation upon a \tcode{matrix_2d} shall be carried out as-if the omitted third column data members were present with the values prescribed in the previous paragraph.

\rSec1 [\iotwod.\matrixtwod.synopsis] {\tcode{matrix_2d} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class matrix_2d {
  public:
    // \ref{\iotwod.\matrixtwod.cons}, construct:
    constexpr matrix_2d() noexcept;
    constexpr matrix_2d(float v00, float v01, float v10, float v11,
      float v20, float v21) noexcept;

    // member data (order is exposition only \ref{\iotwod.\matrixtwod.intro}):
    float m00;
    float m01;
    float m02;
    float m10;
    float m11;
    float m12;
    float m20;
    float m21;
    float m22;
    
    // \ref{\iotwod.\matrixtwod.staticfactories}, static factory functions:
    constexpr static matrix_2d init_translate(point_2d value) noexcept;
    constexpr static matrix_2d init_scale(point_2d value) noexcept;
    static matrix_2d init_rotate(float radians) noexcept;
    static matric_2d init_rotate(float radians, point_2d origin) noexcept;
    static matrix_2d init_reflect(float radians) noexcept;
    constexpr static matrix_2d init_shear_x(float factor) noexcept;
    constexpr static matrix_2d init_shear_y(float factor) noexcept;
    
    // \ref{\iotwod.\matrixtwod.modifiers}, modifiers:
    constexpr matrix_2d& translate(point_2d v) noexcept;
    constexpr matrix_2d& scale(point_2d v) noexcept;
    matrix_2d& rotate(float radians) noexcept;
    matrix_2d& rotate(float radians, point_2d origin) noexcept;
    matrix_2d& reflect(float radians) noexcept;
    constexpr matrix_2d& shear_x(float factor) noexcept;
    constexpr matrix_2d& shear_y(float factor) noexcept;
    
    // \ref{\iotwod.\matrixtwod.observers}, observers:
    constexpr bool is_finite() const noexcept;
    constexpr bool is_invertible() const noexcept;
    constexpr float determinant() const noexcept;
    constexpr matrix_2d inverse() const noexcept;
    constexpr point_2d transform_pt(point_2d pt) const noexcept;
    
    // \ref{\iotwod.\matrixtwod.member.ops}, matrix_2d member operators:
    constexpr matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
  };
    
  // \ref{\iotwod.\matrixtwod.ops}, matrix_2d non-member operators:
  constexpr matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr bool operator==(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr point_2d operator*(point_2d v, const matrix_2d& m) 
    noexcept;
}
\end{codeblock}

\rSec1 [\iotwod.\matrixtwod.cons] {\tcode{matrix_2d} constructors}

\indexlibrary{\idxcode{matrix_2d}!constructor}%
\begin{itemdecl}
constexpr matrix_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{matrix_2d\{ 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f \}}.

\pnum
\begin{note}
The resulting matrix is the identity matrix.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!constructor}%
\begin{itemdecl}
constexpr matrix_2d(float v00, float v01, float v10, float v11,
  float v20, float v21) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{matrix_2d}.

\pnum
\tcode{m00 == v00}, \tcode{m01 == v01}, \tcode{m02 == 0.0f}, \tcode{m10 == v10}, \tcode{m11 == v11}, \tcode{m12 == 0.0f}, \tcode{m20 == v20}, \tcode{m21 == v21}, \tcode{m22 == 1.0f}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.staticfactories] {\tcode{matrix_2d} static factory 
functions}

\indexlibrarymember{init_translate}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_translate(point_2d value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix_2d(1.0f, 0.0f, 0.0f, 1.0f, value.x, value.y)}.
\end{itemdescr}

\indexlibrarymember{init_scale}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_scale(point_2d value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix_2d(value.x, 0.0f, 0.0f, value.y, 0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_rotate}{matrix_2d}%
\begin{itemdecl}
static matrix_2d init_rotate(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix_2d(cos(radians), -sin(radians), sin(radians), cos(radians), 
0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_rotate}{matrix_2d}%
\begin{itemdecl}
static matrix_2d init_rotate(float radians, point_2d origin) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to:
\begin{codeblock}
return matrix_2d(
  matrix_2d::init_translate(origin).rotate(radians).translate(-origin));
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{init_reflect}{matrix_2d}%
\begin{itemdecl}
static matrix_2d init_reflect(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
\end{codeblock}
matrix_2d(cos(radians * 2.0f), sin(radians * 2.0f), sin(radians * 2.0f),
  -cos(radians * 2.0f), 0.0f, 0.0f)
\end{itemdescr}

\indexlibrarymember{init_shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_shear_x(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix_2d(1.0f, 0.0f, factor, 1.0f, 0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_shear_y(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix_2d(1.0f, factor, 0.0f, 1.0f, 0.0f, 0.0f)}
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.modifiers] {\tcode{matrix_2d} modifiers}

\indexlibrarymember{translate}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& translate(point_2d val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_translate(val);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{scale}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& scale(point_2d val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_scale(val);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{rotate}{matrix_2d}%
\begin{itemdecl}
matrix_2d& rotate(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_rotate(radians);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{rotate}{matrix_2d}%
\begin{itemdecl}
matrix_2d& rotate(float radians, point_2d origin) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_rotate(radians, origin);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{reflect}{matrix_2d}%
\begin{itemdecl}
matrix_2d& reflect(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_reflect(radians);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{shear_x}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& shear_x(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_shear_x(factor);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& shear_y(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_shear_y(factor);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.observers] {\tcode{matrix_2d} observers}

\indexlibrarymember{is_finite}{matrix_2d}%
\begin{itemdecl}
constexpr bool is_finite() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{true} if the observable behavior of all of the following expressions evaluates to true:
\begin{itemize}
\item \tcode{isfinite(m00);}
\item \tcode{isfinite(m01);}
\item \tcode{isfinite(m10);}
\item \tcode{isfinite(m11);}
\item \tcode{isfinite(m20);}
\item \tcode{isfinite(m21);}
\end{itemize}

\pnum
Otherwise returns \tcode{false}.

\pnum
\begin{note}
The specification of \tcode{isfinite} in \cppseventeen does not include the \tcode{constexpr} specifier. Regardless, the requirements stated in [library.c] and [c.math.fpclass] in \cppseventeen make it possible to implement a constexpr function that produces the observable behavior of \tcode{isfinite}. As a result, this function can be implemented as a constexpr function.
\end{note}
\end{itemdescr}

\indexlibrarymember{is_invertible}{matrix_2d}%
\begin{itemdecl}
constexpr bool is_invertible() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_finite()} is \tcode{true}.

\pnum
\returns
\tcode{determinant() != 0.0f}.
\end{itemdescr}

\indexlibrarymember{inverse}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d inverse() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_invertible()} is \tcode{true}.

\pnum
\returns
Let \tcode{inverseDeterminant} be \tcode{1.0f / determinant()}.

\begin{codeblock}
return matrix_2d{
   (m11 * 1.0f - 0.0f * m21) * inverseDeterminant,
  -(m01 * 1.0f - 0.0f * m21) * inverseDeterminant,
  -(m10 * 1.0f - 0.0f * m20) * inverseDeterminant,
   (m00 * 1.0f - 0.0f * m20) * inverseDeterminant,
   (m10 * m21 - m11 * m20) * inverseDeterminant,
  -(m00 * m21 - m01 * m20) * inverseDeterminant
};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{determinant}{matrix_2d}%
\begin{itemdecl}
constexpr float determinant() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_finite()} is \tcode{true}.

\pnum
\returns
\tcode{m00 * m11 - m01 * m10}.
\end{itemdescr}

\indexlibrarymember{transform_pt}{matrix_2d}%
\begin{itemdecl}
constexpr point_2d transform_pt(point_2d pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{point_2d((m00 * pt.x + m10 * pt.y) + m20, (m01 * pt.x + m11 * pt.y) + m21)}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.member.ops] {\tcode{matrix_2d} member operators}

\indexlibrarymember{operator*=}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * rhs;}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.ops] {\tcode{matrix_2d} non-member operators}

\indexlibrarymember{operator*}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
matrix_2d{
  lhs.m00 * rhs.m00 + lhs.m01 * rhs.m10,
  lhs.m00 * rhs.m01 + lhs.m01 * rhs.m11,
  lhs.m10 * rhs.m00 + lhs.m11 * rhs.m10,
  lhs.m10 * rhs.m01 + lhs.m11 * rhs.m11,
  lhs.m20 * rhs.m00 + lhs.m21 * rhs.m10 + lhs.m20,
  lhs.m20 * rhs.m01 + lhs.m21 * rhs.m11 + lhs.m21
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{matrix_2d}%
\begin{itemdecl}
constexpr bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.m00 == rhs.m00 && lhs.m01 == rhs.m01 && 
lhs.m10 == rhs.m10 && lhs.m11 == rhs.m11 &&
lhs.m20 == rhs.m20 && lhs.m21 == rhs.m21
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator*}{matrix_2d}%
\begin{itemdecl}
constexpr point_2d operator*(point_2d v, const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{m.transform_pt(v)}.
\end{itemdescr}
