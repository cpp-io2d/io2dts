%!TEX root = io2d.tex
\rSec0 [\iotwod.\matrixtwod] {Class \tcode{matrix_2d}}

\rSec1 [\iotwod.\matrixtwod.intro] {\tcode{matrix_2d} description}

\indexlibrary{\idxcode{matrix_2d}}%
\pnum
The \tcode{matrix_2d} class represents a two-dimensional, three row by three column matrix. Its purpose is to perform affine transformations.

\pnum
The layout of the matrix is: \\
$
~[~[~M00~M01~M02~]~] \\
~[~[~M10~M11~M12~]~] \\
~[~[~M20~M21~M22~]~]$

\pnum
The value of M02 is \tcode{0.0f}. The value of M12 is \tcode{0.0f}. The value of M22 is \tcode{1.0f}. None of the operations on a \tcode{matrix_2d} object can modify the values of M02, M12, and M22. As such they are not part of the observable state of a \tcode{matrix_2d} object.

\pnum
The performance of any mathematical operation upon a \tcode{matrix_2d} shall be carried out as-if the omitted third column data members were present with the values prescribed in the previous paragraph.

\pnum
The values M00, M01, M10, M11, M20, M21 shall each be of type \tcode{float}.

\rSec1 [\iotwod.\matrixtwod.synopsis] {\tcode{matrix_2d} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class matrix_2d {
  public:
    // \ref{\iotwod.\matrixtwod.cons}, construct:
    constexpr matrix_2d() noexcept;
    constexpr matrix_2d(float v00, float v01, float v10, float v11,
      float v20, float v21) noexcept;
    
    // \ref{\iotwod.\matrixtwod.staticfactories}, static factory functions:
    constexpr static matrix_2d init_translate(const vector_2d& value) noexcept;
    constexpr static matrix_2d init_scale(const vector_2d& value) noexcept;
    static matrix_2d init_rotate(float radians) noexcept;
    static matrix_2d init_reflect(float radians) noexcept;
    constexpr static matrix_2d init_shear_x(float factor) noexcept;
    constexpr static matrix_2d init_shear_y(float factor) noexcept;
    
    // \ref{\iotwod.\matrixtwod.modifiers}, modifiers:
    constexpr void m00(float v) noexcept;
    constexpr void m01(float v) noexcept;
    constexpr void m10(float v) noexcept;
    constexpr void m11(float v) noexcept;
    constexpr void m20(float v) noexcept;
    constexpr void m21(float v) noexcept;
    constexpr matrix_2d& translate(const vector_2d& v) noexcept;
    constexpr matrix_2d& scale(const vector_2d& v) noexcept;
    matrix_2d& rotate(float radians) noexcept;
    matrix_2d& reflect(float radians) noexcept;
    constexpr matrix_2d& shear_x(float factor) noexcept;
    constexpr matrix_2d& shear_y(float factor) noexcept;
    
    // \ref{\iotwod.\matrixtwod.observers}, observers:
    constexpr float m00() const noexcept;
    constexpr float m01() const noexcept;
    constexpr float m10() const noexcept;
    constexpr float m11() const noexcept;
    constexpr float m20() const noexcept;
    constexpr float m21() const noexcept;
    constexpr bool is_finite() const noexcept;
    constexpr bool is_invertible() const noexcept;
    constexpr float determinant() const noexcept;
    constexpr matrix_2d inverse() const noexcept;
    constexpr vector_2d transform_point(const vector_2d& pt) const noexcept;
    
    // \ref{\iotwod.\matrixtwod.member.ops}, matrix_2d member operators:
    constexpr matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
  };
    
  // \ref{\iotwod.\matrixtwod.ops}, matrix_2d non-member operators:
  constexpr matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr bool operator==(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs)
    noexcept;
  constexpr vector_2d operator*(const vector_2d& v, const matrix_2d& m) 
    noexcept;
}
\end{codeblock}

\rSec1 [\iotwod.\matrixtwod.cons] {\tcode{matrix_2d} constructors}

\indexlibrary{\idxcode{matrix_2d}!constructor}%
\begin{itemdecl}
constexpr matrix_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{matrix_2d\{ 1.0f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f \}}.

\pnum
\begin{note}
The resulting matrix is the identity matrix.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!constructor}%
\begin{itemdecl}
constexpr matrix_2d(float v00, float v01, float v10, float v11,
  float v20, float v21) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Constructs an object of type \tcode{matrix_2d}.

\pnum
As-if the resulting matrix was: \\
$
~[~[~v00~v01~0.0f~]~] \\
~[~[~v10~v11~0.0f~]~] \\
~[~[~v20~v21~1.0f~]~]$

\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.staticfactories] {\tcode{matrix_2d} static factory 
functions}

\indexlibrarymember{init_translate}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_translate(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix(1.0f, 0.0f, 0.0f, 1.0f, value.x(), value.y())}.
\end{itemdescr}

\indexlibrarymember{init_scale}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_scale(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix(value.x(), 0.0f, 0.0f, value.y(), 0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_rotate}{matrix_2d}%
\begin{itemdecl}
static matrix_2d init_rotate(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix(cos(radians), -sin(radians), sin(radians), cos(radians), 
0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_reflect}{matrix_2d}%
\begin{itemdecl}
static matrix_2d init_reflect(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
\end{codeblock}
matrix(cos(radians * 2.0f), sin(radians * 2.0f), sin(radians * 2.0f),
  -cos(radians * 2.0f), 0.0f, 0.0f)
\end{itemdescr}

\indexlibrarymember{init_shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_shear_x(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix(1.0f, 0.0f, factor, 1.0f, 0.0f, 0.0f)}.
\end{itemdescr}

\indexlibrarymember{init_shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr static matrix_2d init_shear_y(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{matrix\{ 1.0f, factor, 0.0f, 1.0f, 0.0f, 0.0f \}}
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.modifiers] {\tcode{matrix_2d} modifiers}

\indexlibrarymember{m00}{matrix_2d}%
\begin{itemdecl}
constexpr void m00(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M00 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{m01}{matrix_2d}%
\begin{itemdecl}
constexpr void m01(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M01 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{m10}{matrix_2d}%
\begin{itemdecl}
constexpr void m10(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M10 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{m11}{matrix_2d}%
\begin{itemdecl}
constexpr void m11(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M11 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{m20}{matrix_2d}%
\begin{itemdecl}
constexpr void m20(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M20 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{m21}{matrix_2d}%
\begin{itemdecl}
constexpr void m21(float val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
M21 is \tcode{val}.
\end{itemdescr}

\indexlibrarymember{translate}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& translate(const vector_2d& val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_translate(val);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{scale}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& scale(const vector_2d& val) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_scale(val);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{rotate}{matrix_2d}%
\begin{itemdecl}
matrix_2d& rotate(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_rotate(radians);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{reflect}{matrix_2d}%
\begin{itemdecl}
matrix_2d& reflect(float radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_reflect(radians);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{shear_x}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& shear_x(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_shear_x(factor);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\indexlibrarymember{shear_y}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& shear_y(float factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: \tcode{*this = *this * init_shear_y(factor);}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.observers] {\tcode{matrix_2d} observers}

\indexlibrarymember{m00}{matrix_2d}%
\begin{itemdecl}
constexpr float m00() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M00.
\end{itemdescr}

\indexlibrarymember{m01}{matrix_2d}%
\begin{itemdecl}
constexpr float m01() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M01.
\end{itemdescr}

\indexlibrarymember{m10}{matrix_2d}%
\begin{itemdecl}
constexpr float m10() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M10.
\end{itemdescr}

\indexlibrarymember{m11}{matrix_2d}%
\begin{itemdecl}
constexpr float m11() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M11.
\end{itemdescr}

\indexlibrarymember{m20}{matrix_2d}%
\begin{itemdecl}
constexpr float m20() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M20.
\end{itemdescr}

\indexlibrarymember{m21}{matrix_2d}%
\begin{itemdecl}
constexpr float m21() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
M21.
\end{itemdescr}

\indexlibrarymember{is_finite}{matrix_2d}%
\begin{itemdecl}
constexpr bool is_finite const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{true} if the observable behavior of all of the following expressions evaluates to true:
\begin{itemize}
\item \tcode{isfinite(m00());}
\item \tcode{isfinite(m01());}
\item \tcode{isfinite(m10());}
\item \tcode{isfinite(m11());}
\item \tcode{isfinite(m20());}
\item \tcode{isfinite(m21());}
\end{itemize}

\pnum
Otherwise returns \tcode{false}.

\pnum
\begin{note}
The specification of \tcode{isfinite} in \cppseventeen does not include the \tcode{constexpr} specifier. Regardless, the requirements stated in [library.c] and [c.math.fpclass] in \cppseventeen make it possible to implement a constexpr function that produces the observable behavior of \tcode{isfinite}. As a result, this function can be implemented as a constexpr function.
\end{note}
\end{itemdescr}

\indexlibrarymember{is_invertible}{matrix_2d}%
\begin{itemdecl}
constexpr bool is_invertible() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_finite()} is \tcode{true}.

\pnum
\returns
\tcode{determinant() != 0.0f}.
\end{itemdescr}

\indexlibrarymember{inverse}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d inverse() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_invertible()} is \tcode{true}.

\pnum
\returns
Let \tcode{inverseDeterminant} be \tcode{1.0f / determinant()}.

\begin{codeblock}
return matrix_2d{
   (_M11 * 1.0f - 0.0f * _M21) * inverseDeterminant,
  -(_M01 * 1.0f - 0.0f * _M21) * inverseDeterminant,
  -(_M10 * 1.0f - 0.0f * _M20) * inverseDeterminant,
   (_M00 * 1.0f - 0.0f * _M20) * inverseDeterminant,
   (_M10 * _M21 - _M11 * _M20) * inverseDeterminant,
  -(_M00 * _M21 - _M01 * _M20) * inverseDeterminant
};
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{determinant}{matrix_2d}%
\begin{itemdecl}
constexpr float determinant() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\requires
\tcode{is_finite()} is \tcode{true}.

\pnum
\returns
\tcode{m00() * m11() - m01() * m10()}.
\end{itemdescr}

\indexlibrarymember{transform_point}{matrix_2d}%
\begin{itemdecl}
constexpr vector_2d transform_point(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{vector_2d((m00() * pt.x() + m10() * pt.y()) + m20(), (m01() * pt.x() + m11() * pt.y()) + m21())}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.member.ops] {\tcode{matrix_2d} member operators}

\indexlibrarymember{operator*=}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Equivalent to: {*this = *this * rhs;}

\pnum
\returns
\tcode{*this}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.ops] {\tcode{matrix_2d} non-member operators}

\indexlibrarymember{operator*}{matrix_2d}%
\begin{itemdecl}
constexpr matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
matrix_2d{
  lhs.m00() * rhs.m00() + lhs.m01() * rhs.m10(),
  lhs.m00() * rhs.m01() + lhs.m01() * rhs.m11(),
  lhs.m10() * rhs.m00() + lhs.m11() * rhs.m10(),
  lhs.m10() * rhs.m01() + lhs.m11() * rhs.m11(),
  lhs.m20() * rhs.m00() + lhs.m21() * rhs.m10() + lhs.m20(),
  lhs.m20() * rhs.m01() + lhs.m21() * rhs.m11() + lhs.m21()
}
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator==}{matrix_2d}%
\begin{itemdecl}
constexpr bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\begin{codeblock}
lhs.m00() == rhs.m00() && lhs.m01() == rhs.m01() && 
lhs.m10() == rhs.m10() && lhs.m11() == rhs.m11() &&
lhs.m20() == rhs.m20() && lhs.m21() == rhs.m21()
\end{codeblock}
\end{itemdescr}

\indexlibrarymember{operator!=}{matrix_2d}%
\begin{itemdecl}
constexpr bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
\tcode{!(lhs == rhs)}.
\end{itemdescr}


\indexlibrarymember{operator*}{matrix_2d}%
\begin{itemdecl}
constexpr vector_2d operator*(const vector_2d& v, const matrix_2d& m) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
Equivalent to: \tcode{m.transform_point(v)}.
\end{itemdescr}
