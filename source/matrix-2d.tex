%!TEX root = io2d.tex
\rSec0 [\iotwod.\matrixtwod] {Class \tcode{matrix_2d}}

\rSec1 [\iotwod.\matrixtwod.synopsis] {\tcode{matrix_2d} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class matrix_2d {
  public:
    // \ref{\iotwod.\matrixtwod.cons}, construct/copy/move/destroy:
    matrix_2d() noexcept;
    matrix_2d(const matrix_2d& other) noexcept;
    matrix_2d& operator=(const matrix_2d& other) noexcept;
    matrix_2d(matrix_2d&& other) noexcept;
    matrix_2d& operator=(matrix_2d&& other) noexcept;
    matrix_2d(double v00, double v01, double v10, double v11,
      double v20, double v21) noexcept;
    
    // \ref{\iotwod.\matrixtwod.staticfactories}, static factory functions:
    static matrix_2d init_identity() noexcept;
    static matrix_2d init_translate(const vector_2d& value) noexcept;
    static matrix_2d init_scale(const vector_2d& value) noexcept;
    static matrix_2d init_rotate(double radians) noexcept;
    static matrix_2d init_shear_x(double factor) noexcept;
    static matrix_2d init_shear_y(double factor) noexcept;
    
    // \ref{\iotwod.\matrixtwod.modifiers}, modifiers:
    void m00(double value) noexcept;
    void m01(double value) noexcept;
    void m10(double value) noexcept;
    void m11(double value) noexcept;
    void m20(double value) noexcept;
    void m21(double value) noexcept;
    matrix_2d& translate(const vector_2d& value) noexcept;
    matrix_2d& scale(const vector_2d& value) noexcept;
    matrix_2d& rotate(double radians) noexcept;
    matrix_2d& shear_x(double factor) noexcept;
    matrix_2d& shear_y(double factor) noexcept;
    matrix_2d& invert();
    matrix_2d& invert(::std::error_code& ec) noexcept;
    
    // \ref{\iotwod.\matrixtwod.observers}, observers:
    double m00() const noexcept;
    double m01() const noexcept;
    double m10() const noexcept;
    double m11() const noexcept;
    double m20() const noexcept;
    double m21() const noexcept;
    double determinant() const;
    double determinant(::std::error_code& ec) const noexcept;
    vector_2d transform_distance(const vector_2d& dist) const noexcept;
    vector_2d transform_point(const vector_2d& pt) const noexcept;
    
    // \ref{\iotwod.\matrixtwod.member.ops}, matrix_2d member operators:
    matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
  private:
    double _M00; // \expos
    double _M01; // \expos
    double _M10; // \expos
    double _M11; // \expos
    double _M20; // \expos
    double _M21; // \expos
  };
    
  // \ref{\iotwod.\matrixtwod.ops}, matrix_2d non-member operators:
  matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
  bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
  bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
} } } }
\end{codeblock}

\rSec1 [\iotwod.\matrixtwod.intro] {\tcode{matrix_2d} Description}

\pnum
\indexlibrary{\idxcode{matrix_2d}}%
The \tcode{matrix_2d} class represents a two-dimensional, three row by three column, row-major matrix. Its purpose is to perform affine transformations.

\pnum
Mathematically, regardless of the operations performed on a \tcode{matrix_2d}, the third column will always have the column vector value of $[0.0, 0.0, 1.0]$. As such, it is not included in the observable data of the matrix.

\pnum
The performance of any mathematical operation upon a \tcode{matrix_2d} shall be carried out as if the omitted third column data members were present with the values prescribed in the previous paragraph.

\pnum
\enternote
If the third column's data members were included, they would be:

\begin{itemize}
	\item \tcode{m02}, a \tcode{double} which would follow \tcode{m01} in the same row and would be assigned a value of \tcode{0.0}.
	
	\item \tcode{m12}, a \tcode{double} which would follow \tcode{m11} in the same row and would be assigned a value of \tcode{0.0}.
	
	\item \tcode{m22}, a \tcode{double} which would follow \tcode{m21} in the same row and would be assigned a value of \tcode{1.0}.
\end{itemize}

\pnum
The layout of the resulting matrix would be as such: \\
$
~[~[~m00~m01~m02~]~] \\
~[~[~m10~m11~m12~]~] \\
~[~[~m20~m21~m22~]~]$
\exitnote

\rSec1 [\iotwod.\matrixtwod.cons] {\tcode{matrix_2d} constructors and assignment operators}

\indexlibrary{\idxcode{matrix_2d}!constructor}
\begin{itemdecl}
	matrix_2d() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{matrix_2d}.
	
	\pnum
	\postconditions
	\tcode{_M00 == 1.0}.
	
	\pnum
	\tcode{_M01 == 0.0}.
	
	\pnum
	\tcode{_M10 == 0.0}.
	
	\pnum
	\tcode{_M11 == 1.0}.
	
	\pnum
	\tcode{_M20 == 0.0}.
	
	\pnum
	\tcode{_M21 == 0.0}.
	
	\pnum
	\realnote
	The resulting matrix is the identity matrix, which can also be obtained from \tcode{matrix_2d::init_identity()}.

\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!constructor}
\begin{itemdecl}
    matrix_2d(double v00, double v01, double v10, double v11,
      double v20, double v21) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{matrix_2d}.
	
	\pnum
	\postconditions
	\tcode{_M00 == v00}.
	
	\pnum
	\tcode{_M01 == v01}.
	
	\pnum
	\tcode{_M10 == v10}.
	
	\pnum
	\tcode{_M11 == v11}.
	
	\pnum
	\tcode{_M20 == v20}.
	
	\pnum
	\tcode{_M21 == v21}.
	
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.staticfactories] {\tcode{matrix_2d} static factory 
functions}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_identity}}
\indexlibrary{\idxcode{init_identity}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_identity() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix(1.0, 0.0, 0.0, 1.0, 0.0, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_translate}}
\indexlibrary{\idxcode{init_translate}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_translate(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix(1.0, 0.0, 0.0, 1.0, value.x(), value.y())}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_scale}}
\indexlibrary{\idxcode{init_scale}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_scale(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix(value.x(), 0.0, 0.0, value.y(), 0.0, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_rotate}}
\indexlibrary{\idxcode{init_rotate}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_rotate(double radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix(cos(radians), sin(radians), -sin(radians), cos(radians), 
	0.0, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_shear_x}}
\indexlibrary{\idxcode{init_shear_y}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_shear_x(double factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix(1.0, 0.0, factor, 1.0, 0.0, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{init_shear_y}}
\indexlibrary{\idxcode{init_shear_y}!\idxcode{matrix_2d}}
\begin{itemdecl}
static matrix_2d init_shear_y(double factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix\{ 1.0, factor, 0.0, 1.0, 0.0, 0.0 \}}
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.modifiers] {\tcode{matrix_2d} modifiers}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m00}}
\indexlibrary{\idxcode{m00}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m00(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M00 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m01}}
\indexlibrary{\idxcode{m01}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m01(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M01 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m10}}
\indexlibrary{\idxcode{m10}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m10(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M10 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m11}}
\indexlibrary{\idxcode{m11}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m11(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M11 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m20}}
\indexlibrary{\idxcode{m20}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m20(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M20 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m21}}
\indexlibrary{\idxcode{m21}!\idxcode{matrix_2d}}
\begin{itemdecl}
	void m21(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_M21 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{translate}}
\indexlibrary{\idxcode{translate}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& translate(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = init_translate(value) * (*this)}.
	
	\pnum
	\returns
	\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{scale}}
\indexlibrary{\idxcode{scale}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& scale(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = init_scale(value) * (*this)}.
	
	\pnum
	\returns
	\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{rotate}}
\indexlibrary{\idxcode{rotate}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& rotate(double radians) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = init_rotate(radians) * (*this)}.
	
	\pnum
	\returns
	\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{shear_x}}
\indexlibrary{\idxcode{shear_x}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& shear_x(double factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = init_shear_x(factor) * (*this)}.
	
	\pnum
	\returns
	\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{shear_y}}
\indexlibrary{\idxcode{shear_y}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& shear_y(double factor) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = init_shear_y(factor) * (*this)}.
	
	\pnum
	\returns
	\tcode{*this}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{invert}}
\indexlibrary{\idxcode{invert}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d& invert();
matrix_2d& invert(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
\begin{codeblock}
const auto det = _M00 * _M11 - _M01 * _M10;
const auto inverseDet = 1.0 / det;

const auto cM02 = 0.0;
const auto cM12 = 0.0;
const auto cM22 = 1.0;

const auto adjugateM00 =   _M11 * cM22 - cM12 * _M21;
const auto adjugateM01 = -(_M01 * cM22 - cM02 * _M21);
const auto adjugateM10 = -(_M10 * cM22 - cM12 * _M20);
const auto adjugateM11 =   _M00 * cM22 - cM02 * _M20;
const auto adjugateM20 =   _M10 * _M21 - _M11 * _M20;
const auto adjugateM21 = -(_M00 * _M21 - _M01 * _M20);

_M00 = inverseDet * adjugateM00;
_M01 = inverseDet * adjugateM01;
_M10 = inverseDet * adjugateM10;
_M11 = inverseDet * adjugateM11;
_M20 = inverseDet * adjugateM20;
_M21 = inverseDet * adjugateM21;
\end{codeblock}
	
	\pnum
	\returns
	\tcode{*this}.
	
	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).
	
	\pnum
	\errors
	\tcode{io2d_error::invalid_matrix} if \tcode{isnan(_M00) || isnan(_M01) || isnan(_M10) || isnan(_M11) || isnan(_M20) || isnan(_M21)}.

	\tcode{io2d_error::invalid_matrix} if \tcode{determinant() == 0.0}.
	
	\tcode{io2d_error::invalid_matrix} if \tcode{!isfinite(determinant())}.
	
	\pnum
	\remark
	If an error occurs, this function shall have no effects.
	
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.observers] {\tcode{matrix_2d} observers}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m00}}
\indexlibrary{\idxcode{m00}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m00() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M00}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m01}}
\indexlibrary{\idxcode{m01}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m01() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M01}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m10}}
\indexlibrary{\idxcode{m10}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m10() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M10}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m11}}
\indexlibrary{\idxcode{m11}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m11() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M11}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m20}}
\indexlibrary{\idxcode{m20}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m20() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M20}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{m21}}
\indexlibrary{\idxcode{m21}!\idxcode{matrix_2d}}
\begin{itemdecl}
	double m21() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M21}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{determinant}}
\indexlibrary{\idxcode{determinant}!\idxcode{matrix_2d}}
\begin{itemdecl}
double determinant() const;
double determinant(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_M00 * _M11 - _M01 * M10}.
	
	\pnum
	In the event of a non-throwing error, the function shall return \tcode{numeric_limits<double>::quiet_NaN()}.

	\pnum
	\throws
	As specified in Error reporting (\ref{\iotwod.err.report}).

	\pnum
	\errors
	\tcode{io2d_error::invalid_matrix} if \tcode{isnan(_M00) || isnan(_M01) || isnan(_M10) || isnan(_M11) || isnan(_M20) || isnan(_M21)}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{transform_distance}}
\indexlibrary{\idxcode{transform_distance}!\idxcode{matrix_2d}}
\begin{itemdecl}
vector_2d transform_distance(const vector_2d& dist) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{vector_2d(m00() * dist.x() + m10() * dist.y(), m01() * dist.x() + m11() * dist.y())}.
	
	\pnum
	\realnote
	This function ignores the translation component of \tcode{*this}. If the 
	translation component, \tcode{m20()} and \tcode{m21()}, of \tcode{*this} is set to \tcode{(0.0, 0.0)}, the return value of this function and the return 
	value of \tcode{transform_point(dist)} will be identical when given the 
	same input.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{transform_point}}
\indexlibrary{\idxcode{transform_point}!\idxcode{matrix_2d}}
\begin{itemdecl}
vector_2d transform_point(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{vector_2d((m00() * dist.x() + m10() * dist.y()) + m20(), (m01() * dist.x() + m11() * dist.y()) + m21())}.
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.member.ops] {\tcode{matrix_2d} member operators}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{operator*=}}
\indexlibrary{\idxcode{operator*=}!\idxcode{matrix_2d}}
\begin{itemdecl}
	matrix_2d& operator*=(const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	\tcode{*this = *this * rhs}
	
	\pnum
	\returns
	\tcode{*this}
\end{itemdescr}

\rSec1 [\iotwod.\matrixtwod.ops] {\tcode{matrix_2d} non-member operators}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{operator*}}
\indexlibrary{\idxcode{operator*}!\idxcode{matrix_2d}}
\begin{itemdecl}
matrix_2d operator*(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{matrix_2d\{\\
	lhs.m00() * rhs.m00() + lhs.m01() * rhs.m10(),\\
	lhs.m00() * rhs.m01() + lhs.m01() * rhs.m11(),\\
	lhs.m10() * rhs.m00() + lhs.m11() * rhs.m10(),\\
	lhs.m10() * rhs.m01() + lhs.m11() * rhs.m11(),\\
	lhs.m20() * rhs.m00() + lhs.m21() * rhs.m10() + lhs.m20(),\\
	lhs.m20() * rhs.m01() + lhs.m21() * rhs.m11() + lhs.m21()\\
	\}}
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{operator==}}
\indexlibrary{\idxcode{operator==}!\idxcode{matrix_2d}}
\begin{itemdecl}
bool operator==(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns \tcode{lhs.m00() == rhs.m00() \&\& lhs.m01() == rhs.m01() \&\& 
	lhs.m10() == rhs.m10() \&\& lhs.m11() == rhs.m11() \&\&
	lhs.m20() == rhs.m20() \&\& lhs.m21() == rhs.m21()}.
\end{itemdescr}

\indexlibrary{\idxcode{matrix_2d}!\idxcode{operator!=}}
\indexlibrary{\idxcode{operator!=}!\idxcode{matrix_2d}}%
\begin{itemdecl}
bool operator!=(const matrix_2d& lhs, const matrix_2d& rhs) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{!(lhs == rhs)}.
\end{itemdescr}
