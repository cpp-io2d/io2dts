%!TEX root = io2d.tex
\rSec0 [arc] {Class \tcode{arc}}

\rSec1 [arc.synopsis] {\tcode{arc} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class arc : public path_data {
  public:
    // \ref{arc.cons}, construct/copy/move/destroy:
    arc() noexcept;
    arc(const arc& other) noexcept;
    arc& operator=(const arc& other) noexcept;
    arc(arc&& other) noexcept;
    arc& operator=(arc&& other) noexcept;
    arc(const vector_2d& ctr, double rad, double angle1, double angle2) noexcept;

    // \ref{arc.modifiers}, modifiers:
    void center(const vector_2d& value) noexcept;
    void radius(double value) noexcept;
    void angle_1(double radians) noexcept;
    void angle_2(double radians) noexcept;

    // \ref{arc.observers}, observers:
    vector_2d center() const noexcept;
    double radius() const noexcept;
    double angle_1() const noexcept;
    double angle_2() const noexcept;
    virtual path_data_type type() const noexcept override;

  private:
    vector_2d _Center; // \expos
    double _Radius;    // \expos
    double _Angle_1;   // \expos
    double _Angle_2;   // \expos
  };
} } } }
\end{codeblock}

\rSec1 [arc.intro] {\tcode{arc} Description}

\pnum
\indexlibrary{\idxcode{arc}}
The class \tcode{arc} describes an operation on a path geometry collection.

\pnum
This operation creates a circular arc.

\pnum
The unit for the values passed to and returned by \tcode{arc::angle_1} and \tcode{arc::angle_2} is the radian.

\pnum
Its \term{start point} is \tcode{vector_2d\{ *this.radius() * cos(*this.angle_1(), -(*this.radius() * -sin(*this.angle_1())) \} + *this.center()}.

\pnum
Its \term{end point} is \tcode{vector_2d\{ *this.radius() * cos(*this.angle_2(), -(*this.radius() * -sin(*this.angle_2())) \} + *this.center()}.

\pnum
If the current path geometry has a current point, a line is created from the current point to the start point before this arc operation is processed. Otherwise the start point is set as the current point and last-move-to point of the current path geometry.

\pnum
The arc rotates around the point returned by \tcode{*this.center()}.

\pnum
The arc begins at its start point and proceeds clockwise until it reaches its end point.

\pnum
The current point is set be to the arc's end point at the end of this operation.

\pnum
For purposes of determining whether a point is on the arc, if the value returned by \tcode{*this.angle_2()} is less than the value returned by \tcode{*this.angle_1()} then the value returned by \tcode{*this.angle_2()} shall be continuously incremented by $2\pi$ until it is greater than the value returned by \tcode{*this.angle_1()}.

\rSec1 [arc.cons] {\tcode{arc} constructors and assignment operators}

\indexlibrary{\idxcode{arc}!constructor}
\begin{itemdecl}
    arc() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{arc}.
	
	\pnum
	\postconditions
	\tcode{_Center == vector_2d(0.0, 0.0)}.

	\tcode{_Radius == 0.0}.

	\tcode{_Angle_1 == 0.0}.

	\tcode{_Angle_2 == 0.0}.

\end{itemdescr}

\indexlibrary{\idxcode{arc}!constructor}
\begin{itemdecl}
    arc(const vector_2d& ctr, double rad, double angle1, double angle2) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Constructs an object of type \tcode{arc}.
	
	\pnum
	\postconditions
	\tcode{_Center == ctr}.

	\tcode{_Radius == rad}.

	\tcode{_Angle_1 == angle1}.

	\tcode{_Angle_2 == angle2}.

\end{itemdescr}

\rSec1 [arc.modifiers]{\tcode{arc} modifiers}

\indexlibrary{\idxcode{arc}!\idxcode{center}}
\indexlibrary{\idxcode{center}!\idxcode{arc}}
\begin{itemdecl}
    void center(const vector_2d& value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Center == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{radius}}
\indexlibrary{\idxcode{radius}!\idxcode{arc}}
\begin{itemdecl}
    void radius(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Radius == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{angle_1}}
\indexlibrary{\idxcode{angle_1}!\idxcode{arc}}
\begin{itemdecl}
    void angle_1(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Angle_1 == value}.
	
\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{angle_2}}
\indexlibrary{\idxcode{angle_2}!\idxcode{arc}}
\begin{itemdecl}
    void angle_2(double value) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\postconditions
	\tcode{_Angle_2 == value}.
	
\end{itemdescr}

\rSec1 [arc.observers]{\tcode{arc} observers}

\indexlibrary{\idxcode{arc}!\idxcode{center}}
\indexlibrary{\idxcode{center}!\idxcode{arc}}
\begin{itemdecl}
    vector_2d center() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Center}.

\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{radius}}
\indexlibrary{\idxcode{radius}!\idxcode{arc}}
\begin{itemdecl}
    double radius() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Radius}.

\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{angle_1}}
\indexlibrary{\idxcode{angle_1}!\idxcode{arc}}
\begin{itemdecl}
    double angle_1() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Angle_1}.

\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{angle_2}}
\indexlibrary{\idxcode{angle_2}!\idxcode{arc}}
\begin{itemdecl}
    double angle_2() const noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{_Angle_2}.

\end{itemdescr}

\indexlibrary{\idxcode{arc}!\idxcode{type}}
\indexlibrary{\idxcode{type}!\idxcode{arc}}
\begin{itemdecl}
    virtual path_data_type type() const noexcept override;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	\tcode{path_data_type::arc}.

\end{itemdescr}
