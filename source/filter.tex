%!TEX root = io2d.tex
\rSec0 [filter] {Enum class \tcode{filter}}

\rSec1 [filter.summary] {\tcode{filter} Summary}

\pnum
The \tcode{filter} enum class specifies the type of signal filter to use when 
sampling from a \tcode{brush} or \tcode{surface}. Some values specify 
attributes, leaving the choice of specific filter to the implementation, while 
others denote a specific type of filter that shall be used.

\pnum
See Table~\ref{tab:filter.meanings} for the meaning of each
\tcode{filter} enumerator.

\rSec1 [filter.synopsis] {\tcode{filter} Synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  enum class filter {
    fast,
    good,
    best,
    nearest,
    bilinear
  };
} } } }
\end{codeblock}

\rSec1 [filter.enumerators] {\tcode{filter} Enumerators}
\begin{libreqtab2}
 {\tcode{filter} enumerator meanings}
 {tab:filter.meanings}
 \\ \topline
 \lhdr{Enumerator}
 & \rhdr{Meaning}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Enumerator}
 & \rhdr{Meaning}
 \\ \capsep
 \endhead
 \tcode{fast}
 & The meaning of this value is \impldef{filter!fast}.
 \enternote
 By choosing this value, the user is hinting that performance is more important 
 that quality. Typically this would mean nearest-neighbor filtering, but if 
 implementations can perform, e.g., bilinear filtering at nearly identical 
 speeds, they are free to set that as the fast filter.
 \exitnote
 \\
 \tcode{good}
 & The meaning of this value is \impldef{filter!good}.
 \enternote
 By choosing this value, the user is hinting that quality is important but that 
 performance is also still a consideration. Typically this would mean bilinear 
 filtering, but if implementations can perform, e.g., bicubic filtering at nearly identical speeds, they are free to set that as the good filter.
 \exitnote
 \\
 \tcode{best}
 & The meaning of this value is \impldef{filter!best}.
 \enternote
 By choosing this value, the user is hinting that quality is more important 
 than performance. Typically this would mean bicubic filtering (possibly with mipmapping).
 \exitnote
 \\
 \tcode{nearest}
 & Nearest-neighbor filtering shall be used. This is sometimes also called point sampling. The color of the nearest source pixel is used with no interpolation performed. Whether mipmapping is used and whether mipmaps are generated for sources that do not have them is \impldef{filter!nearest mipmapping}.
 \\
 \tcode{bilinear}
 & Bilinear filtering shall be used. The distance-weighted average of the nearest 2x2 grid of source pixels is used to create an interpolated color for the destination pixel. If some source pixel values do not exist (e.g. because an edge or corner of the source has been reached) then the current \tcode{extend} should be considered in order to determine the values for the missing source pixels. If a hardware sampler is available and offers bilinear filtering, implementations may use it even if its results do not conform to those produced by the description of bilinear filtering provided by this standard. Whether mipmapping is used and whether mipmaps are generated for sources that do not have them is \impldef{filter!bilinear mipmapping}.
 \\
\end{libreqtab2}
