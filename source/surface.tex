%!TEX root = io2d.tex
\rSec0 [\iotwod.surface] {Class \tcode{surface}}

\rSec1 [\iotwod.surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class surface {
  public:
    // \ref{\iotwod.surface.cons}, constructors, assignment operators, destructors:
    surface() = delete;
    surface(const surface&) = delete;
    surface& operator=(const surface&) = delete;
    surface(surface&& other) noexcept;
    surface& operator=(surface&& other) noexcept;
    virtual ~surface();

    // \ref{\iotwod.surface.modifiers.state}, state modifiers:
    virtual void finish() noexcept;
    void flush();
    void flush(error_code& ec) noexcept;
    shared_ptr<experimental::io2d::device> device();
    shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void device_offset(const vector_2d& offset);
    void device_offset(const vector_2d& offset, error_code& ec) noexcept;
    void map(const function<void(mapped_surface&)>& action);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const rectangle& extents,
      const function<void(mapped_surface&)>& action);
    void map(const rectangle& extents,
      const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    virtual void save();
    virtual void save(error_code& ec) noexcept;
    virtual void restore();
    virtual void restore(error_code& ec) noexcept;
    void reset_brush() noexcept;
    void brush(const experimental::io2d::brush& source);
    void brush(const experimental::io2d::brush& source, error_code& ec)
      noexcept;
    void antialias(experimental::io2d::antialias a) noexcept;
    void reset_dashes() noexcept;
    void dashes(const experimental::io2d::dashes& d);
    void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
    void fill_rule(experimental::io2d::fill_rule fr) noexcept;
    void line_cap(experimental::io2d::line_cap lc) noexcept;
    void line_join(experimental::io2d::line_join lj) noexcept;
    void line_width(double width) noexcept;
    void miter_limit(double limit) noexcept;
    void compositing_operator(experimental::io2d::compositing_operator co)
      noexcept;
    void clip(const experimental::io2d::path& p);
    void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
    void clip_immediate();
    void clip_immediate(error_code& ec) noexcept;
    void reset_path() noexcept;
    void path(const experimental::io2d::path& p);
    void path(const experimental::io2d::path& p, error_code& ec) noexcept;

    // \ref{\iotwod.surface.modifiers.immediatepath}, immediate path modifiers:
    experimental::io2d::path_factory& immediate() noexcept;

    // \ref{\iotwod.surface.modifiers.render}, render modifiers:
    void fill();
    void fill(error_code& ec) noexcept;
    void fill(const rgba_color& c);
    void fill(const rgba_color& c, error_code& ec) noexcept;
    void fill(const experimental::io2d::brush& b);
    void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void fill(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void fill(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void fill(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void fill_immediate();
    void fill_immediate(error_code& ec) noexcept;
    void fill_immediate(const rgba_color& c);
    void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
    void fill_immediate(const experimental::io2d::brush& b);
    void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void fill_immediate(const surface& s, const vector_2d& o = vector_2d{ }, 
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint();
    void paint(error_code& ec) noexcept;
    void paint(const rgba_color& c);
    void paint(const rgba_color& c, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b);
    void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void paint(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint(double alpha);
    void paint(double alpha, error_code& ec) noexcept;
    void paint(const rgba_color& c, double alpha);
    void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b, double alpha);
    void paint(const experimental::io2d::brush& b, double alpha,
      error_code& ec) noexcept;
    void paint(const surface& s, double alpha,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, double alpha, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, double alpha, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, double alpha, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void stroke();
    void stroke(error_code& ec) noexcept;
    void stroke(const rgba_color& c);
    void stroke(const rgba_color& c, error_code& ec) noexcept;
    void stroke(const experimental::io2d::brush& b);
    void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void stroke(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void stroke(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke_immediate();
    void stroke_immediate(error_code& ec) noexcept;
    void stroke_immediate(const rgba_color& c);
    void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
    void stroke_immediate(const experimental::io2d::brush& b);
    void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void stroke_immediate(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void stroke_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{\iotwod.surface.modifiers.maskrender}, mask render modifiers:
    void mask(const experimental::io2d::brush& mb);
    void mask(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask(const experimental::io2d::brush& mb, const rgba_color& c);
    void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
      error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none, 
      filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms);
    void mask(const surface& ms, error_code& ec) noexcept;
    void mask(const surface& ms, const rgba_color& c);
    void mask(const surface& ms, const rgba_color& c, error_code& ec) noexcept;
    void mask(const surface& ms, const experimental::io2d::brush& b);
    void mask(const surface& ms, const experimental::io2d::brush& b, 
      error_code& ec) noexcept;
    void mask(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void mask(const surface& ms, const vector_2d& mo);
    void mask(const surface& ms, const vector_2d& mo, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c);
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c,
      error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb);
    void mask_immediate(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c);
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms);
    void mask_immediate(const surface& ms, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const rgba_color& c);
    void mask_immediate(const surface& ms, const rgba_color& c, error_code& ec) 
      noexcept;
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b,
      error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo);
    void mask_immediate(const surface& ms, const vector_2d& mo, error_code& ec)
      noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{\iotwod.surface.modifiers.textrender}, text render modifiers:
    vector_2d show_text(const string& utf8, const vector_2d& pos);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c, error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{\iotwod.surface.modifiers.transform}, transformation modifiers:
    void matrix(const matrix_2d& matrix) noexcept;
    
    // \ref{\iotwod.surface.modifiers.font}, font modifiers:
    void font_face(const string& family, font_slant sl, font_weight w);
    void font_face(const string& family, font_slant sl, font_weight w,
      error_code& ec) noexcept;
    void font_face(const experimental::io2d::font_face& f);
    void font_face(const experimental::io2d::font_face& f, error_code& ec)
      noexcept;
    void font_size(double s) noexcept;
    void font_matrix(const matrix_2d& m) noexcept;
    void font_options(const font_options& fo) noexcept;
    
    // \ref{\iotwod.surface.observers.state}, state observers:
    bool is_finished() const noexcept;
    experimental::io2d::content content() const noexcept;
    bool has_surface_resource() const noexcept;
    experimental::io2d::brush brush() const noexcept;
    experimental::io2d::antialias antialias() const noexcept;
    unsigned int dashes_count() const noexcept;
    experimental::io2d::dashes dashes() const;
    experimental::io2d::dashes dashes(error_code& ec) const noexcept;
    experimental::io2d::fill_rule fill_rule() const noexcept;
    experimental::io2d::line_cap line_cap() const noexcept;
    experimental::io2d::line_join line_join() const noexcept;
    double line_width() const noexcept;
    double miter_limit() const noexcept;
    experimental::io2d::compositing_operator compositing_operator() const
      noexcept;
    double tolerance() const noexcept;
    rectangle clip_extents() const noexcept;
    bool in_clip(const vector_2d& pt) const noexcept;
    vector<rectangle> clip_rectangles() const;
    vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
    
    // \ref{\iotwod.surface.observers.render}, render observers:
    rectangle fill_extents() const noexcept;
    rectangle fill_extents_immediate() const noexcept;
    bool in_fill(const vector_2d& pt) const noexcept;
    bool in_fill_immediate(const vector_2d& pt) const noexcept;
    rectangle stroke_extents() const noexcept;
    rectangle stroke_extents_immediate() const noexcept;
    bool in_stroke(const vector_2d& pt) const noexcept;
    bool in_stroke_immediate(const vector_2d& pt) const noexcept;
    experimental::io2d::font_extents font_extents() const noexcept;
    experimental::io2d::text_extents text_extents(const string& utf8) const;
    experimental::io2d::text_extents text_extents(const string& utf8,
      error_code& ec) const noexcept;
    
    // \ref{\iotwod.surface.observers.transform}, transformation observers:
    matrix_2d matrix() const noexcept;
    vector_2d user_to_surface(const vector_2d& pt) const noexcept;
    vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
    vector_2d surface_to_user(const vector_2d& pt) const;
    vector_2d surface_to_user(const vector_2d& pt, error_code& ec) const
      noexcept;
    vector_2d surface_to_user_distance(const vector_2d& dpt) const;
    vector_2d surface_to_user_distance(const vector_2d& dpt, error_code& ec)
      const noexcept;
    
    // \ref{\iotwod.surface.observers.font}, font observers:
    matrix_2d font_matrix() const noexcept;
    experimental::io2d::font_options font_options() const noexcept;
    experimental::io2d::font_face font_face() const;
    experimental::io2d::font_face font_face(error_code& ec) const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [\iotwod.surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}
The \tcode{surface} class manages a graphics
data graphics resource and its observable state data
(\ref{\iotwod.surface.state}).

\pnum
The \tcode{surface} class provides two ways to modify its graphics resource:
\begin{itemize}
\item by rendering to it; and
\item by mapping it.
\end{itemize}

\pnum
A \tcode{surface} object is a move-only object.

\pnum
Rendering to a \tcode{surface} object is accomplished by setting the appropriate state, often in the form of state objects such as \tcode{path} and \tcode{pattern}, and then calling one or more of the render functions to make the changes specified by the state to the \tcode{surface} object's graphics resource.

\pnum
The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable. While a \tcode{surface} object manages a graphics data graphics resource, no well-defined semantics are provided for the graphics resource. Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics resource or inherit well-defined semantics for the graphics resource from a base class.

\rSec1 [\iotwod.surface.state] {\tcode{surface} state}

\pnum
Table~\ref{tab:\iotwod.surface.state.listing} specifies the name, type, function, and default value for each item of a surface's observable state.

\rSec2 [\iotwod.surface.state.default] {\tcode{surface} state default values}

\begin{libreqtab4b}
	{Surface observable state}
	{tab:\iotwod.surface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	Current Brush &
	\tcode{brush} &
	This is the brush that shall be used when performing rendering operations &
	\tcode{brush\{ \{ rgba_color::black() \} \}} \\ \rowsep

	General Antialiasing &
	\tcode{antialias} &
	This is the type of antialiasing that should be used when performing non-text rendering operations &
	\tcode{antialias::default_antialias}\\ \rowsep
	
	Dash Pattern &
	\tcode{dashes} &
	This specifies the pattern that shall be used when performing stroke rendering operations &
	\tcode{dashes\{ vector<double>(), 0.0 \}} \\ \rowsep
	
	Fill Rule &
	\tcode{fill_rule} &
	This controls which areas of paths shall be eligible to be filled when performing fill rendering operations &
	\tcode{fill_rule::winding} \\ \rowsep
	
	Line Cap &
	\tcode{line_cap} &
	This specifies how the end of a path segment that is not joined to another path segment shall be rendered when performing stroke rendering operations &
	\tcode{line_cap::butt} \\ \rowsep
	
	Line Join &
	\tcode{line_join} &
	This specifies how the join point of two path segments that are joined to each other shall be rendered when performing stroke rendering operations &
	\tcode{line_join::miter} \\ \rowsep
	
	Line Width &
	\tcode{double} &
	This is the width, in surface coordinate space units, that shall be used to determine the rendered width of path segments when performing a stroke rendering operation &
	\tcode{2.0} \\ \rowsep
	
	Miter Limit &
	\tcode{double} &
	This is the value that shall be used to calculate whether a line join shall be mitered or beveled when the value of Line Join is \tcode{line_join::miter}. &
	\tcode{10.0} \\ \rowsep
	
	Composition Operator &
	\tcode{compositing_operator} &
	This specifies the composition algorithm that shall be used when performing rendering operations &
	\tcode{compositing_operator::over} \\ \rowsep
	
	Tolerance &
	\tcode{double} &
	This is the value, in surface coordinate space units, that should be used when transforming non-linear path segments into linear path segments when performing rendering operations &
	\tcode{\impldef{\tcode{surface}!Tolerance}} \\ \rowsep
	
	Clip Area &
	\tcode{\unspec}
	The areas of the surface which shall be the only areas in which rendering and composing operations shall be able to have any effect &
	An area which contains the entire area of the surface \\ \rowsep
	
	Current Path &
	\tcode{path} &
	This is the \tcode{path} object that shall be used when performing non-immediate rendering operations &
	\tcode{path\{ path_factory\{ \} \}} \\ \rowsep
	
	Immediate Path &
	\tcode{path_factory} &
	This is the \tcode{path_factory} object that shall be used when performing immediate rendering operations &
	\tcode{path_factory\{ \}} \\ \rowsep
	
	Transformation Matrix &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from an object's local coordinate space to the surface's coordinate space when performing rendering operations &
	\tcode{matrix_2d::init_identity\{ \}} \\ \rowsep
	
	Font Face &
	\tcode{font_face} &
	This is the font that shall be used when performing text rendering operations &
	\tcode{\impldef{\tcode{surface}!Font Face}} \\ \rowsep
	
	Font Matrix &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from a font's local coordinate space to the surface's coordinate space when performing text rendering operations &
	\tcode{matrix_2d::init_scale\{ \{ 10.0, 10.0 \} \}} \\ \rowsep
	
	Font Options &
	\tcode{font_options} &
	This is the \tcode{font_options} object that shall be used to determine certain aspects of how a font should be rendered when performing text rendering operations &
	\tcode{font_option\{ antialias::default_antialias, subpixel_order::default_subpixel_order \}} \\ \rowsep
	
\end{libreqtab4b}


\rSec2 [\iotwod.surface.state.save] {\tcode{surface} saved state}

\pnum
A surface object provides an interface to save its current state and subsequently restore it.

\pnum
Save and restore operations are performed using \tcode{surface::save} and \tcode{surface::restore}, respectively.

\pnum
Save and restore operations may be nested.

\pnum
Each call to \tcode{surface::restore} restores a surface object's state to its values at the time of the most recent call to \tcode{surface::save}.

\pnum
The following list denotes each item of observable state that shall be saved by \tcode{surface::save} and restored by \tcode{surface::restore}, using the state item names listed in Table~\ref{tab:\iotwod.surface.state.listing}:

\begin{itemize}
	\item Current Brush
	\item General Antialiasing
	\item Dash Pattern
	\item Fill Rule
	\item Line Cap
	\item Line Join
	\item Line Width
	\item Miter Limit
	\item Compositing Operator
	\item Tolerance
	\item Clip Area
	\item Current Path
	\item Immediate Path
	\item Transformation Matrix
	\item Font Face
	\item Font Matrix
	\item Font Options
\end{itemize}

\rSec1 [\iotwod.surface.rendering] {\tcode{surface} rendering and composing}

\pnum
The \tcode{surface} class provides five fundamental rendering and composing operations:
\begin{itemize}
\item painting
\item filling
\item stroking
\item masking
\item typesetting
\end{itemize}

\pnum
Some of these operations consist solely of composing. The remainder consist of rendering followed by composing.

%\pnum
%Where an operation includes rendering, the rendering shall be done as if the following steps are taken:
%\begin{enumeraten}
%\item An \tcode{image_surface} object large enough to contain the results of the rendering is created 
%\end{enumeraten}

\pnum
All rendering and composing operations shall be constrained to the Clip Area.
\enternote
The preceding requirement is intended to make it clear that the Clip Area always applies even if no mention is made of the Clip Area or if a description of an operation could otherwise be read as disregarding the Clip Area. The painting operation is a good example of this since it is described as affecting the entire surface but it, in fact, only affects all areas of the surface that are within the Clip Area. The preceding requirement removes the need to continually restate the applicability of the Clip Area through the descriptions of the rendering and composing operations that follow.
\exitnote

\rSec2 [\iotwod.surface.rendering.painting] {\tcode{surface} painting}

\pnum
Painting is a composing operation.

\pnum
Painting shall affect the entire surface.

\pnum
Where a painting operation is initiated on a surface and either no arguments are supplied or the only argument supplied is an \tcode{error_code} object, the implementation shall compose the surface's Current Brush and the surface in the manner required by the Composition Operator.
\enternote
***FIXME*** Should the term 'compose' be defined (as it is now) or should I eliminate the definition (or make it a local term) since it is complex due to the fact that the definition has "parameters". Need to examine the Standard to see if there is any precedent for a term definition in this form. Also need to fixup the 'brush' type to use the new terminology (i.e. it is a raster graphics data graphics resource).
\exitnote

\pnum
Where one or more arguments, not including an \tcode{error_code} object, are supplied, the entire surface shall be filled as if those arguments were used to construct a \tcode{brush} object from a brush factory object of the type which those 

\rSec2 [\iotwod.surface.rendering.filling] {\tcode{surface} filling}

\pnum
***FIXME***

\rSec2 [\iotwod.surface.rendering.stroking] {\tcode{surface} stroking}

\pnum
***FIXME***

\rSec2 [\iotwod.surface.rendering.masking] {\tcode{surface} masking}

\pnum
***FIXME***

\rSec2 [\iotwod.surface.rendering.typesetting] {\tcode{surface} typesetting}

\pnum
***FIXME***



\rSec1 [\iotwod.surface.cons] {\tcode{surface} constructors, assignment operators, and destructors}

\indexlibrary{\idxcode{surface}!destructor}
\begin{itemdecl}
virtual ~surface();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Destroys an object of class \tcode{surface}.
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{finish}}
\indexlibrary{\idxcode{finish}!\idxcode{surface}}
\begin{itemdecl}
virtual void finish() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Releases all resources managed by the \tcode{surface} if \tcode{!is_finished()}, otherwise does nothing.

\pnum
\postconditions
\tcode{is_finished()} shall return \tcode{true}. \tcode{has_surface_resource()} shall return \tcode{false}.

\pnum
\remarks
Once this function has been called, the surface is \term{finished}. The only valid operations on a finished surface are destruction, calling \tcode{finish()}, calling \tcode{has_surface_resource()}, and calling \tcode{is_finished()}. Any other operation on a finished surface or any attempt to use a finished \tcode{surface} or \tcode{surface}-derived object as an argument to a function produces undefined behavior except as otherwise noted.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}
\indexlibrary{\idxcode{flush}!\idxcode{surface}}
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The user shall be able to use the implementation's underlying surface without introducing a race condition. This means that any pending surface operations shall be executed, batched, or otherwise committed to the underlying technologies. Saved surface state, if any, shall also be restored before this function returns.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists primarily to allow the user to take control of the underlying surface using an implementation-provided native handle. The implementation's responsibility is to ensure that the user can safely use the underlying surface.
\enternote
This function flushes the native surface so that it can safely be rendered to or, if the underlying technology supports it, be used as a texture to be sampled from. It is not required to flush the device or context that is rendering to it.
\exitnote

\pnum
\errors

\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device}}
\indexlibrary{\idxcode{device}!\idxcode{surface}}
\begin{itemdecl}
shared_ptr<experimental::io2d::device> device();
shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A shared pointer to the \tcode{device} object for this \tcode{surface}.	
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const rectangle& rect);
void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Informs the implementation that external changes were potentially made to the entire underlying graphics resource, or to the area defined by \tcode{rect} if that parameter is present.

\pnum
\remarks
After external changes are made to this \tcode{surface} object's underlying graphics resource, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
No call to this function shall be required solely as a result of changes made to a surface using the functionality provided by \tcode{surface::map}.
\enternote
The \tcode{mapped_surface} type, which is used by \tcode{surface::map}, provides its own functionality for managing any such changes.
\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device_offset}}
\indexlibrary{\idxcode{device_offset}!\idxcode{surface}}
\begin{itemdecl}
void device_offset(const vector_2d& offset);
void device_offset(const vector_2d& offset, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Stores the value of \tcode{offset}. The value will be added to all coordinates after they have been transformed by the \tcode{surface} object's transformation matrix.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}
\indexlibrary{\idxcode{map}!\idxcode{surface}}
\begin{itemdecl}
void map(const function<void(mapped_surface&)>& action);
void map(const function<void(mapped_surface&, error_code&)>& action, error_code& ec);
void map(const function<void(mapped_surface&)>& action, const rectangle& extents);
void map(const function<void(mapped_surface&, error_code&)>& action,
  const rectangle& extents, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Maps \tcode{*this} to a newly created \tcode{image_surface} which allows direct manipulation of the underlying surface. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}.
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it.
\end{itemdescr}

\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates an \tcode{image_surface} that allows direct manipulation of the underlying surface. The \tcode{image_surface} will be scoped to the area of the underlying surface defined by \tcode{extents}. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}. 
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it. 
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{save}}
\indexlibrary{\idxcode{save}!\idxcode{surface}}
\begin{itemdecl}
virtual void save();
virtual void save(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Saves the current observable state of \tcode{*this} to a newly created entry on the internal stack of saved states.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{restore}}
\indexlibrary{\idxcode{restore}!\idxcode{surface}}
\begin{itemdecl}
virtual void restore();
virtual void restore(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	A matching call to \tcode{surface::save} on \tcode{*this}.
	
	\pnum
	\effects
	Restores the observable state of \tcode{*this} from the most recent entry on the internal stack of saved states and removes that entry from the stack.
	
	\pnum
	\throws
	\tcode{system_error} with an error category of \tcode{io2d_error_category} and an error condition of \tcode{io2d_error::invalid_restore} if there are no entries on the stack of saved states when this function is called.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_brush}}
\indexlibrary{\idxcode{reset_brush}!\idxcode{surface}}
\begin{itemdecl}
void reset_brush() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets a default \tcode{pattern} object.
	\enternote
	The default \tcode{pattern} object is always an opaque black solid color 
	pattern, equivalent to the pattern created by 
	\tcode{solid_color_pattern_factory(rgba_color::black).get_pattern()}. It is 
	not required to be the same object throughout the lifetime of the program.
	\exitnote
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a default \tcode{pattern} object.
\end{itemdescr}

\begin{itemdecl}
void brush(const experimental::io2d::brush& source);
void brush(const experimental::io2d::brush& source,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets \tcode{source} as the current \tcode{pattern} object.
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a \tcode{pattern} object with the same observable state as \tcode{source} object.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
void antialias(experimental::io2d::antialias a) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current \tcode{antialias} state to \tcode{a}.
	
	\pnum
	\postconditions
	\tcode{get_antialias()} returns the value of \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_dashes}}
\indexlibrary{\idxcode{reset_dashes}!\idxcode{surface}}
\begin{itemdecl}
void reset_dashes() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to be a solid line.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{make_tuple<vector<double>, double>(\{ \}, 0.0)}. \tcode{get_dashes_count()} will return \tcode{0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(const experimental::io2d::dashes& d);
void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to the value of \tcode{d}.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{d}. \tcode{get_dashes_count()} will return the value of \tcode{static_cast<int>(get<0>(d).size())}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
void fill_rule(experimental::io2d::fill_rule fr) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current fill rule to the value of \tcode{fr}.
	
	\pnum
	\postconditions
	\tcode{get_fill_rule()} will return the value of \tcode{fr}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
void line_cap(experimental::io2d::line_cap lc) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line cap to the value of \tcode{lc}.
		
	\pnum
	\postconditions
	\tcode{get_line_cap()} will return the value of \tcode{lc}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
void line_join(experimental::io2d::line_join lj) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line join to the value of \tcode{lj}.
	
	\pnum
	\postconditions
	\tcode{get_line_join()} will return the value of \tcode{lj}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{set_line_width}}
\indexlibrary{\idxcode{set_line_width}!\idxcode{surface}}
\begin{itemdecl}
void line_width(double width) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line width to \tcode{max(width, 0.0)}.
	
	\pnum
	\postconditions
	\tcode{get_line_width()} will return \tcode{max(width, 0.0)}.
	
	\pnum
	\remarks
	Line width is in pre-transformation units and is used with the \tcode{surface::stroke} functions. It postulates a round brush with a diameter of the current line width. The shape and size of the stroke when rendered depends on other state data.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
void miter_limit(double limit) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the Miter Limit to \tcode{limit}.
	
	\pnum
	The Miter Limit shall be clamped to be within the range defined by the \impldef{Miter Limit!minimum} minimum value and the \impldef{Miter Limit!maximum} maximum value, inclusive. The \impdef minimum value shall not be greater than \tcode{2.0} and the \impdef maximum value shall not be less than \tcode{10.0}.
	
	\pnum
	\enternote
	The Miter Limit only applies when the Line Join is set to \tcode{line_join::miter}.
	\exitnote
	
	\pnum
	\remarks
	The Miter Limit works as follow. The length of the miter is divided by the width of the line. If the resulting value is greater than the Miter Limit, the join will be beveled, otherwise it will be mitered.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
void compositing_operator(experimental::io2d::compositing_operator co)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current compositing operator to the value of \tcode{co}.
	
	\pnum
	\postconditions
	\tcode{get_compositing_operator} will return the value of \tcode{co}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip}}
\indexlibrary{\idxcode{clip}!\idxcode{surface}}
\begin{itemdecl}
void clip(const experimental::io2d::path& p);
void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current clip area to be the intersection of the current clip area and the current path where the current path's area is determined in the same way as if the current path were filled according to the current fill rule.
	
	\pnum
	\realnotes
	The clip area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_immediate}}
\indexlibrary{\idxcode{clip_immediate}!\idxcode{surface}}
\begin{itemdecl}
void clip_immediate();
void clip_immediate(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_path}}
\indexlibrary{\idxcode{reset_path}!\idxcode{surface}}
\begin{itemdecl}
void reset_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\begin{itemdecl}
void path(const experimental::io2d::path& p);
void path(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to \tcode{p}.
	
	\pnum
	\remarks
	Processing the path data so that it is properly transformed can be done at the time it is first set as a path on a \tcode{surface} object or any time before that. The untransformed \tcode{vector<path_data>} must be retained to ensure that a path can be properly recreated at any time. The steps for converting an untransformed \tcode{vector<path_data>} to transformed path data are found at .
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.immediatepath] {\tcode{surface} immediate path modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\postconditions

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.maskrender] {\tcode{surface} mask render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\postconditions

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.textrender] {\tcode{surface} text render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.transform] {\tcode{surface} transformation modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}


\rSec1 [\iotwod.surface.modifiers.font] {\tcode{surface} font modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}


\rSec1 [\iotwod.surface.observers.state] {\tcode{surface} state observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.render] {\tcode{surface} render observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.transform] {\tcode{surface} transformation observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.font] {\tcode{surface} font observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}
