%!TEX root = io2d.tex
\rSec0 [\iotwod.surface] {Overview of surface classes}

\rSec1 [\iotwod.surface.intro] {Surface class templates description}

\pnum
\indexlibrary{\idxcode{surface}}%
There are three surface class templates:
\begin{itemize}
\item \tcode{basic_image_surface}
\item \tcode{basic_output_surface}
\item \tcode{basic_unmanaged_output_surface}
\end{itemize}

\pnum
For ease of description, an instantiation of a surface class template will be called a \term{surface class}.

\pnum
A surface class contains visual data and provides an interface for managing and manipulating that visual data.

\pnum
Surface classes are \tcode{MoveConstructible} and \tcode{MoveAssignable}. They are neither \tcode{CopyConstructible} nor \tcode{CopyAssignable}. \begin{note}
On many platforms, especially those that use specialized hardware to accelerate various graphics operations, copying a surface class object is highly detrimental to performance and is rarely desired. The \tcode{copy_surface} function (\ref{\iotwod.standalone.copysurface}) exists for those situations where a copy is desired.
\end{note}

\pnum
The surface classes manipulate their visual data through rendering and composing operations.

\pnum
The rendering and composing operations \ref{\iotwod.surface.rendering} are described in terms of operating on each integral point of the visual data of a surface class. The reason for that is to support the discrete nature of raster graphics data. Operating on each integral point of the surface is the coarsest granularity allowed. Implementations may perform rendering and composing operations at a finer granularity than that of each integral point.
\begin{note}
Vector graphics data, being continuous, has the finest granularity possible since it resolves at the limits imposed by the precision of the floating-point types used to determine its visual data at any particular point.
\end{note} 

\rSec1 [\iotwod.surface.rendering] {Rendering and composing}

\rSec2 [\iotwod.surface.rendering.ops] {Operations}

\pnum
The surface classes provide four fundamental rendering and composing operations:
\begin{libreqtab2}
 {surface rendering and composing operations}
 {tab:\iotwod.surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{paint}
 \\
 Filling
 & \tcode{fill}
 \\
 Stroking
 & \tcode{stroke}
 \\
 Masking
 & \tcode{mask}
 \\
\end{libreqtab2}

\pnum
All composing operations shall happen in a linear color space, regardless of the color space of the visual data that is involved.

\pnum
\begin{note}
While a color space such as sRGB helps produce expected, consistent results when visual data are viewed by people, composing operations only produce expected results when the valid values for the color channel and alpha channel data in the visual data involved are uniformly (i.e. linearly) spaced. 
\end{note}

\rSec2 [\iotwod.surface.rendering.brushes] {Rendering and composing brushes}

\pnum
All rendering and composing operations use a \term{source brush} of type \tcode{basic_brush}.

\pnum
The masking operation uses a \term{mask brush} of type \tcode{basic_brush}.

\rSec2 [\iotwod.surface.rendering.sourcepath] {Rendering and composing source path}

\pnum
In addition to brushes (\ref{\iotwod.surface.rendering.brushes}), all rendering and composing operation except for painting and masking use a \term{source path}. The source path is either a \tcode{basic_path_builder<Allocator>} object or a \tcode{basic_interpreted_path} object. If it is a \tcode{basic_path_builder<Allocator>} object, it is interpreted (\ref{\iotwod.paths.interpretation}) before it is used as the source path.

\rSec2 [\iotwod.surface.rendering.commonstate] {Common state data}

\pnum
All rendering and composing operations use the following state data:

\begin{libreqtab2}
 {\tcode{surface} rendering and composing common state data}
 {tab:\iotwod.surface.rendering.commonstate.listing}
 \\ \topline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Brush properties
 & \tcode{brush_props}
 \\
 Surface properties
 & \tcode{render_props}
 \\
 Clip properties
 & \tcode{clip_props}
 \\
\end{libreqtab2}

\rSec2 [\iotwod.surface.rendering.specificstate] {Specific state data}

\pnum
In addition to the common state data (\ref{\iotwod.surface.rendering.commonstate}), certain rendering and composing operations use state data that is specific to each of them:

\begin{libiotwodtab3e}
 {surface rendering and composing specific state data}
 {tab:\iotwod.surface.rendering.specificstate.listing}
 \\ \topline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Stroking
 & Stroke properties
 & \tcode{stroke_props}
 \\
 Stroking
 & Dashes
 & \tcode{dashes}
 \\
 Masking
 & Mask properties
 & \tcode{mask_props}
 \\
\end{libiotwodtab3e}

\rSec2 [\iotwod.surface.rendering.statedefaults] {State data default values}

\pnum
For all rendering and composing operations, the state data objects named above are provided using \tcode{optional<T>} class template arguments.

\pnum
If there is no contained value for a state data object, it is interpreted as-if the \tcode{optional<T>} argument contained a default constructed object of the relevant state data object.

\rSec1 [\iotwod.surface.coordinatespaces] {Standard coordinate spaces}

\pnum
There are four standard coordinate spaces relevant to the rendering and composing operations (\ref{\iotwod.surface.rendering}):
\begin{itemize}
\item the brush coordinate space;
\item the mask coordinate space;
\item the user coordinate space; and
\item the surface coordinate space.
\end{itemize}

\pnum
The \term{brush coordinate space} is the standard coordinate space of the source brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the brush properties' brush matrix (\ref{\iotwod.brushprops.summary}).

\pnum
The \term{mask coordinate space} is the standard coordinate space of the mask brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the mask properties' mask matrix (\ref{\iotwod.maskprops.summary}).

\pnum
The \term{user coordinate space} is the standard coordinate space of \tcode{basic_interpreted_path} objects. Its transformation matrix is a default-constructed \tcode{basic_matrix_2d}.

\pnum
The \term{surface coordinate space} is the standard coordinate space of the surface object's visual data. Its transformation matrix is the surface properties' surface matrix (\ref{\iotwod.renderprops.summary}).

\pnum
Given a point \tcode{pt}, a brush coordinate space transformation matrix \tcode{bcsm}, a mask coordinate space transformation matrix \tcode{mcsm}, a user coordinate space transformation matrix \tcode{ucsm}, and a surface coordinate space transformation matrix \tcode{scsm}, the following table describes how to transform it from each of these standard coordinate spaces to the other standard coordinate spaces:

\begin{libiotwodreqtab3}
 {Point transformations}
 {tab:\iotwod.surface.pointtransforms.listing}
 \\ \topline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endhead
 brush coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(bcsm.invert().transform_pt(pt))}.
 \\
 brush coordinate space
 & user coordinate space
 & \tcode{bcsm.invert().transform_pt(pt)}.
 \\
 brush coordinate space
 & surface coordinate space
 & \tcode{scsm.transform_pt(bcsm.invert().transform_pt(pt))}.
 \\
 user coordinate space
 & brush coordinate space
 & \tcode{bcsm.transform_pt(pt)}.
 \\
 user coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(pt)}.
 \\
 user coordinate space
 & surface coordinate space
 & \tcode{scsm.transform_pt(pt)}.
 \\
 surface coordinate space
 & brush coordinate space
 & \tcode{bcsm.transform_pt(scsm.invert().transform_pt(pt))}.
 \\
 surface coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(scsm.invert().transform_pt(pt))}.
 \\
 surface coordinate space
 & user coordinate space
 & \tcode{scsm.invert().transform_pt(pt)}.
 \\
\end{libiotwodreqtab3}

\rSec1 [\iotwod.surface.painting] {surface painting}

\pnum
When a painting operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the surface's visual data, determine if $sp$ is within the clip area (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the brush coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the surface's visual data in the manner specified by the surface's current \term{compositing operator} (\ref{\iotwod.renderprops.summary}), and modify the visual data of the surface at point $sp$ to reflect the result produced by application of the compositing operator.
\end{enumerate}

\rSec1 [\iotwod.surface.filling] {surface filling}

\pnum
When a filling operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the surface's visual data, determine if $sp$ is within the \term{clip area} (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the user coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $up$.
\item Using the source path (\ref{\iotwod.surface.rendering.sourcepath}) and the fill rule (\ref{\iotwod.brushprops.summary}), determine whether $up$ shall be filled; if so, proceed with the remaining steps.
\item Transform $up$ from the user coordinate space to the brush coordinate space (\ref{\iotwod.surface.coordinatespaces} and Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the surface's visual data in the manner specified by the surface's current compositing operator (\ref{\iotwod.renderprops.summary}), and modify the surface's visual data at point $sp$ to reflect the result produced by application of the compositing operator.
\end{enumerate}

\rSec1 [\iotwod.surface.stroking] {surface stroking}

\pnum
When a stroking operation is initiated on a surface, it is carried out for each figure in the source path (\ref{\iotwod.surface.rendering}).

\pnum
The following rules shall apply when a stroking operation is carried out on a figure:
\begin{enumerate}
\item No part of the surface's visual data that is outside of the clip area shall be modified.

\item If the figure is a closed figure, then the point where the end point of its final segment meets the start point of the initial segment shall be rendered as specified by the \term{line join} value (see: \ref{\iotwod.strokeprops.summary} and \ref{\iotwod.surface.rendering.specificstate}); otherwise the start point of the initial segment and end point of the final segment shall each by rendered as specified by the line cap value. The remaining meetings between successive end points and start points shall be rendered as specified by the line join value.

\item If the dash pattern (Table~\ref{tab:\iotwod.surface.rendering.specificstate.listing}) has its default value or if its \tcode{vector<float>} member is empty, the segments shall be rendered as a continuous path.

\item If the dash pattern's \tcode{vector<float>} member contains only one value, that value shall be used to define a repeating pattern in which the path is shown then hidden. The ends of each shown portion of the path shall be rendered as specified by the line cap value.

\item If the dash pattern's \tcode{vector<float>} member contains two or more values, the values shall be used to define a pattern in which the figure is alternatively rendered then not rendered for the length specified by the value. The ends of each rendered portion of the figure shall be rendered as specified by the line cap value. If the dash pattern's \tcode{float} member, which specifies an offset value, is not \tcode{0.0f}, the meaning of its value is \impldefplain{dash pattern!offset value}. If a rendered portion of the figure overlaps a not rendered portion of the figure, the rendered portion shall be rendered.
\end{enumerate}

\pnum
When a stroking operation is carried out on a figure, the width of each rendered portion shall be the \term{line width} (see: \ref{\iotwod.strokeprops.summary} and \ref{\iotwod.surface.rendering.specificstate}). Ideally this means that the diameter of the stroke at each rendered point should be equal to the line width. However, because there are an infinite number of points along each rendered portion, implementations may choose an \unspecnorm method of determining minimum distances between points along each rendered portion and the diameter of the stroke between those points shall be the same.
\begin{note}
This concept is sometimes referred to as a tolerance. It allows for a balance between precision and performance, especially in situations where the end result is in a non-exact format such as raster graphics data.
\end{note}

\pnum
After all figures in the path have been rendered but before the rendered result is composed to the surface's visual data, the rendered result shall be transformed from the user coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}).

\rSec1 [\iotwod.surface.masking] {surface masking}

\pnum
When a masking operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the surface's visual data, determine if $sp$ is within the clip area (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the mask coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $mp$.
\item Sample the alpha channel from point $mp$ of the mask brush and store the result in $mac$; if the visual data format of the mask brush does not have an alpha channel, the value of $mac$ shall always be $1.0$.
\item Transform $sp$ from the surface coordinate space to the brush coordinate space, resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the surface's visual data at point $sp$ in the manner specified by the surface's current compositing operator (\ref{\iotwod.renderprops.summary}), multiply each channel of the result produced by application of the compositing operator by $map$ if the visual data format of the surface's visual data is a premultiplied format and if not then just multiply the alpha channel of the result by $map$, and modify the surface's visual data at point $sp$ to reflect the multiplied result.
\end{enumerate}

\rSec1 [\iotwod.outputsurface.misc] {output surface miscellaneous behavior}

\pnum
What constitutes an output device is \impldefplain{output device}, with the sole constraint being that an output device must allow the user to see the dynamically-updated contents of the display buffer.
\begin{example}
An output device might be a window in a windowing system environment or the usable screen area of a smart phone or tablet.
\end{example}

\pnum
Implementations may allow more than one \tcode{basic_output_surface} object, \tcode{basic_unmanaged_output_surface} object, or a combination thereof to exist co-synchronously. \begin{note}
In windowing environments, implementations would likely support multiple objects of these types. In contrast, on a smart phone it is unlikely that an implementation would support multiple objects of these types due to environmental and platform constraints.
\end{note}

\pnum
It is not required that implementations support the existence of any \tcode{basic_unmanaged_output_surface} objects. See Table~\ref{tab:\iotwod.graphsurf.surfs.requirementstab}.

\pnum
All functions that perform rendering and composing operations operate on the back buffer. <TODO> Specify on a per-function basis rather than with a blanket statement that is probably inaccurate.

\rSec1 [\iotwod.outputsurface.state] {output surface state}

\pnum
Table~\ref{tab:\iotwod.outputsurface.state.listing} specifies the name, type, function, and default value for each item of a display surface's observable state.

\begin{libreqtab4b}
	{Output surface observable state}
	{tab:\iotwod.outputsurface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	\term{Letterbox brush} &
	\tcode{brush} &
	This is the brush that shall be used as specified by \tcode{scaling::letterbox} (Table~\ref{tab:\iotwod.scaling.meanings}) &
	\tcode{brush\{ \{ rgba_color::black \} \}} \\ \rowsep
	
	\term{Letterbox brush props} &
	\tcode{brush_props} &
	This is the brush properties for the letterbox brush &
	\tcode{brush_props\{ \}} \\ \rowsep
	
	\term{Scaling type} &
	\tcode{scaling} &
	When the user scaling callback is equal to its default value, this is the type of scaling that shall be used when transferring the back buffer to the display buffer &
	\tcode{scaling::letterbox}\\ \rowsep
	
	\term{Draw width} &
	\tcode{int} &
	The width in pixels of the back buffer. The minimum value is \tcode{1}. The maximum value is \unspecnorm. Because users can only request a preferred value for the draw width when setting and altering it, the maximum value may be a run-time determined value. If the preferred draw width exceeds the maximum value, then if a preferred draw height has also been supplied then implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the preferred draw height otherwise implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the current draw height &
	\textit{N/A}
	\begin{note}
	It is impossible to create an output surface object without providing a preferred draw width value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Draw height} &
	\tcode{int} &
	The height in pixels of the back buffer. The minimum value is \tcode{1}. The maximum value is \unspecnorm. Because users can only request a preferred value for the draw height when setting and altering it, the maximum value may be a run-time determined value. If the preferred draw height exceeds the maximum value, then if a preferred draw width has also been supplied then implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred draw width and the preferred draw height otherwise implementations should provide a back buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the current draw width and the preferred draw height &
	\textit{N/A}
	\begin{note}
	It is impossible to create an output surface object without providing a preferred draw height value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Draw format} &
	\tcode{format} &
	The pixel format of the back buffer. When an output surface object is created, a preferred pixel format value is provided. If the implementation does not support the preferred pixel format value as the value of draw format, the resulting value of draw format is \impldefplain{display_surface!unsupported draw format} &
	\textit{N/A}
	\begin{note}
	It is impossible to create an output surface object without providing a preferred draw format value; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Display width} &
	\tcode{int} &
	The width in pixels of the display buffer. The minimum value is \unspecnorm. The maximum value is \unspecnorm. Because users can only request a preferred value for the display width when setting and altering it, both the minimum value and the maximum value may be run-time determined values. If the preferred display width is not within the range between the minimum value and the maximum value, inclusive, then if a preferred display height has also been supplied then implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the preferred display height otherwise implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the current display height &
	\textit{N/A}
	\begin{note}
	It is impossible to create an output surface object without providing a preferred display width value since in the absence of an explicit display width argument the mandatory preferred draw width argument is used as the preferred display width; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Display height} &
	\tcode{int} &
	The height in pixels of the display buffer. The minimum value is \unspecnorm. The maximum value is \unspecnorm. Because users can only request a preferred value for the display height when setting and altering it, both the minimum value and the maximum value may be run-time determined values. If the preferred display height is not within the range between the minimum value and the maximum value, inclusive, then if a preferred display width has also been supplied then implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the preferred display width and the preferred display height otherwise implementations should provide a display buffer with the largest dimensions possible that maintain as nearly as possible the aspect ratio between the current display width and the preferred display height &
	\textit{N/A}
	\begin{note}
	It is impossible to create an output surface object without providing a preferred display height value since in the absence of an explicit display height argument the mandatory preferred draw height argument is used as the preferred display height; as such a default value cannot exist.
	\end{note} \\ \rowsep
	
	\term{Auto clear} &
	\tcode{bool} &
	If \tcode{true} the implementation shall call \tcode{clear}, which shall clear the back buffer, immediately before it executes the draw callback &
	\tcode{false} \\ \rowsep
	
	\term{Refresh rate} &
	\tcode{refresh_rate} &
	The \tcode{refresh_rate} value that determines when the draw callback shall be called while output surface\tcode{::show} is being executed &
	\tcode{refresh_rate::as_fast_as_possible} \\ \rowsep
	
	\term{Desired frame rate} &
	\tcode{float} &
	This value is the number of times the draw callback shall be called per second while output surface\tcode{::show} is being executed when the value of refresh rate is \tcode{refresh_rate::fixed}, subject to the additional requirements documented in the meaning of \tcode{refresh_rate::fixed} (Table~\ref{tab:\iotwod.refreshrate.meanings}) \\ \rowsep
	
\end{libreqtab4b}