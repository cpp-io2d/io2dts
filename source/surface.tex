%!TEX root = io2d.tex
\rSec0 [surface] {Class \tcode{surface}}

\pnum
A \term{rendering and composing operation} is an operation that is either a single-phase operation consisting of a composing operation or a multi-phase operation consisting of a rendering operation followed by a composing operation.

\rSec1 [surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class surface {
  public:
    // \ref{surface.cons}, constructors, assignment operators, destructors:
    surface() = delete;
    surface(const surface&) = delete;
    surface& operator=(const surface&) = delete;
    surface(surface&& other) noexcept;
    surface& operator=(surface&& other) noexcept;
    virtual ~surface();

    // \ref{surface.modifiers.state}, state modifiers:
    virtual void finish() noexcept;
    void flush();
    void flush(error_code& ec) noexcept;
    shared_ptr<experimental::io2d::device> device();
    shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void device_offset(const vector_2d& offset);
    void device_offset(const vector_2d& offset, error_code& ec) noexcept;
    void map(const function<void(mapped_surface&)>& action);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const rectangle& extents,
      const function<void(mapped_surface&)>& action);
    void map(const rectangle& extents,
      const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    virtual void save();
    virtual void save(error_code& ec) noexcept;
    virtual void restore();
    virtual void restore(error_code& ec) noexcept;
    void reset_brush() noexcept;
    void brush(const experimental::io2d::brush& source);
    void brush(const experimental::io2d::brush& source, error_code& ec)
      noexcept;
    void antialias(experimental::io2d::antialias a) noexcept;
    void reset_dashes() noexcept;
    void dashes(const experimental::io2d::dashes& d);
    void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
    void fill_rule(experimental::io2d::fill_rule fr) noexcept;
    void line_cap(experimental::io2d::line_cap lc) noexcept;
    void line_join(experimental::io2d::line_join lj) noexcept;
    void line_width(double width) noexcept;
    void miter_limit(double limit) noexcept;
    void compositing_operator(experimental::io2d::compositing_operator co)
      noexcept;
    void clip(const experimental::io2d::path& p);
    void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
    void clip_immediate();
    void clip_immediate(error_code& ec) noexcept;
    void reset_path() noexcept;
    void path(const experimental::io2d::path& p);
    void path(const experimental::io2d::path& p, error_code& ec) noexcept;

    // \ref{surface.modifiers.immediatepath}, immediate path modifiers:
    experimental::io2d::path_factory& immediate() noexcept;

    // \ref{surface.modifiers.render}, render modifiers:
    void fill();
    void fill(error_code& ec) noexcept;
    void fill(const rgba_color& c);
    void fill(const rgba_color& c, error_code& ec) noexcept;
    void fill(const experimental::io2d::brush& b);
    void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void fill(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void fill(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void fill(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void fill_immediate();
    void fill_immediate(error_code& ec) noexcept;
    void fill_immediate(const rgba_color& c);
    void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
    void fill_immediate(const experimental::io2d::brush& b);
    void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void fill_immediate(const surface& s, const vector_2d& o = vector_2d{ }, 
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint();
    void paint(error_code& ec) noexcept;
    void paint(const rgba_color& c);
    void paint(const rgba_color& c, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b);
    void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void paint(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint(double alpha);
    void paint(double alpha, error_code& ec) noexcept;
    void paint(const rgba_color& c, double alpha);
    void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b, double alpha);
    void paint(const experimental::io2d::brush& b, double alpha,
      error_code& ec) noexcept;
    void paint(const surface& s, double alpha,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, double alpha, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, double alpha, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, double alpha, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void stroke();
    void stroke(error_code& ec) noexcept;
    void stroke(const rgba_color& c);
    void stroke(const rgba_color& c, error_code& ec) noexcept;
    void stroke(const experimental::io2d::brush& b);
    void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void stroke(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void stroke(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke_immediate();
    void stroke_immediate(error_code& ec) noexcept;
    void stroke_immediate(const rgba_color& c);
    void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
    void stroke_immediate(const experimental::io2d::brush& b);
    void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void stroke_immediate(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void stroke_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.maskrender}, mask render modifiers:
    void mask(const experimental::io2d::brush& mb);
    void mask(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask(const experimental::io2d::brush& mb, const rgba_color& c);
    void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
      error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none, 
      filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms);
    void mask(const surface& ms, error_code& ec) noexcept;
    void mask(const surface& ms, const rgba_color& c);
    void mask(const surface& ms, const rgba_color& c, error_code& ec) noexcept;
    void mask(const surface& ms, const experimental::io2d::brush& b);
    void mask(const surface& ms, const experimental::io2d::brush& b, 
      error_code& ec) noexcept;
    void mask(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void mask(const surface& ms, const vector_2d& mo);
    void mask(const surface& ms, const vector_2d& mo, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c);
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c,
      error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb);
    void mask_immediate(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c);
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms);
    void mask_immediate(const surface& ms, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const rgba_color& c);
    void mask_immediate(const surface& ms, const rgba_color& c, error_code& ec) 
      noexcept;
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b,
      error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo);
    void mask_immediate(const surface& ms, const vector_2d& mo, error_code& ec)
      noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.textrender}, text render modifiers:
    vector_2d show_text(const string& utf8, const vector_2d& pos);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c, error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    vector_2d show_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.transform}, transformation modifiers:
    void matrix(const matrix_2d& matrix) noexcept;
    
    // \ref{surface.modifiers.font}, font modifiers:
    void font_face(const string& typeface, font_slant sl, font_weight w);
    void font_face(const string& typeface, font_slant sl, font_weight w,
      error_code& ec) noexcept;
    void font_face(const experimental::io2d::font_face& f);
    void font_face(const experimental::io2d::font_face& f, error_code& ec)
      noexcept;
    void font_size(double s) noexcept;
    void font_matrix(const matrix_2d& m) noexcept;
    void font_options(const font_options& fo) noexcept;
    
    // \ref{surface.observers.state}, state observers:
    bool is_finished() const noexcept;
    experimental::io2d::content content() const noexcept;
    bool has_surface_resource() const noexcept;
    experimental::io2d::brush brush() const noexcept;
    experimental::io2d::antialias antialias() const noexcept;
    unsigned int dashes_count() const noexcept;
    experimental::io2d::dashes dashes() const;
    experimental::io2d::dashes dashes(error_code& ec) const noexcept;
    experimental::io2d::fill_rule fill_rule() const noexcept;
    experimental::io2d::line_cap line_cap() const noexcept;
    experimental::io2d::line_join line_join() const noexcept;
    double line_width() const noexcept;
    double miter_limit() const noexcept;
    experimental::io2d::compositing_operator compositing_operator() const
      noexcept;
    double tolerance() const noexcept;
    rectangle clip_extents() const noexcept;
    bool in_clip(const vector_2d& pt) const noexcept;
    vector<rectangle> clip_rectangles() const;
    vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
    
    // \ref{surface.observers.render}, render observers:
    rectangle fill_extents() const noexcept;
    rectangle fill_extents_immediate() const noexcept;
    bool in_fill(const vector_2d& pt) const noexcept;
    bool in_fill_immediate(const vector_2d& pt) const noexcept;
    rectangle stroke_extents() const noexcept;
    rectangle stroke_extents_immediate() const noexcept;
    bool in_stroke(const vector_2d& pt) const noexcept;
    bool in_stroke_immediate(const vector_2d& pt) const noexcept;
    experimental::io2d::font_extents font_extents() const noexcept;
    experimental::io2d::text_extents text_extents(const string& utf8) const;
    experimental::io2d::text_extents text_extents(const string& utf8,
      error_code& ec) const noexcept;
    
    // \ref{surface.observers.transform}, transformation observers:
    matrix_2d matrix() const noexcept;
    vector_2d user_to_surface(const vector_2d& pt) const noexcept;
    vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
    vector_2d surface_to_user(const vector_2d& pt) const;
    vector_2d surface_to_user(const vector_2d& pt, error_code& ec) const
      noexcept;
    vector_2d surface_to_user_distance(const vector_2d& dpt) const;
    vector_2d surface_to_user_distance(const vector_2d& dpt, error_code& ec)
      const noexcept;
    
    // \ref{surface.observers.font}, font observers:
    matrix_2d font_matrix() const noexcept;
    experimental::io2d::font_options font_options() const noexcept;
    experimental::io2d::font_face font_face() const;
    experimental::io2d::font_face font_face(error_code& ec) const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}
The \tcode{surface} class provides an interface for managing a graphics
data graphics resource and its observable state data
(\ref{surface.state}).

\pnum
A \tcode{surface} object is a move-only object.

\pnum
The \tcode{surface} class provides two ways to modify its graphics resource:
\begin{itemize}
\item Rendering and composing operations.
\item Mapping.
\end{itemize}

\pnum
\enternote
While a \tcode{surface} object manages a graphics data graphics resource, the \tcode{surface} class does not provide well-defined semantics for the graphics resource. The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable.
\exitnote

\pnum
Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics resource or inherit well-defined semantics for the graphics resource from a base class.

\pnum
\enterexample
The \tcode{image_surface} class and the \tcode{display_surface} class each specify that they manage a raster graphics data graphics resource and that the members they inherit from the \tcode{surface} class shall use that raster graphics data graphics resource as their graphics data graphics resource. Since, unlike graphics data, raster graphics data provides well-defined semantics, these classes meet the requirements for being directly instantiable.
\exitexample

\pnum
The definitions of the rendering and composing operations in \ref{surface.rendering} shall only be applicable when the graphics data graphics resource on which the \tcode{surface} members operate is a raster graphics data graphics resource. In all other cases, any attempt to invoke the rendering and composition operations shall result in undefined behavior.

\rSec1 [surface.state] {\tcode{surface} state}

\pnum
Table~\ref{tab:surface.state.listing} specifies the name, type, function, and default value for each item of a surface's observable state.

\rSec2 [surface.state.default] {\tcode{surface} state default values}

\begin{libreqtab4b}
	{Surface observable state}
	{tab:surface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	Current Brush &
	\tcode{brush} &
	This is the brush that shall be available for use when performing rendering and composing operations &
	\tcode{brush\{ \{ rgba_color::black() \} \}} \\ \rowsep

	General Antialiasing &
	\tcode{antialias} &
	This is the type of antialiasing that should be used when performing non-text rendering operations &
	\tcode{antialias::default_antialias}\\ \rowsep
	
	Dash Pattern &
	\tcode{dashes} &
	This specifies the pattern that shall be used when performing stroke rendering operations &
	\tcode{dashes\{ vector<double>(), 0.0 \}} \\ \rowsep
	
	Fill Rule &
	\tcode{fill_rule} &
	This controls which areas of paths shall be eligible to be filled when performing fill rendering operations &
	\tcode{fill_rule::winding} \\ \rowsep
	
	Line Cap &
	\tcode{line_cap} &
	This specifies how the end of a path segment that is not joined to another path segment shall be rendered when performing stroke rendering operations &
	\tcode{line_cap::butt} \\ \rowsep
	
	Line Join &
	\tcode{line_join} &
	This specifies how the join point of two path segments that are joined to each other shall be rendered when performing stroke rendering operations &
	\tcode{line_join::miter} \\ \rowsep
	
	Line Width &
	\tcode{double} &
	This is the width, in surface coordinate space units, that shall be used to determine the rendered width of path segments when performing a stroke rendering operation &
	\tcode{2.0} \\ \rowsep
	
	Miter Limit &
	\tcode{double} &
	This is the value that shall be used to calculate whether a line join shall be mitered or beveled when the value of Line Join is \tcode{line_join::miter}. &
	\tcode{10.0} \\ \rowsep
	
	Composition Operator &
	\tcode{compositing_operator} &
	This specifies the composition algorithm that shall be used when performing rendering operations &
	\tcode{compositing_operator::over} \\ \rowsep
	
	Tolerance &
	\tcode{double} &
	This is the value, in surface coordinate space units, that should be used when transforming non-linear path segments into linear path segments when performing rendering operations &
	\tcode{\impldef{\tcode{surface}!Tolerance}} \\ \rowsep
	
	Clip Area &
	\unspec (see \ref{surface.state.default}, below) &
	The areas of the surface which shall be the only areas in which composing operations may have any effect &
	An area which contains the entire area of the surface \\ \rowsep
	
	Current Path &
	\tcode{path} &
	This is the \tcode{path} object that shall be used when performing non-immediate rendering operations &
	\tcode{path\{ path_factory\{ \} \}} \\ \rowsep
	
	Immediate Path &
	\tcode{path_factory} &
	This is the \tcode{path_factory} object that shall be used when performing immediate rendering operations &
	\tcode{path_factory\{ \}} \\ \rowsep
	
	Transformation Matrix &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from an object's local coordinate space to the surface's coordinate space when performing rendering operations &
	\tcode{matrix_2d::init_identity\{ \}} \\ \rowsep
	
	Font Face &
	\tcode{font_face} &
	This is the font that shall be used when performing text rendering operations &
	\tcode{\impldef{\tcode{surface}!Font Face}} \\ \rowsep
	
	Font Matrix &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from a font's local coordinate space to the surface's coordinate space when performing text rendering operations &
	\tcode{matrix_2d::init_scale\{ \{ 10.0, 10.0 \} \}} \\ \rowsep
	
	Font Options &
	\tcode{font_options} &
	This is the \tcode{font_options} object that shall be used to determine certain aspects of how a font should be rendered when performing text rendering operations &
	\tcode{font_option\{ antialias::default_antialias, subpixel_order::default_subpixel_order \}} \\ \rowsep
	
\end{libreqtab4b}

\pnum
\enternote
The Clip Area may be modified by intersecting the current Clip Area with the areas of a \tcode{path} object that would be filled according to the current Fill Rule. The resulting Clip Area will only contain areas that were already in the Clip Area and does not need to be a valid \tcode{path} object since the Clip Area is only guaranteed to be observable by the effects it has on composing operations. For this reason, the Clip Area's type is unspecified. The Clip Area may also be modified by resetting it to its default value, which is the only way of enlarging the current Clip Area.
\exitnote

\rSec2 [surface.state.save] {\tcode{surface} saved state}

\pnum
A surface object provides an interface to save its current state and subsequently restore it.

\pnum
Save and restore operations are performed using \tcode{surface::save} and \tcode{surface::restore}, respectively.

\pnum
Save and restore operations may be nested.

\pnum
Each call to \tcode{surface::restore} restores a surface object's state to its values at the time of the most recent call to \tcode{surface::save}.

\pnum
The following list denotes each item of observable state that shall be saved by \tcode{surface::save} and restored by \tcode{surface::restore}, using the state item names listed in Table~\ref{tab:surface.state.listing}:

\begin{itemize}
	\item Current Brush
	\item General Antialiasing
	\item Dash Pattern
	\item Fill Rule
	\item Line Cap
	\item Line Join
	\item Line Width
	\item Miter Limit
	\item Compositing Operator
	\item Tolerance
	\item Clip Area
	\item Current Path
	\item Immediate Path
	\item Transformation Matrix
	\item Font Face
	\item Font Matrix
	\item Font Options
\end{itemize}

\rSec1 [surface.rendering] {\tcode{surface} rendering and composing}

\pnum
The \tcode{surface} class provides five fundamental rendering and composing operations:
\begin{libreqtab2}
 {\tcode{surface} rendering and composing operations}
 {tab:surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{surface::paint}
 \\
 Filling
 & \tcode{surface::fill}, \tcode{surface::fill_immediate}
 \\
 Stroking
 & \tcode{surface::stroke}, \tcode{surface::stroke_immediate}
 \\
 Masking
 & \tcode{surface::mask}, \tcode{surface::mask_immediate}
 \\
 Typesetting
 & \tcode{surface::draw_text}
 \\
\end{libreqtab2}

\pnum
The filling, stroking, and masking operations each provide two functions for invoking their functionality.

\pnum
Certain rendering and composing operations require a \term{source path}, which is a native path geometry. The rendering and composing operations invoked by the \tcode{surface::fill}, \tcode{surface::stroke}, and \tcode{surface::mask} functions shall use the \tcode{surface} object's Current Path as their source path. The rendering and composing operations invoked by the \tcode{surface::fill_immediate}, \tcode{surface::stroke_immediate}, and \tcode{surface::mask_immediate} functions shall use of the surface's Immediate Path state data in their operation.

\pnum
Provided that none of the function calls results in an error, given a \tcode{surface} object \tcode{s}, there shall be no observable difference in the results of:
\begin{itemize}
	\item calling \tcode{surface::fill_immediate} on \tcode{s} versus calling \tcode{surface::fill} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	\item calling \tcode{surface::stroke_immediate} on \tcode{s} versus calling \tcode{surface::stroke} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	\item calling \tcode{surface::mask_immediate} on \tcode{s} versus calling \tcode{surface::mask} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function.
\end{itemize}

\pnum
Where a \tcode{path} object is constructed from a surface's Immediate Path and is then successfully set as the Current Path, the observable effects

\pnum
The painting operation is a single-part operation consisting of a composing operation. Each of the other operations is a multi-part operation consisting of a rendering operation followed by a composing operation.

\pnum
\enternote
By definition (see Table \ref{tab:surface.state.listing}), the Clip Area always applies to all composing operations and therefore to all rendering and composing operations. This is true even if no mention is made of the Clip Area in the description of a rendering and composing operation or if the description of a rendering and composing operation uses phraseology that could otherwise be read as being unconstrained. Because of this, mention of the applicability of the Clip Area will be omitted in the descriptions of the rendering and composing operations that follow.
\exitnote

\pnum
Each of the five fundamental rendering and composing operations has its own set of minimum arguments.
\begin{enumerate}
	\item The painting operation has no minimum arguments.
	\item The filling operation has no minimum arguments.
	\item The stroking operation has no minimum arguments.
	\item The masking operation has one minimum argument: an object, used as the mask (see \ref{surface.rendering.masking}), that is of type \tcode{brush} or type \tcode{surface}.
	\item The typesetting operation has two minimum arguments: an object, used as the text that is rendered and composed to the surface (see \ref{surface.rendering.typesetting}), that is of type \tcode{string}; and, an object, used to specify the coordinates at which the origin of the first character of the text is positioned (see \ref{surface.rendering.typesetting}), of type \tcode{vector_2d}.
\end{enumerate}

\pnum
If an \tcode{error_code} argument (see \ref{\iotwod.err.report}) is passed to a rendering and composing operation, it shall be considered part of the set of minimum arguments for that operation.

\pnum
For the masking operation, where a \tcode{surface} object is used as the mask argument, it may be immediately followed by an argument of type \tcode{vector_2d} which shall be used as the mask surface origin (see \ref{surface.rendering.masking}). If a mask surface origin argument is passed to the masking operation, it shall be considered part of the set of minimum arguments for that operation.

\pnum
The rendering and composing operations shall have access to a \term{source brush}, a raster graphics data graphics resource which has the same observable behavior as a \tcode{brush} object even where it is not required to be a \tcode{brush} object, each time they are invoked.

\pnum
When a rendering and composing operation is invoked with only those arguments that are part of its set of minimum arguments, the surface's Current Brush shall be the source brush.

\pnum
When a rendering and composing operation is invoked with \term{extra arguments}, additional arguments beyond those that are part of its set of minimum arguments, the source brush shall be as follows, with any errors reported as specified in Error reporting (\ref{\iotwod.err.report}):
\begin{itemize}
	\item Where there is one extra argument and it is a \tcode{brush} object, the source brush shall be that \tcode{brush} object.
	\item Where there is one extra argument and it is an \tcode{rgba_color} object, the source brush shall be the same as if it were a \tcode{brush} object constructed from a \tcode{solid_color_brush_factory} constructed from the extra argument.
	\item Where there is more than one extra argument, including default arguments, and the first extra argument is a \tcode{surface} object, the source brush shall be the same as if it were a \tcode{brush} object \tcode{b} constructed from a \tcode{surface_brush_factory} constructed from the \tcode{surface} object extra argument with the following adjustments:
	\begin{enumerate}
		\item The \tcode{surface} object extra argument should be used directly; no copy of it should be made. This differs from the \tcode{surface_brush_factory} class, which requires that a copy be made and that only the copy be used.
		\item The source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::extend} was called on \tcode{b} with the \tcode{extend} object extra argument passed to \tcode{brush::extend} as an argument.
		\item The source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::filter} was called on \tcode{b} with the \tcode{filter} object extra argument passed to \tcode{brush::filter} as an argument.
		\item If there is an extra argument of type \tcode{vector_2d}, the source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::matrix} was called on \tcode{b} with the result of passing the \tcode{vector_2d} object extra argument to \tcode{matrix_2d::init_translate} passed to \tcode{brush::matrix} as an argument.
		\item If there is an extra argument of type \tcode{matrix_2d}, the source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::matrix} was called on \tcode{b} with the \tcode{matrix} object extra argument passed to \tcode{brush::matrix} as an argument.
	\end{enumerate}
\end{itemize}

\pnum
\enternote
The rendering and composing operations each have the same combinations of extra arguments, all of which are covered by the above requirements that determine the source brush when extra arguments are present.
\exitnote

\pnum
When a rendering and composing operation needs to obtain a value for a pixel from the source brush, it shall do so as specified in \ref{surface.sampling}. %% If the source brush is an object of type \tcode{brush}, and invoking \tcode{brush::type} on it returns \tcode{brush_type::linear} or \tcode{brush_type::radial}, \ref{gradients.sampling} shall also apply.

\pnum
A \tcode{surface} object shall not be used as a mask or as a source brush for any rendering and composing operations invoked on that \tcode{surface} object. No diagnostic is required.
\enternote
When a \tcode{brush} object \tcode{b} is created from a \tcode{surface} object \tcode{s} using the \tcode{surface_brush_factory} class, \tcode{b} may be used as a mask or as a source brush for rendering and composing operations invoked on \tcode{s} because the \tcode{surface_brush_factory} class creates a copy of \tcode{s} (see \ref{surfacebrushfact}), thereby avoiding the aliasing problems and race conditions that this requirement exists to block.
\exitnote

\rSec1 [surface.sampling] {Sampling from a raster graphics data graphics resource}

\pnum
A ...

\pnum
For every raster graphics data graphics resource that may be used as a source brush or a mask it shall be possible to provide an input value in the form of a point and receive an output value in the form of a pixel. ***FIXME*** Need to deal with formats - are they an input or is the returned pixel always in the RGBA color space with the conversion to the required format happening as a subsequent step? Also, something needs to be done to ensure that the output is the same value both for every call with the same input and state and for all implementations - a graphics data graphics resource currently has no coordinate system which makes that problematic or even impossible. together with its graphics state data, if any,

\pnum
In general, the effects of the \tcode{extend} value on a \tcode{brush} object are documented in \ref{extend}.

\pnum
The initial \tcode{extend} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.

%\pnum
%If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::mesh}, the \tcode{brush}'s \tcode{extend} value is ignored and all operations proceed as if the \tcode{extend} value is \tcode{extend::none}.
%
\rSec1 [brush.filter] {Effects of its \tcode{filter} value of a \tcode{brush} object}

\pnum
The effects of the \tcode{filter} value on a \tcode{brush} object are documented in \ref{filter}.

\pnum
The initial \tcode{filter} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.

\rSec1 [brush.matrix] {Effects of its \tcode{matrix_2d} value on a \tcode{brush} object}

\pnum
The initial \tcode{matrix_2d} value of a \tcode{brush} object is \tcode{matrix_2d::init_identity()}.

\pnum
If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::solid_color}, the brush is treated as if its data area is an infinite plane. As such\ the \tcode{brush}'s \tcode{extend}, \tcode{filter}, and \tcode{matrix_2d} values do not matter. Regardless of the coordinate from which data from the \tcode{brush} is requested, the \tcode{brush} will always return the color which the \tcode{solid_color_brush_factory} that was used to create it had at the time the \tcode{brush} was created.

\pnum
All brushes except \tcode{brush_type::solid_color} brushes are sensitive to coordinates and as such will need to have an appropriate \tcode{matrix_2d} value to achieve the desired outcome.

\pnum
\enternote
Sometimes the initial \tcode{matrix_2d} value will be the appropriate value. As such there is no requirement to set a \tcode{matrix_2d} value unless you need something other than the initial value.
\exitnote

\pnum
When it is necessary for the implementation to retrieve data from a \tcode{brush} object to calculate the resulting color value of a coordinate on a \tcode{surface}, the coordinate is first transformed using the \tcode{brush} object's \tcode{matrix_2d}.

\pnum
A \tcode{brush} object's \tcode{matrix_2d} value transforms a coordinate from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space.

\pnum
\enterexample
Take a \tcode{brush b} which has a \tcode{matrix_2d} value of \tcode{matrix_2d::init_scale(\{ 2.0, 0.25 \})}.

\pnum
If a request for data from \tcode{b} at the point \tcode{vector_2d(30.0, 18.0)} is made, by operation of \tcode{b}'s \tcode{matrix_2d}, the actual data that will be retrieved is the data at \tcode{vector_2d(60.0, 4.5)} (after application of \tcode{b}'s \tcode{extend} value as described above).

\pnum
Notice that although the \xaxis scale is set to \tcode{2.0} and the \yaxis scale is set to \tcode{0.25}, the actual effect is the same as if the \tcode{b}'s data itself had been scaled to the inverse of those values. This is because the transformation goes from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space rather than from the \tcode{brush}'s coordinate space to the \tcode{surface}'s coordinate space.
\exitexample

\pnum
\enternote
For the same reason as explained in the example above, if you wish to translate the origin point of a \tcode{brush} to the point \tcode{vector_2d p} of a \tcode{surface}, you would do so by setting \tcode{matrix_2d::init_translate(-p)} as the brush's \tcode{matrix_2d} value.
\exitnote

\rSec2 [surface.rendering.painting] {\tcode{surface} painting}

\pnum
When a painting operation is initiated on a surface, the implementation shall compose the source brush with the surface's graphics data graphics resource in the manner specified by the surface's current Composition Operator and modify the surface's graphics data graphics resource to reflect the results of that operation.

\rSec2 [surface.rendering.filling] {\tcode{surface} filling}

\pnum
When a filling operation is initiated on a surface, the implementation shall produce results as if the following steps were performed:
\begin{itemize}
	\item The surface's 
\end{itemize}

\rSec2 [surface.rendering.stroking] {\tcode{surface} stroking}

\pnum
***FIXME***

\rSec2 [surface.rendering.masking] {\tcode{surface} masking}

\pnum
***FIXME*** used to specify the coordinates at which the origin of the \tcode{surface} object being used as the mask is positioned

\rSec2 [surface.rendering.typesetting] {\tcode{surface} typesetting}

\pnum
***FIXME***



\rSec1 [surface.cons] {\tcode{surface} constructors, assignment operators, and destructors}

\indexlibrary{\idxcode{surface}!destructor}
\begin{itemdecl}
virtual ~surface();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Destroys an object of class \tcode{surface}.
\end{itemdescr}

\rSec1 [surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{finish}}
\indexlibrary{\idxcode{finish}!\idxcode{surface}}
\begin{itemdecl}
virtual void finish() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Releases all resources managed by the \tcode{surface} if \tcode{!is_finished()}, otherwise does nothing.

\pnum
\postconditions
\tcode{is_finished()} shall return \tcode{true}. \tcode{has_surface_resource()} shall return \tcode{false}.

\pnum
\remarks
Once this function has been called, the surface is \term{finished}. The only valid operations on a finished surface are destruction, calling \tcode{finish()}, calling \tcode{has_surface_resource()}, and calling \tcode{is_finished()}. Any other operation on a finished surface or any attempt to use a finished \tcode{surface} or \tcode{surface}-derived object as an argument to a function produces undefined behavior except as otherwise noted.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}
\indexlibrary{\idxcode{flush}!\idxcode{surface}}
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
The user shall be able to use the implementation's underlying surface without introducing a race condition. This means that any pending surface operations shall be executed, batched, or otherwise committed to the underlying technologies. Saved surface state, if any, shall also be restored before this function returns.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists primarily to allow the user to take control of the underlying surface using an implementation-provided native handle. The implementation's responsibility is to ensure that the user can safely use the underlying surface.
\enternote
This function flushes the native surface so that it can safely be rendered to or, if the underlying technology supports it, be used as a texture to be sampled from. It is not required to flush the device or context that is rendering to it.
\exitnote

\pnum
\errors

\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device}}
\indexlibrary{\idxcode{device}!\idxcode{surface}}
\begin{itemdecl}
shared_ptr<experimental::io2d::device> device();
shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A shared pointer to the \tcode{device} object for this \tcode{surface}.	
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const rectangle& rect);
void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Informs the implementation that external changes were potentially made to the entire underlying graphics resource, or to the area defined by \tcode{rect} if that parameter is present.

\pnum
\remarks
After external changes are made to this \tcode{surface} object's underlying graphics resource, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
No call to this function shall be required solely as a result of changes made to a surface using the functionality provided by \tcode{surface::map}.
\enternote
The \tcode{mapped_surface} type, which is used by \tcode{surface::map}, provides its own functionality for managing any such changes.
\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device_offset}}
\indexlibrary{\idxcode{device_offset}!\idxcode{surface}}
\begin{itemdecl}
void device_offset(const vector_2d& offset);
void device_offset(const vector_2d& offset, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Stores the value of \tcode{offset}. The value will be added to all coordinates after they have been transformed by the \tcode{surface} object's transformation matrix.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}
\indexlibrary{\idxcode{map}!\idxcode{surface}}
\begin{itemdecl}
void map(const function<void(mapped_surface&)>& action);
void map(const function<void(mapped_surface&, error_code&)>& action, error_code& ec);
void map(const function<void(mapped_surface&)>& action, const rectangle& extents);
void map(const function<void(mapped_surface&, error_code&)>& action,
  const rectangle& extents, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Maps \tcode{*this} to a newly created \tcode{image_surface} which allows direct manipulation of the underlying surface. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}.
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it.
\end{itemdescr}

\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates an \tcode{image_surface} that allows direct manipulation of the underlying surface. The \tcode{image_surface} will be scoped to the area of the underlying surface defined by \tcode{extents}. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}. 
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it. 
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{save}}
\indexlibrary{\idxcode{save}!\idxcode{surface}}
\begin{itemdecl}
virtual void save();
virtual void save(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Saves the current observable state of \tcode{*this} to a newly created entry on the internal stack of saved states.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{restore}}
\indexlibrary{\idxcode{restore}!\idxcode{surface}}
\begin{itemdecl}
virtual void restore();
virtual void restore(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	A matching call to \tcode{surface::save} on \tcode{*this}.
	
	\pnum
	\effects
	Restores the observable state of \tcode{*this} from the most recent entry on the internal stack of saved states and removes that entry from the stack.
	
	\pnum
	\throws
	\tcode{system_error} with an error category of \tcode{io2d_error_category} and an error condition of \tcode{io2d_error::invalid_restore} if there are no entries on the stack of saved states when this function is called.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_brush}}
\indexlibrary{\idxcode{reset_brush}!\idxcode{surface}}
\begin{itemdecl}
void reset_brush() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets a default \tcode{pattern} object.
	\enternote
	The default \tcode{pattern} object is always an opaque black solid color 
	pattern, equivalent to the pattern created by 
	\tcode{solid_color_pattern_factory(rgba_color::black).get_pattern()}. It is 
	not required to be the same object throughout the lifetime of the program.
	\exitnote
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a default \tcode{pattern} object.
\end{itemdescr}

\begin{itemdecl}
void brush(const experimental::io2d::brush& source);
void brush(const experimental::io2d::brush& source,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets \tcode{source} as the current \tcode{pattern} object.
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a \tcode{pattern} object with the same observable state as \tcode{source} object.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
void antialias(experimental::io2d::antialias a) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current \tcode{antialias} state to \tcode{a}.
	
	\pnum
	\postconditions
	\tcode{get_antialias()} returns the value of \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_dashes}}
\indexlibrary{\idxcode{reset_dashes}!\idxcode{surface}}
\begin{itemdecl}
void reset_dashes() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to be a solid line.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{make_tuple<vector<double>, double>(\{ \}, 0.0)}. \tcode{get_dashes_count()} will return \tcode{0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(const experimental::io2d::dashes& d);
void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to the value of \tcode{d}.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{d}. \tcode{get_dashes_count()} will return the value of \tcode{static_cast<int>(get<0>(d).size())}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
void fill_rule(experimental::io2d::fill_rule fr) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current fill rule to the value of \tcode{fr}.
	
	\pnum
	\postconditions
	\tcode{get_fill_rule()} will return the value of \tcode{fr}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
void line_cap(experimental::io2d::line_cap lc) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line cap to the value of \tcode{lc}.
		
	\pnum
	\postconditions
	\tcode{get_line_cap()} will return the value of \tcode{lc}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
void line_join(experimental::io2d::line_join lj) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line join to the value of \tcode{lj}.
	
	\pnum
	\postconditions
	\tcode{get_line_join()} will return the value of \tcode{lj}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{set_line_width}}
\indexlibrary{\idxcode{set_line_width}!\idxcode{surface}}
\begin{itemdecl}
void line_width(double width) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line width to \tcode{max(width, 0.0)}.
	
	\pnum
	\postconditions
	\tcode{get_line_width()} will return \tcode{max(width, 0.0)}.
	
	\pnum
	\remarks
	Line width is in pre-transformation units and is used with the \tcode{surface::stroke} functions. It postulates a round brush with a diameter of the current line width. The shape and size of the stroke when rendered depends on other state data.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
void miter_limit(double limit) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the Miter Limit to \tcode{limit}.
	
	\pnum
	The Miter Limit shall be clamped to be within the range defined by the \impldef{Miter Limit!minimum} minimum value and the \impldef{Miter Limit!maximum} maximum value, inclusive. The \impdef minimum value shall not be greater than \tcode{2.0} and the \impdef maximum value shall not be less than \tcode{10.0}.
	
	\pnum
	\enternote
	The Miter Limit only applies when the Line Join is set to \tcode{line_join::miter}.
	\exitnote
	
	\pnum
	\remarks
	The Miter Limit works as follow. The length of the miter is divided by the width of the line. If the resulting value is greater than the Miter Limit, the join will be beveled, otherwise it will be mitered.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
void compositing_operator(experimental::io2d::compositing_operator co)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current compositing operator to the value of \tcode{co}.
	
	\pnum
	\postconditions
	\tcode{get_compositing_operator} will return the value of \tcode{co}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip}}
\indexlibrary{\idxcode{clip}!\idxcode{surface}}
\begin{itemdecl}
void clip(const experimental::io2d::path& p);
void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current clip area to be the intersection of the current clip area and the current path where the current path's area is determined in the same way as if the current path were filled according to the current fill rule.
	
	\pnum
	\realnotes
	The clip area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_immediate}}
\indexlibrary{\idxcode{clip_immediate}!\idxcode{surface}}
\begin{itemdecl}
void clip_immediate();
void clip_immediate(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_path}}
\indexlibrary{\idxcode{reset_path}!\idxcode{surface}}
\begin{itemdecl}
void reset_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\begin{itemdecl}
void path(const experimental::io2d::path& p);
void path(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to \tcode{p}.
	
	\pnum
	\remarks
	Processing the path data so that it is properly transformed can be done at the time it is first set as a path on a \tcode{surface} object or any time before that. The untransformed \tcode{vector<path_data>} must be retained to ensure that a path can be properly recreated at any time. The steps for converting an untransformed \tcode{vector<path_data>} to transformed path data are found at .
\end{itemdescr}

\rSec1 [surface.modifiers.immediatepath] {\tcode{surface} immediate path modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}

\rSec1 [surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\postconditions

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [surface.modifiers.maskrender] {\tcode{surface} mask render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects

\pnum
\postconditions

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks

\pnum
\errors

\pnum
\realnotes

\end{itemdescr}

\rSec1 [surface.modifiers.textrender] {\tcode{surface} text render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}

\rSec1 [surface.modifiers.transform] {\tcode{surface} transformation modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}


\rSec1 [surface.modifiers.font] {\tcode{surface} font modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{}}
\indexlibrary{\idxcode{}!\idxcode{surface}}
\begin{itemdecl}
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects


\pnum
\postconditions


\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).


\pnum
\remarks


\pnum
\errors


\pnum
\realnotes


\end{itemdescr}


\rSec1 [surface.observers.state] {\tcode{surface} state observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [surface.observers.render] {\tcode{surface} render observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [surface.observers.transform] {\tcode{surface} transformation observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}

\rSec1 [surface.observers.font] {\tcode{surface} font observers}

%\indexlibrary{\idxcode{surface}!\idxcode{}}
%\indexlibrary{\idxcode{}!\idxcode{surface}}
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\returns
%	
%\end{itemdescr}
