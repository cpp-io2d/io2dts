%!TEX root = io2d.tex
\rSec0 [\iotwod.surface] {Class \tcode{surface}}

\rSec1 [\iotwod.surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class surface {
  public:
    // See~\ref{\iotwod.req.native}
    typedef @\impdef@ native_handle_type;
    native_handle_type native_handle() const;

    // tuple<dashes, offset>
    typedef std::tuple<std::vector<double>, double> dashes;

    // \ref{\iotwod.surface.cons}, constructors, assignment operators, destructors:
    surface() = delete;
    surface(const surface&) = delete;
    surface& operator=(const surface&) = delete;
    surface(surface&& other) noexcept;
    surface& operator=(surface&& other) noexcept;
    virtual ~surface();

    // \ref{\iotwod.surface.modifiers.state}, state modifiers:
    virtual void finish() noexcept;
    void flush();
    void flush(error_code& ec) noexcept;
    std::shared_ptr<std::experimental::io2d::device> device();
    std::shared_ptr<std::experimental::io2d::device> device(error_code& ec)
      noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void device_offset(const vector_2d& offset);
    void device_offset(const vector_2d& offset, error_code& ec) noexcept;
    void map(const std::function<void(mapped_surface&)>& action);
    void map(const std::function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const rectangle& extents,
      const std::function<void(mapped_surface&)>& action);
    void map(const rectangle& extents,
      const std::function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    virtual void save();
    virtual void save(error_code& ec) noexcept;
    virtual void restore();
    virtual void restore(error_code& ec) noexcept;
    void reset_brush() noexcept;
    void brush(const std::experimental::io2d::brush& source);
    void brush(const std::experimental::io2d::brush& source, error_code& ec)
      noexcept;
    void antialias(std::experimental::io2d::antialias a) noexcept;
    void reset_dashes() noexcept;
    void dashes(const std::experimental::io2d::dashes& d);
    void dashes(const std::experimental::io2d::dashes& d, error_code& ec)
      noexcept;
    void fill_rule(std::experimental::io2d::fill_rule fr) noexcept;
    void line_cap(std::experimental::io2d::line_cap lc) noexcept;
    void line_join(std::experimental::io2d::line_join lj) noexcept;
    void line_width(double width) noexcept;
    void miter_limit(double limit) noexcept;
    void compositing_operator(std::experimental::io2d::compositing_operator co)
      noexcept;
    void clip(const std::experimental::io2d::path& p);
    void clip(const std::experimental::io2d::path& p, error_code& ec) noexcept;
    void clip_immediate();
    void clip_immediate(error_code& ec) noexcept;
    void reset_path() noexcept;
    void path(const std::experimental::io2d::path& p);
    void path(const std::experimental::io2d::path& p, error_code& ec) noexcept;

    // \ref{\iotwod.surface.modifiers.render}, render modifiers:
    void fill();
    void fill(const surface& s);
    void mask(const pattern& pttn);
    void mask(const surface& surface);
    void mask(const surface& surface, const vector_2d& origin);
    void paint();
    void paint(const surface& s);
    void paint(double alpha);
    void paint(const surface& s, double alpha);
    void stroke();
    void stroke(const surface& s);
    void show_text(const std::string& utf8);
    void show_glyphs(const std::vector<glyph>& glyphs);
    void show_text_glyphs(const std::string& utf8,
      const std::vector<glyph>& glyphs,
      const std::vector<text_cluster>& clusters, 
      bool clusterToGlyphsMapReverse = false);

    // \ref{\iotwod.surface.modifiers.transform}, transformation modifiers:
    void set_matrix(const matrix_2d& matrix);

    // \ref{\iotwod.surface.modifiers.font}, font modifiers:
    void select_font_face(const std::string& family, font_slant slant, 
      font_weight weight);
    void set_font_size(double size);
    void set_font_matrix(const matrix_2d& matrix);
    void set_font_options(const font_options& options);
    void set_font_face(const font_face& font_face);
    void set_scaled_font(const scaled_font& scaled_font);

    // \ref{\iotwod.surface.observers.state}, state observers:
    content get_content() const;
    vector_2d get_device_offset() const;
    bool has_surface_resource() const;
    pattern get_pattern() const;
    antialias get_antialias() const;
    int get_dashes_count() const;
    dashes get_dashes() const;
    fill_rule get_fill_rule() const;
    line_cap get_line_cap() const;
    line_join get_line_join() const;
    double get_line_width() const;
    double get_miter_limit() const;
    compositing_operator get_compositing_operator() const;
    double get_tolerance() const;
    rectangle get_clip_extents() const;
    bool in_clip(const vector_2d& pt) const;
    std::vector<rectangle> get_clip_rectangles() const;

    // \ref{\iotwod.surface.observers.render}, render observers:
    rectangle get_fill_extents() const;
    bool in_fill(const vector_2d& pt) const;
    rectangle get_stroke_extents() const;
    bool in_stroke(const vector_2d& pt) const;
    font_extents get_font_extents() const;
    text_extents get_text_extents(const std::string& utf8) const;
    text_extents get_glyph_extents(const std::vector<glyph>& glyphs) const;

    // \ref{\iotwod.surface.observers.transform}, transformation observers:
    matrix_2d get_matrix() const;
    vector_2d user_to_device() const;
    vector_2d user_to_device_distance() const;
    vector_2d device_to_user() const;
    vector_2d device_to_user_distance() const;

    // \ref{\iotwod.surface.observers.font}, font observers:
    matrix_2d get_font_matrix() const;
    font_options get_font_options() const;
    font_face get_font_face() const;
    scaled_font get_scaled_font() const;
  };
  
  // \ref{\iotwod.surface.nonmembers}, non-member functions:
  surface make_surface(@\impdef@) @\impdef@;
} } } }
\end{codeblock}

\rSec1 [\iotwod.surface.intro] {\tcode{surface} Description}

\pnum
\indexlibrary{\idxcode{surface}}
The \tcode{surface} class represents a surface on which graphics are rendered.

\pnum
A \tcode{surface} object is a stateful, move-only object.

\pnum
Rendering to a \tcode{surface} is accomplished by setting the appropriate state, often in the form of state objects such as \tcode{path} and \tcode{pattern}, and then calling one or more of the render functions to make the changes specified by the state to the surface resource managed by the \tcode{surface} object.

\pnum
A \tcode{surface} object is usually created by calling the \tcode{make_surface} \ref{\iotwod.surface.make_surface} function.

\rSec1 [\iotwod.surface.cons] {\tcode{surface} constructors, assignment operators, and destructors}

\indexlibrary{\idxcode{surface}!destructor}
\begin{itemdecl}
virtual ~surface();
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Destroys an object of class \tcode{surface}.
	
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{finish}}
\indexlibrary{\idxcode{finish}!\idxcode{surface}}
\begin{itemdecl}
virtual void finish() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Releases all resources associated with the \tcode{surface}.
	
	\pnum
	\remarks
	Once this function has been called, the surface is \term{finished}. The only valid operations on a finished surface are destruction and calling \tcode{finish} again (which will do nothing). Any other operation on a finished surface or any attempt to use a finished surface as an argument to a function produces undefined behavior.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}
\indexlibrary{\idxcode{flush}!\idxcode{surface}}
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	The user will be able to use the implementation's underlying surface without introducing a race condition. This means that any pending surface operations will be executed, batched, or otherwise committed to the underlying technologies. Saved surface state, if any, shall also be restored before this function returns.
	
	\pnum
	\remarks
	This function exists primarily to allow the user to take control of the 
	underlying surface using an implementation-provided native handle. The implementation's responsibility is to ensure that the user can safely use the underlying surface.
	\enternote
	This function flushes the native surface so that it can safely be rendered to or, if the underlying technology supports it, be used as a texture to be sampled from. It is not required to flush the device or context that is rendering to it.
	\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device}}
\indexlibrary{\idxcode{device}!\idxcode{surface}}%
\begin{itemdecl}
shared_ptr<std::experimental::io2d::device> device();
shared_ptr<std::experimental::io2d::device> device(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	A shared pointer to the \tcode{device} object for this \tcode{surface}.	
\end{itemdescr}

\rSec2 [\iotwod.surface::mark_dirty] {\tcode{surface::mark_dirty}}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Informs the implementation that external changes were made to the underlying surface.
	
	\pnum
	\remarks
	A program shall call this function first when using the \tcode{surface} object after external changes are made to its underlying surface; no diagnostic is required.
\end{itemdescr}

\begin{itemdecl}
void mark_dirty(const rectangle& rect);
void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Informs the implementation that external changes were made to the underlying surface within the area denoted by \tcode{rect}.
	
	\pnum
	\remarks
	This function shall be at least as efficient as \tcode{mark_dirty()}. A program shall call this function first when using the \tcode{surface} object after external changes are made to its underlying surface; no diagnostic is required.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{set_device_offset}}
\indexlibrary{\idxcode{set_device_offset}!\idxcode{surface}}
\begin{itemdecl}
void device_offset(const vector_2d& offset);
void device_offset(const vector_2d& offset, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Stores the value of \tcode{offset}. The value will be added to all coordinates after they have been transformed by the \tcode{surface} object's transformation matrix.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}
\indexlibrary{\idxcode{map}!\idxcode{surface}}
\begin{itemdecl}
void map(const std::function<void(mapped_surface&)>& action);
void map(const std::function<void(mapped_surface&, error_code&)>& action, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Maps \tcode{*this} to a newly created \tcode{image_surface} which allows direct manipulation of the underlying surface. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}.
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it.
\end{itemdescr}

\begin{itemdecl}
void map(const rectangle& extents,
  const std::function<void(mapped_surface&)>& action);
void map(const rectangle& extents,
  const std::function<void(mapped_surface&, error_code&)>& action,
  error_code& ec);
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Creates an \tcode{image_surface} that allows direct manipulation of the underlying surface. The \tcode{image_surface} will be scoped to the area of the underlying surface defined by \tcode{extents}. Whether changes are committed to the underlying surface immediately or only when the surface is unmapped is \impldef{\tcode{surface}!\tcode{map_to_image}}. Implementations may specify different commit behaviors for \tcode{surface::map_to_image()} and \tcode{surface::map_to_image(const rectangle\&)}.
	
	\pnum
	\returns
	An \tcode{image_surface} which, when changed, will change the underlying surface of \tcode{*this}. 
	\enternote
	Use of the returned \tcode{image_surface} is very limited. The only valid operations that may be performed with it are move construction, move assignment, destruction, \tcode{image_surface::set_data}, \tcode{image_surface::get_data}, \tcode{image_surface::get_format}, \tcode{image_surface::get_width}, \tcode{image_surface::get_height}, \tcode{image_surface::get_stride}, and passing it as an argument when calling \tcode{surface::unmap_image} on the \tcode{surface} object that created it. All other operations produce undefined behavior.
	\exitnote
	
	\pnum
	\remarks
	A \tcode{surface} object shall only be mapped once at any time; no diagnostic is required. A \tcode{surface} object that is mapped shall not be used until it is unmapped; no diagnostic is required. A mapped \tcode{surface} object can be unmapped by either destroying the \tcode{image_surface} object returned by this function or by passing the \tcode{image_surface} object returned by this function to the \tcode{unmap_image} member function of the \tcode{surface} object that created it. 
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{save}}
\indexlibrary{\idxcode{save}!\idxcode{surface}}
\begin{itemdecl}
virtual void save();
virtual void save(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Saves the current observable state of \tcode{*this} to a newly created entry on the internal stack of saved states.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{restore}}
\indexlibrary{\idxcode{restore}!\idxcode{surface}}
\begin{itemdecl}
virtual void restore();
virtual void restore(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\requires
	A matching call to \tcode{surface::save} on \tcode{*this}.
	
	\pnum
	\effects
	Restores the observable state of \tcode{*this} from the most recent entry on the internal stack of saved states and removes that entry from the stack.
	
	\pnum
	\throws
	\tcode{std::system_error} with an error category of \tcode{io2d_error_category} and an error condition of \tcode{io2d_error::invalid_restore} if there are no entries on the stack of saved states when this function is called.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_brush}}
\indexlibrary{\idxcode{reset_brush}!\idxcode{surface}}
\begin{itemdecl}
void reset_brush() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets a default \tcode{pattern} object.
	\enternote
	The default \tcode{pattern} object is always an opaque black solid color 
	pattern, equivalent to the pattern created by 
	\tcode{solid_color_pattern_factory(rgba_color::black).get_pattern()}. It is 
	not required to be the same object throughout the lifetime of the program.
	\exitnote
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a default \tcode{pattern} object.
\end{itemdescr}

\begin{itemdecl}
void brush(const std::experimental::io2d::brush& source);
void brush(const std::experimental::io2d::brush& source,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Unsets the current \tcode{pattern} object and sets \tcode{source} as the current \tcode{pattern} object.
	
	\pnum
	\postconditions
	\tcode{get_pattern()} returns a \tcode{pattern} object with the same observable state as \tcode{source} object.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
void antialias(std::experimental::io2d::antialias a) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current \tcode{antialias} state to \tcode{a}.
	
	\pnum
	\postconditions
	\tcode{get_antialias()} returns the value of \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_dashes}}
\indexlibrary{\idxcode{reset_dashes}!\idxcode{surface}}
\begin{itemdecl}
void reset_dashes() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to be a solid line.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{std::make_tuplestd::<vector<double>, double>(\{ \}, 0.0)}. \tcode{get_dashes_count()} will return \tcode{0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(const std::experimental::io2d::dashes& d);
void dashes(const std::experimental::io2d::dashes& d, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current dash pattern to the value of \tcode{d}.
	
	\pnum
	\postconditions
	\tcode{get_dashes()} will return the equivalent of \tcode{d}. \tcode{get_dashes_count()} will return the value of \tcode{static_cast<int>(std::get<0>(d).size())}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
void fill_rule(std::experimental::io2d::fill_rule fr) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current fill rule to the value of \tcode{fr}.
	
	\pnum
	\postconditions
	\tcode{get_fill_rule()} will return the value of \tcode{fr}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
void line_cap(std::experimental::io2d::line_cap lc) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line cap to the value of \tcode{lc}.
		
	\pnum
	\postconditions
	\tcode{get_line_cap()} will return the value of \tcode{lc}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
void line_join(std::experimental::io2d::line_join lj) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line join to the value of \tcode{lj}.
	
	\pnum
	\postconditions
	\tcode{get_line_join()} will return the value of \tcode{lj}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{set_line_width}}
\indexlibrary{\idxcode{set_line_width}!\idxcode{surface}}
\begin{itemdecl}
void line_width(double width) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current line width to \tcode{std::max(width, 0.0)}.
	
	\pnum
	\postconditions
	\tcode{get_line_width()} will return \tcode{std::max(width, 0.0)}.
	
	\pnum
	\remarks
	Line width is in pre-transformation units and is used with the \tcode{surface::stroke} functions. It postulates a round brush with a diameter of the current line width. The shape and size of the stroke when rendered depends on other state data. See \tcode{surface::stroke}\ref{\iotwod.surface::stroke} for more information.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
void miter_limit(double limit) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current miter limit to the value of \tcode{std::max(limit, 1.0)}. This limit only applies when the current line join is set to \tcode{line_join::miter_or_bevel}.
	
	\pnum
	\postconditions
	\tcode{get_miter_limit} will return \tcode{std::max(limit, 1.0)}.
	
	\pnum
	\remarks
	The miter limit works as follow. The length of the miter is divided by the width of the line. If the resulting value is greater than \tcode{limit}, the line join will be beveled, otherwise it will be mitered.
	\enternote
	When the join angle is less than 0.0005 radians, it is 
	\impldef{\tcode{surface}!\tcode{set_miter_limit}} whether a mitered join or 
	a beveled joins will be produced. Specifically, when the join angle is less 
	than 0.0005 radians, implementations may switch to beveled rendering 
	instead of mitered rendering at an \impdef angle value, provided that the 
	value is less than 0.0005 radians and that all joins with angles below the 
	\impdef angle value are rendered as beveled.
	\exitnote
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
void compositing_operator(std::experimental::io2d::compositing_operator co)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current compositing operator to the value of \tcode{co}.
	
	\pnum
	\postconditions
	\tcode{get_compositing_operator} will return the value of \tcode{co}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip}}
\indexlibrary{\idxcode{clip}!\idxcode{surface}}
\begin{itemdecl}
void clip(const std::experimental::io2d::path& p);
void clip(const std::experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Sets the current clip area to be the intersection of the current clip area and the current path where the current path's area is determined in the same way as if the current path were filled according to the current fill rule.
	
	\pnum
	\realnotes
	The clip area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_immediate}}
\indexlibrary{\idxcode{clip_immediate}!\idxcode{surface}}
\begin{itemdecl}
void clip_immediate();
void clip_immediate(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{reset_path}}
\indexlibrary{\idxcode{reset_path}!\idxcode{surface}}
\begin{itemdecl}
void reset_path() noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to be an empty path.
	
	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\begin{itemdecl}
void path(const std::experimental::io2d::path& p);
void path(const std::experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	Set's the current \tcode{path} to \tcode{p}.
	
	\pnum
	\remarks
	Processing the path data so that it is properly transformed can be done at the time it is first set as a path on a \tcode{surface} object or any time before that. The untransformed \tcode{vector<path_data>} must be retained to ensure that a path can be properly recreated at any time. The steps for converting an untransformed \tcode{vector<path_data>} to transformed path data are found at .
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.render] {\tcode{surface} render modifiers}

\rSec2 [\iotwod.surface::stroke] {\tcode{surface::stroke}}

\indexlibrary{\idxcode{surface}!\idxcode{stroke}}%
\indexlibrary{\idxcode{stroke}!\idxcode{surface}}%
\begin{itemdecl}
void stroke();
void stroke(const surface& s);
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\effects
	...
	
	\pnum
	\postconditions
	...
	
	\pnum
	\complexity
	...
	
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.transform] {\tcode{surface} transformation modifiers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.font] {\tcode{surface} font modifiers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.state] {\tcode{surface} state observers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.render] {\tcode{surface} render observers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.transform] {\tcode{surface} transformation observers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.observers.font] {\tcode{surface} font observers}

%\rSec2 [\iotwod.::] {\tcode{::}}
%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\indexlibrary{\idxcode{}!\idxcode{}}%
%\begin{itemdecl}
%\end{itemdecl}
%\begin{itemdescr}
%	\pnum
%	\effects
%	
%	\pnum
%	\postconditions
%	
%	\pnum
%	\complexity
%\end{itemdescr}

\rSec1 [\iotwod.surface.nonmembers] {\tcode{surface} non-member functions}

\rSec2 [\iotwod.surface.make_surface] {\tcode{make_surface}}

\indexlibrary{\idxcode{make_surface}}%
\begin{itemdecl}
surface make_surface(@\impdef@) @\impdef@;
\end{itemdecl}
\begin{itemdescr}
	\pnum
	\returns
	A \tcode{surface} object. The default initial state of the returned \tcode{surface} object is listed in Table~\ref{tab:\iotwod.surface.make_surface.definitstate}.
	\enternote
	Implementations may return a \tcode{surface} object with a different initial state. See the Remarks section below.
	\exitnote
	
\begin{libreqtab2}
 {\tcode{make_surface} Default Initial State Values}
 {tab:\iotwod.surface.make_surface.definitstate}
 \\ \topline
 \lhdr{Observer}
 & \rhdr{Return Value}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Observer}
 & \rhdr{Return Value}
 \\ \capsep
 \endhead
 \tcode{a}
 & \tcode{b}
 \\
\end{libreqtab2}

	\pnum
	\remarks
	The name, return type, and default initial values for the observable states of the returned \tcode{surface} object are the only semantic elements specified for \tcode{make_surface}. The default initial values for the observable state of the returned \tcode{surface} object are given in Table~\ref{tab:\iotwod.surface.make_surface.definitstate}. Implementations are free to provide different initial values provided that the differences are documented. 
\end{itemdescr}
