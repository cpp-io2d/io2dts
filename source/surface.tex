%!TEX root = io2d.tex
\rSec0 [surface] {Class \tcode{surface}}

\pnum
A \term{rendering and composing operation} is an operation that is either a single-phase operation consisting of a composing operation or a multi-phase operation consisting of a rendering operation followed by a composing operation.

\rSec1 [surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class surface {
  public:
    // \ref{surface.cons}, constructors, assignment operators, destructors:
    surface() = delete;
    surface(const surface&) = delete;
    surface& operator=(const surface&) = delete;
    surface(surface&& other) noexcept;
    surface& operator=(surface&& other) noexcept;
    virtual ~surface();

    // \ref{surface.modifiers.state}, state modifiers:
    virtual void finish() noexcept;
    void flush();
    void flush(error_code& ec) noexcept;
    shared_ptr<experimental::io2d::device> device();
    shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void map(const function<void(mapped_surface&)>& action);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const function<void(mapped_surface&)>& action,
      const rectangle& extents);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      const rectangle& extents, error_code& ec);
    virtual void save();
    virtual void save(error_code& ec) noexcept;
    virtual void restore();
    virtual void restore(error_code& ec) noexcept;
    void brush(experimental::nullopt_t) noexcept;
    void brush(const experimental::io2d::brush& source);
    void brush(const experimental::io2d::brush& source, error_code& ec)
      noexcept;
    void antialias(experimental::io2d::antialias a) noexcept;
    void dashes(experimental::nullopt_t) noexcept;
    void dashes(const experimental::io2d::dashes& d);
    void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
    void fill_rule(experimental::io2d::fill_rule fr) noexcept;
    void line_cap(experimental::io2d::line_cap lc) noexcept;
    void line_join(experimental::io2d::line_join lj) noexcept;
    void line_width(double width) noexcept;
    void miter_limit(double limit) noexcept;
    void compositing_operator(experimental::io2d::compositing_operator co)
      noexcept;
    void clip(const experimental::io2d::path& p);
    void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
    void clip_immediate();
    void clip_immediate(error_code& ec) noexcept;
    void path(experimental::nullopt_t) noexcept;
    void path(const experimental::io2d::path& p);
    void path(const experimental::io2d::path& p, error_code& ec) noexcept;

    // \ref{surface.modifiers.immediatepath}, immediate path modifiers:
    experimental::io2d::path_factory& immediate() noexcept;

    // \ref{surface.modifiers.render}, render modifiers:
    void fill();
    void fill(error_code& ec) noexcept;
    void fill(const rgba_color& c);
    void fill(const rgba_color& c, error_code& ec) noexcept;
    void fill(const experimental::io2d::brush& b);
    void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void fill(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void fill(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void fill(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void fill_immediate();
    void fill_immediate(error_code& ec) noexcept;
    void fill_immediate(const rgba_color& c);
    void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
    void fill_immediate(const experimental::io2d::brush& b);
    void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void fill_immediate(const surface& s, const vector_2d& o = vector_2d{ }, 
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void fill_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void fill_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint();
    void paint(error_code& ec) noexcept;
    void paint(const rgba_color& c);
    void paint(const rgba_color& c, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b);
    void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void paint(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void paint(double alpha);
    void paint(double alpha, error_code& ec) noexcept;
    void paint(const rgba_color& c, double alpha);
    void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b, double alpha);
    void paint(const experimental::io2d::brush& b, double alpha,
      error_code& ec) noexcept;
    void paint(const surface& s, double alpha,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, double alpha, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void paint(const surface& s, double alpha, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void paint(const surface& s, double alpha, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void stroke();
    void stroke(error_code& ec) noexcept;
    void stroke(const rgba_color& c);
    void stroke(const rgba_color& c, error_code& ec) noexcept;
    void stroke(const experimental::io2d::brush& b);
    void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void stroke(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke(const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void stroke(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void stroke_immediate();
    void stroke_immediate(error_code& ec) noexcept;
    void stroke_immediate(const rgba_color& c);
    void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
    void stroke_immediate(const experimental::io2d::brush& b);
    void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void stroke_immediate(const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void stroke_immediate(const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void stroke_immediate(const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.maskrender}, mask render modifiers:
    void mask(const experimental::io2d::brush& mb);
    void mask(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask(const experimental::io2d::brush& mb, const rgba_color& c);
    void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
      error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none, 
      filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms);
    void mask(const surface& ms, error_code& ec) noexcept;
    void mask(const surface& ms, const rgba_color& c);
    void mask(const surface& ms, const rgba_color& c, error_code& ec) noexcept;
    void mask(const surface& ms, const experimental::io2d::brush& b);
    void mask(const surface& ms, const experimental::io2d::brush& b, 
      error_code& ec) noexcept;
    void mask(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const surface& s, const matrix_2d& m,
      error_code& ec, extend e = extend::none, filter f = filter::good)
      noexcept;
    void mask(const surface& ms, const vector_2d& mo);
    void mask(const surface& ms, const vector_2d& mo, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c);
    void mask(const surface& ms, const vector_2d& mo, const rgba_color& c,
      error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask(const surface& ms, const vector_2d& mo, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb);
    void mask_immediate(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c);
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
      const matrix_2d& m, extend e = extend::none, filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms);
    void mask_immediate(const surface& ms, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const rgba_color& c);
    void mask_immediate(const surface& ms, const rgba_color& c, error_code& ec) 
      noexcept;
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const experimental::io2d::brush& b,
      error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const surface& s,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s, error_code& ec,
      const vector_2d& o = vector_2d{ }, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const surface& s, const matrix_2d& m,
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const surface& s,
      const matrix_2d& m, error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo);
    void mask_immediate(const surface& ms, const vector_2d& mo, error_code& ec)
      noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    void mask_immediate(const surface& ms, const vector_2d& mo,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.textrender}, text render modifiers:
    vector_2d render_text(const string& utf8, const vector_2d& pos);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c, error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
      extend e = extend::none, filter f = filter::good) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, extend e = extend::none,
      filter f = filter::good);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m, error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.transform}, transformation modifiers:
    void matrix(const matrix_2d& matrix);
    void matrix(const matrix_2d& matrix, error_code& ec) noexcept;
    
    // \ref{surface.modifiers.font}, font modifiers:
    void font_face(const string& typeface, font_slant sl, font_weight w);
    void font_face(const string& typeface, font_slant sl, font_weight w,
      error_code& ec) noexcept;
    void font_face(const experimental::io2d::font_face& f);
    void font_face(const experimental::io2d::font_face& f, error_code& ec)
      noexcept;
    void font_size(double s) noexcept;
    void font_matrix(const matrix_2d& m);
    void font_matrix(const matrix_2d& m, error_code& ec) noexcept;
    void font_options(const font_options& fo) noexcept;
    
    // \ref{surface.observers.state}, state observers:
    bool is_finished() const noexcept;
    experimental::io2d::content content() const noexcept;
    experimental::io2d::brush brush() const noexcept;
    experimental::io2d::antialias antialias() const noexcept;
    experimental::io2d::dashes dashes() const;
    experimental::io2d::dashes dashes(error_code& ec) const noexcept;
    experimental::io2d::fill_rule fill_rule() const noexcept;
    experimental::io2d::line_cap line_cap() const noexcept;
    experimental::io2d::line_join line_join() const noexcept;
    double line_width() const noexcept;
    double miter_limit() const noexcept;
    experimental::io2d::compositing_operator compositing_operator() const
      noexcept;
    rectangle clip_extents() const noexcept;
    bool in_clip(const vector_2d& pt) const noexcept;
    vector<rectangle> clip_rectangles() const;
    vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
    
    // \ref{surface.observers.render}, render observers:
    rectangle fill_extents() const noexcept;
    rectangle fill_extents_immediate() const;
    rectangle fill_extents_immediate(error_code& ec) const noexcept;
    bool in_fill(const vector_2d& pt) const noexcept;
    bool in_fill_immediate(const vector_2d& pt) const;
    bool in_fill_immediate(const vector_2d& pt, error_code& ec) const noexcept;
    rectangle stroke_extents() const noexcept;
    rectangle stroke_extents_immediate() const;
    rectangle stroke_extents_immediate(error_code& ec) const noexcept;
    bool in_stroke(const vector_2d& pt) const noexcept;
    bool in_stroke_immediate(const vector_2d& pt) const;
    bool in_stroke_immediate(const vector_2d& pt, error_code& ec) const 
      noexcept;
    experimental::io2d::font_extents font_extents() const noexcept;
    experimental::io2d::text_extents text_extents(const string& utf8) const;
    experimental::io2d::text_extents text_extents(const string& utf8,
      error_code& ec) const noexcept;
    
    // \ref{surface.observers.transform}, transformation observers:
    matrix_2d matrix() const noexcept;
    vector_2d user_to_surface(const vector_2d& pt) const noexcept;
    vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
    vector_2d surface_to_user(const vector_2d& pt) const noexcept;
    vector_2d surface_to_user_distance(const vector_2d& dpt) const noexcept;
    
    // \ref{surface.observers.font}, font observers:
    matrix_2d font_matrix() const noexcept;
    experimental::io2d::font_options font_options() const noexcept;
    experimental::io2d::font_face font_face() const;
    experimental::io2d::font_face font_face(error_code& ec) const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}
The \tcode{surface} class provides an interface for managing a graphics
data graphics resource and its observable state data
(\ref{surface.state}).

\pnum
A \tcode{surface} object is a move-only object.

\pnum
The \tcode{surface} class provides two ways to modify its graphics resource:
\begin{itemize}
\item Rendering and composing operations.
\item Mapping.
\end{itemize}

\pnum
\enternote
While a \tcode{surface} object manages a graphics data graphics resource, the \tcode{surface} class does not provide well-defined semantics for the graphics resource. The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable.
\exitnote

\pnum
Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics data graphics resource or inherit well-defined semantics for the graphics data graphics resource from a base class.

\pnum
\enterexample
The \tcode{image_surface} class and the \tcode{display_surface} class each specify that they manage a raster graphics data graphics resource and that the members they inherit from the \tcode{surface} class shall use that raster graphics data graphics resource as their graphics data graphics resource. Since, unlike graphics data, raster graphics data provides well-defined semantics, these classes meet the requirements for being directly instantiable.
\exitexample

\pnum
The definitions of the rendering and composing operations in \ref{surface.rendering} shall only be applicable when the graphics data graphics resource on which the \tcode{surface} members operate is a raster graphics data graphics resource. In all other cases, any attempt to invoke the rendering and composing operations shall result in undefined behavior.

\rSec1 [surface.state] {\tcode{surface} state}

\pnum
Table~\ref{tab:surface.state.listing} specifies the name, type, function, and default value for each item of a surface's observable state.

\rSec2 [surface.state.default] {\tcode{surface} state default values}

\begin{libreqtab4b}
	{Surface observable state}
	{tab:surface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	\term{Current Brush} &
	\tcode{brush} &
	This is the brush that shall be available for use when performing rendering and composing operations &
	\tcode{brush\{ \{ rgba_color::black() \} \}} \\ \rowsep

	\term{General Antialiasing} &
	\tcode{antialias} &
	This is the type of antialiasing that should be used when performing non-text rendering operations &
	\tcode{antialias::default_antialias}\\ \rowsep
	
	\term{Dash Pattern} &
	\tcode{dashes} &
	This specifies the pattern that shall be used when performing stroke rendering operations &
	\tcode{dashes\{ vector<double>(), 0.0 \}} \\ \rowsep
	
	\term{Fill Rule} &
	\tcode{fill_rule} &
	This controls which areas of paths shall be eligible to be filled when performing fill rendering operations &
	\tcode{fill_rule::winding} \\ \rowsep
	
	\term{Line Cap} &
	\tcode{line_cap} &
	This specifies how the end of a path segment that is not joined to another path segment shall be rendered when performing stroke rendering operations &
	\tcode{line_cap::butt} \\ \rowsep
	
	\term{Line Join} &
	\tcode{line_join} &
	This specifies how the join point of two path segments that are joined to each other shall be rendered when performing stroke rendering operations &
	\tcode{line_join::miter} \\ \rowsep
	
	\term{Line Width} &
	\tcode{double} &
	This is the width, in surface coordinate space units, that shall be used to determine the rendered width of path segments when performing a stroke rendering operation &
	\tcode{2.0} \\ \rowsep
	
	\term{Miter Limit} &
	\tcode{double} &
	This is the value that shall be used to calculate whether a line join shall be mitered or beveled when the value of Line Join is \tcode{line_join::miter}. &
	\tcode{10.0} \\ \rowsep
	
	\term{Composition Operator} &
	\tcode{compositing_operator} &
	This specifies the composition algorithm that shall be used when performing rendering operations &
	\tcode{compositing_operator::over} \\ \rowsep
	
	\term{Clip Area} &
	\unspec (see \ref{surface.state.default}, below) &
	The areas of the surface which shall be the only areas in which composing operations may have any effect &
	An area which contains the entire area of the surface \\ \rowsep
	
	\term{Current Path} &
	\tcode{path} &
	This is the \tcode{path} object that shall be used when performing non-immediate rendering operations &
	\tcode{path\{ path_factory\{ \} \}} \\ \rowsep
	
	\term{Immediate Path} &
	\tcode{path_factory} &
	This is the \tcode{path_factory} object that shall be used when performing immediate rendering operations &
	\tcode{path_factory\{ \}} \\ \rowsep
	
	\term{Transformation Matrix} &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from an object's local coordinate space to the surface's coordinate space when performing rendering operations &
	\tcode{matrix_2d::init_identity\{ \}} \\ \rowsep
	
	\term{Font Face} &
	\tcode{font_face} &
	This is the font that shall be used when performing text rendering operations &
	\tcode{\impldef{\tcode{surface}!Font Face}} \\ \rowsep
	
	\term{Font Matrix} &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform coordinates from a font's local coordinate space to the surface's coordinate space when performing text rendering operations &
	\tcode{matrix_2d::init_scale\{ \{ 10.0, 10.0 \} \}} \\ \rowsep
	
	\term{Font Options} &
	\tcode{font_options} &
	This is the \tcode{font_options} object that shall be used to determine certain aspects of how a font should be rendered when performing text rendering operations &
	\tcode{font_option\{ antialias::default_antialias, subpixel_order::default_subpixel_order \}} \\ \rowsep
	
\end{libreqtab4b}

\pnum
\enternote
The Clip Area may be modified by intersecting the current Clip Area with the areas of a \tcode{path} object that would be filled according to the current Fill Rule. The resulting Clip Area will only contain areas that were already in the Clip Area and does not need to be a valid \tcode{path} object since the Clip Area is only guaranteed to be observable by the effects it has on composing operations. For this reason, the Clip Area's type is unspecified. The Clip Area may also be modified by resetting it to its default value, which is the only way of enlarging the current Clip Area.
\exitnote

\rSec2 [surface.state.save] {\tcode{surface} saved state}

\pnum
A surface object provides an interface to save its current state and subsequently restore it.

\pnum
Save and restore operations are performed using \tcode{surface::save} and \tcode{surface::restore}, respectively.

\pnum
Save and restore operations may be nested.

\pnum
Each call to \tcode{surface::restore} restores a surface object's state to its values at the time of the most recent call to \tcode{surface::save}.

\pnum
The following list denotes each item of observable state that shall be saved by \tcode{surface::save} and restored by \tcode{surface::restore}, using the state item names listed in Table~\ref{tab:surface.state.listing}:

\begin{itemize}
	\item Current Brush
	\item General Antialiasing
	\item Dash Pattern
	\item Fill Rule
	\item Line Cap
	\item Line Join
	\item Line Width
	\item Miter Limit
	\item Compositing Operator
	\item Tolerance
	\item Clip Area
	\item Current Path
	\item Immediate Path
	\item Transformation Matrix
	\item Font Face
	\item Font Matrix
	\item Font Options
\end{itemize}

\rSec1 [surface.rendering] {\tcode{surface} rendering and composing operations}

\pnum
The \tcode{surface} class provides five fundamental rendering and composing operations:
\begin{libreqtab2}
 {\tcode{surface} rendering and composing operations}
 {tab:surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{surface::paint}
 \\
 Filling
 & \tcode{surface::fill}, \tcode{surface::fill_immediate}
 \\
 Stroking
 & \tcode{surface::stroke}, \tcode{surface::stroke_immediate}
 \\
 Masking
 & \tcode{surface::mask}, \tcode{surface::mask_immediate}
 \\
 Typesetting
 & \tcode{surface::draw_text}
 \\
\end{libreqtab2}

\pnum
The filling, stroking, and masking operations each provide two functions, not including overloads, for invoking their functionality.

\pnum
Certain rendering and composing operations require a \term{source path}, which is a path geometry graphics resource.

\pnum
The rendering and composing operations invoked by the \tcode{surface::fill}, \tcode{surface::stroke}, and \tcode{surface::mask} functions shall use the \tcode{surface} object's Current Path as their source path.

\pnum
The rendering and composing operations invoked by the \tcode{surface::fill_immediate}, \tcode{surface::stroke_immediate}, and \tcode{surface::mask_immediate} functions shall use as their source path a path geometry graphics resource formed in the manner specified by \ref{pathgeometries.processing} from the (\textit{const} reference to) \tcode{vector<path_data_item>} returned by calling the \tcode{path_factory::data_ref} member function on the surface's Immediate Path.

\pnum
Provided that none of the function calls results in an error, given a \tcode{surface} object \tcode{s}, there shall be no observable difference in the results of:
\begin{itemize}
	\item calling \tcode{surface::fill_immediate} on \tcode{s} versus calling \tcode{surface::fill} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	
	\item calling \tcode{surface::stroke_immediate} on \tcode{s} versus calling \tcode{surface::stroke} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	
	\item calling \tcode{surface::mask_immediate} on \tcode{s} versus calling \tcode{surface::mask} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function.
\end{itemize}

\pnum
The painting operation is a single-part operation consisting of a composing operation. Each of the other operations is a multi-part operation consisting of a rendering operation followed by a composing operation.

\pnum
The surface's Clip Area shall always apply to all composing operations. This is true even if no mention is made of the Clip Area in the description of a composing operation or if the description of a composing operation uses phraseology that could otherwise be read as being unconstrained.
\enternote
Because of this, mention of the applicability of the Clip Area will be omitted in the descriptions of the composing operation portions of the rendering and composing operations that follow.
\exitnote

\pnum
Each of the five fundamental rendering and composing operations has its own set of minimum arguments.
\begin{enumerate}
	\item The painting operation has no minimum arguments.
	\item The filling operation has no minimum arguments.
	\item The stroking operation has no minimum arguments.
	\item The masking operation has one minimum argument: an object, used as the mask (see \ref{surface.masking}), that is of type \tcode{brush} or type \tcode{surface}.
	\item The typesetting operation has two minimum arguments: an object, used as the text that is rendered and composed to the surface (see \ref{surface.typesetting}), that is of type \tcode{string}; and, an object, used to specify the coordinates at which the origin of the first character of the text is positioned (see \ref{surface.typesetting}), of type \tcode{vector_2d}.
\end{enumerate}

\pnum
If a reference to an \tcode{error_code} object (see \ref{\iotwod.err.report}) is passed to a rendering and composing operation, it shall be considered part of the set of minimum arguments for that operation.

\pnum
For the masking operation, where a \tcode{surface} object is used as the mask argument, it may be immediately followed by an argument of type \tcode{vector_2d} which shall be used as the mask surface origin (see \ref{surface.masking}). If a mask surface origin argument is passed to the masking operation, it shall be considered part of the set of minimum arguments for that operation.

\pnum
A \term{source brush} is composed of a pixmap, an \tcode{extend} value, a \tcode{filter} value, and a \tcode{matrix_2d} object.

\pnum
\enternote
A \tcode{brush} object provides all of the components of a source brush. As such, \tcode{brush} objects will commonly be used as source brushes.
\exitnote

\pnum
The rendering and composing operations shall be provided with a source brush each time they are invoked.

\pnum
A source brush may be provided by a \tcode{brush} object or by an identified set of arguments which, together, provide all of the components of a source brush.

\pnum
When a rendering and composing operation is invoked with only those arguments that are part of its set of minimum arguments, the surface's Current Brush shall be the source brush.

\pnum
When a rendering and composing operation is invoked with \term{extra arguments}, which are additional arguments beyond those that are part of its set of minimum arguments, the source brush shall be as follows, with any errors reported as specified in Error reporting (\ref{\iotwod.err.report}):
\begin{itemize}
	\item Where there is one extra argument and it is a \tcode{brush} object, the source brush shall be that \tcode{brush} object.
	\item Where there is one extra argument and it is an \tcode{rgba_color} object, the source brush shall be the same as if it were a \tcode{brush} object constructed from a \tcode{solid_color_brush_factory} constructed from the extra argument.
	\item Where there is more than one extra argument, including default arguments, and the first extra argument is a \tcode{surface} object, the source brush shall be the same as if it were a \tcode{brush} object \tcode{b} constructed from a \tcode{surface_brush_factory} constructed from the \tcode{surface} object extra argument with the following adjustments:
	\begin{enumerate}
		\item The \tcode{surface} object extra argument should be used directly; no copy of it should be made. This differs from the \tcode{surface_brush_factory} class, which requires that a copy be made and that only the copy be used.
		\item The source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::extend} was called on \tcode{b} with the \tcode{extend} object extra argument passed to \tcode{brush::extend} as an argument.
		\item The source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::filter} was called on \tcode{b} with the \tcode{filter} object extra argument passed to \tcode{brush::filter} as an argument.
		\item If there is an extra argument of type \tcode{vector_2d}, the source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::matrix} was called on \tcode{b} with the result of passing the \tcode{vector_2d} object extra argument to \tcode{matrix_2d::init_translate} passed to \tcode{brush::matrix} as an argument.
		\item If there is an extra argument of type \tcode{matrix_2d}, the source brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::matrix} was called on \tcode{b} with the \tcode{matrix} object extra argument passed to \tcode{brush::matrix} as an argument.
	\end{enumerate}
\end{itemize}

\pnum
\enternote
The rendering and composing operations each have the same combinations of extra arguments, all of which are covered by the above requirements that determine the source brush when extra arguments are present.
\exitnote

\pnum
When a rendering and composing operation needs to obtain a value for a pixel from its source brush, it shall do so as specified in \ref{surface.sampling}. %% If the source brush is an object of type \tcode{brush}, and invoking \tcode{brush::type} on it returns \tcode{brush_type::linear} or \tcode{brush_type::radial}, \ref{gradients.sampling} shall also apply.

\pnum
A \tcode{surface} object shall not be used as a mask or as a source brush for any rendering and composing operations invoked on that \tcode{surface} object. No diagnostic is required.
\enternote
When a \tcode{brush} object \tcode{b} is created from a \tcode{surface} object \tcode{s} using the \tcode{surface_brush_factory} class, \tcode{b} may be used as a mask or as a source brush for rendering and composing operations invoked on \tcode{s} because the \tcode{surface_brush_factory} class creates a copy of \tcode{s} (see \ref{surfacebrushfact}), thereby avoiding the aliasing problems and race conditions that this requirement exists to block.
\exitnote

\rSec1 [surface.sampling] {Sampling from a source brush}

\pnum
This section is forthcoming in a future revision.

%%\pnum
%%\enternote
%%A pixmap can be thought of ***FIXME*** Is it really a discrete signal? What does it mean to sample from a texture? Should there even be a note here or should I just explain the process along the lines of how path processing is explained?
%%\exitnote
%%
%\pnum
%When performing a composing operation, the source pixels for the composition algorithm shall be sampled from the source brush and the destination pixels shall be sampled from the \tcode{surface} object. The \tcode{surface} object shall be modified in the manner specified by the composition algorithm.
%
%\pnum
%The source brush and the \tcode{surface} object may have different visual data formats. 
%
%\pnum
%When performing a composing operation, the coordinate space of a \tcode{surface} object and the coordinate space of a source brush's pixmap shall be the same, subject to the following rules:
%\begin{itemize}
%	\item When sampling from a source brush, each point shall be transformed by calling \tcode{matrix_2d::transform_point} on the source brush's \tcode{matrix_2d} object and using the return value as the point which shall be sampled.
%	\item When sampling from the \tcode{surface} object, each point shall be transformed by calling \tcode{matrix_2d::transform_point} on the \tcode{matrix_2d} object returned by calling \tcode{surface::matrix()} on the \tcode{surface} object and using the return value as the point which shall be sampled.
%\end{itemize}
%
%\pnum
%\enternote
%Each source brush and surface has its own local coordinate space.
%
%\pnum
%Its \tcode{matrix_2d} object, identified in the list above, maps the default coordinate space to its local coordinate space.
%
%\pnum
%When its \tcode{matrix_2d} object is the identity matrix, the local coordinate space is the same as the default coordinate space.
%\exitnote
%
%\pnum
%This section is forthcoming in a future revision.
%
%\pnum
%In general, the effects of the \tcode{extend} value on a \tcode{brush} object are documented in \ref{extend}.
%***FIXME***
%
%\pnum
%For every raster graphics data graphics resource that may be used as a source brush or a mask it shall be possible to provide an input value in the form of a point and receive an output value in the form of a pixel. ***FIXME*** Need to deal with formats - are they an input or is the returned pixel always in the RGBA color space with the conversion to the required format happening as a subsequent step? Also, something needs to be done to ensure that the output is the same value both for every call with the same input and state and for all implementations - a graphics data graphics resource currently has no coordinate system which makes that problematic or even impossible. together with its graphics state data, if any,
%
%\pnum
%
%\pnum
%The initial \tcode{extend} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.
%
%%\pnum
%%If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::mesh}, the \tcode{brush}'s \tcode{extend} value is ignored and all operations proceed as if the \tcode{extend} value is \tcode{extend::none}.
%%
\rSec1 [brush.filter] {Effects of its \tcode{filter} value of a \tcode{brush} object}

\pnum
The effects of the \tcode{filter} value on a \tcode{brush} object are documented in \ref{filter}.

\pnum
The initial \tcode{filter} value of a \tcode{brush} object depends on the brush factory used to create it and is documented in the \tcode{brush} constructors for each type of brush factory.

\rSec1 [brush.matrix] {Effects of its \tcode{matrix_2d} value on a \tcode{brush} object}

\pnum
The initial \tcode{matrix_2d} value of a \tcode{brush} object is \tcode{matrix_2d::init_identity()}.

\pnum
If the \tcode{brush}'s \tcode{brush_type} is \tcode{brush_type::solid_color}, the brush is treated as if its data area is an infinite plane. As such\ the \tcode{brush}'s \tcode{extend}, \tcode{filter}, and \tcode{matrix_2d} values do not matter. Regardless of the coordinate from which data from the \tcode{brush} is requested, the \tcode{brush} will always return the color which the \tcode{solid_color_brush_factory} that was used to create it had at the time the \tcode{brush} was created.

\pnum
All brushes except \tcode{brush_type::solid_color} brushes are sensitive to coordinates and as such will need to have an appropriate \tcode{matrix_2d} value to achieve the desired outcome.

\pnum
\enternote
Sometimes the initial \tcode{matrix_2d} value will be the appropriate value. As such there is no requirement to set a \tcode{matrix_2d} value unless you need something other than the initial value.
\exitnote

\pnum
When it is necessary for the implementation to retrieve data from a \tcode{brush} object to calculate the resulting color value of a coordinate on a \tcode{surface}, the coordinate is first transformed using the \tcode{brush} object's \tcode{matrix_2d}.

\pnum
A \tcode{brush} object's \tcode{matrix_2d} value transforms a coordinate from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space.

\pnum
\enterexample
Take a \tcode{brush b} which has a \tcode{matrix_2d} value of \tcode{matrix_2d::init_scale(\{ 2.0, 0.25 \})}.

\pnum
If a request for data from \tcode{b} at the point \tcode{vector_2d(30.0, 18.0)} is made, by operation of \tcode{b}'s \tcode{matrix_2d}, the actual data that will be retrieved is the data at \tcode{vector_2d(60.0, 4.5)} (after application of \tcode{b}'s \tcode{extend} value as described above).

\pnum
Notice that although the \xaxis scale is set to \tcode{2.0} and the \yaxis scale is set to \tcode{0.25}, the actual effect is the same as if the \tcode{b}'s data itself had been scaled to the inverse of those values. This is because the transformation goes from the \tcode{surface}'s coordinate space to the \tcode{brush}'s coordinate space rather than from the \tcode{brush}'s coordinate space to the \tcode{surface}'s coordinate space.
\exitexample

\pnum
\enternote
For the same reason as explained in the example above, if you wish to translate the origin point of a \tcode{brush} to the point \tcode{vector_2d p} of a \tcode{surface}, you would do so by setting \tcode{matrix_2d::init_translate(-p)} as the brush's \tcode{matrix_2d} value.
\exitnote

\rSec2 [surface.painting] {\tcode{surface} painting}

\pnum
When a Painting operation is initiated on a surface, the implementation shall compose the source brush with the \underlyingsurface in the manner specified by the surface's current Composition Operator and modify the \underlyingsurface to reflect the results of that operation.

\pnum
No part of the \underlyingsurface that is outside of the Clip Area shall be modified.

\rSec2 [surface.filling] {\tcode{surface} filling}

\pnum
This section is forthcoming in a future revision.

%\pnum
%When a filling operation is initiated on a surface, the implementation shall produce results as if the following steps were performed:
%\begin{itemize}
%	\item The surface's ***FIXME***
%\end{itemize}

\rSec2 [surface.stroking] {\tcode{surface} stroking}

\pnum
When a Stroking operation is initiated on a surface, the implementation shall carry out the Stroking operation for each path geometry in the source path.

\pnum
After all path geometries have been rendered but before the rendered result is composed to the \underlyingsurface, the rendered result shall be transformed by the Transformation Matrix.
\enterexample
If an open path geometry consisting solely of a vertical line from \tcode{vector_2d(20.0, 20.0)} to \tcode{vector_2d(20.0, 60.0)} is to be composed to the \underlyingsurface, the Line Cap is \tcode{line_cap::butt}, the Line Width is \tcode{12.0}, and the Transformation Matrix is \tcode{matrix_2d::init_scale(0.5, 1.0)}, then the line will end up being composed within the area \tcode{rectangle( \{ 7.0, 20.0 \}, \{ 13.0, 60.0 \} )} on the \underlyingsurface. The Transformation Matrix causes the center of the \xaxis of the line to move from \tcode{20.0} to \tcode{10.0} and then causes the horizontal width of the line to be reduced from \tcode{12.0} to \tcode{6.0}.
\exitexample

\pnum
The following rules shall apply when a Stroking operation is carried out on a path geometry:
\begin{enumerate}
\item No part of the \underlyingsurface that is outside of the Clip Area shall be modified.

\item If the path geometry only contains a degenerate path segment, then if the Line Cap value is either \tcode{line_cap::round} or \tcode{line_cap::square}, the line caps shall be rendered, resulting in a circle or a square, respectively. The remaining rules shall not apply.

\item If the path geometry is a closed path geometry, then the point where the end point of its final path segment meets the start point of the initial path segment shall be rendered as specified by the Line Join value; otherwise the start point of the initial path segment and end point of the final path segment shall each by rendered as specified by the Line Cap value. The remaining meetings between successive end points and start points shall be rendered as specified by the Line Join value.

\item If the Dash Pattern has its default value or if its \tcode{vector<double>} member is empty, the path segments shall be rendered as a continuous path.

\item If the Dash Pattern's \tcode{vector<double>} member contains only one value, that value shall be used to define a repeating pattern in which the path is shown then hidden. The ends of each shown portion of the path shall be rendered as specified by the Line Cap value.

\item If the Dash Pattern's \tcode{vector<double>} member contains two or more values, the values shall be used to define a pattern in which the path is alternatively shown then hidden for the length specified by the value. The ends of each shown portion of the path shall be rendered as specified by the Line Cap value. If the Dash Pattern's \tcode{double} member, which specifies an offset value, is not \tcode{0.0}, the meaning of its value is \impldef{Dash Pattern!offset value}.
\end{enumerate}

\rSec2 [surface.masking] {\tcode{surface} masking}

\pnum
This section is forthcoming in a future revision.

\rSec2 [surface.typesetting] {\tcode{surface} typesetting}

\pnum
This section is forthcoming in a future revision.

\rSec1 [surface.cons] {\tcode{surface} constructors, assignment operators, and destructors}

\indexlibrary{\idxcode{surface}!destructor}
\begin{itemdecl}
virtual ~surface();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Destroys an object of class \tcode{surface}.
\end{itemdescr}

\rSec1 [surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{finish}}
\indexlibrary{\idxcode{finish}!\idxcode{surface}}
\begin{itemdecl}
virtual void finish() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Releases all resources managed by the \tcode{surface} object \tcode{s} if \tcode{!s.is_finished()}, otherwise does nothing.

\pnum
\postconditions
\tcode{s.is_finished()} shall return \tcode{true}.

\pnum
\remarks
Once this function has been called, the surface is \term{finished}. The only valid operations on a finished surface are destruction, calling \tcode{finish()}, and calling \tcode{is_finished()}. Except as otherwise noted, any other operation on a finished surface or any attempt to use a finished \tcode{surface} or \tcode{surface}-derived object as an argument to a function produces undefined behavior; no diagnostic is required.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}
\indexlibrary{\idxcode{flush}!\idxcode{surface}}
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
	\item Any pending rendering and composing operations (\ref{surface.rendering}) shall be performed on the \tcode{surface} object.
	\enternote
	As long as the observable effect is the same as if they were performed immediately, it does not matter whether they are executed, batched, or otherwise committed to the \underlyingrendandpresenttechs.
	\exitnote
	\item The implementation may then modify the \tcode{surface} object's observable state (\ref{surface.state}). 
	\item The \tcode{surface} object's observable state shall then be undefined.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists to allow the user to take control of the underlying surface using an implementation-provided native handle without introducing a race condition. The implementation's responsibility is to ensure that the user can safely use the underlying surface.

\pnum
\errors
The potential errors are \impldef{surface::flush errors}.

\pnum
Implementations should avoid producing errors here.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.

\pnum
\realnotes
Because the \tcode{surface} object's observable state can change as a result of calling this function, users will typically want to call \tcode{surface::save} before calling this function. When the user is done using the \tcode{surface} object's native handle, he or she must call \tcode{surface::mark_dirty} if changes were made to the \underlyingsurface using the native handle as per that function's semantics. Once that is done, or immediately after access using the native handle is finished if no changes were made, the user needs to then call \tcode{surface::restore} (assuming a previous, valid call to {surface::save}). Otherwise the user must set every item of observable state before using the \tcode{surface} object in any other way.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device}}
\indexlibrary{\idxcode{device}!\idxcode{surface}}
\begin{itemdecl}
shared_ptr<experimental::io2d::device> device();
shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A shared pointer to the \tcode{device} object for this \tcode{surface}. If a \tcode{device} object does not already exist for this \tcode{surface}, a shared \tcode{device} object shall be allocated and returned.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if a \tcode{device} object needs to be created and not enough memory exists to do so.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const rectangle& extents);
void mark_dirty(const rectangle& extents, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
	\item If called without a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the entire \underlyingsurface.
	\item If called with a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the \underlyingsurface within the bounds specified by the \term{bounding rectangle} \tcode{rectangle\{ round(extents.x()), round (extents.y()), round(extents.width()), round(extents.height())\}}. No part of the bounding rectangle shall be outside of the bounds of the \underlyingsurface; no diagnostic is required.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
After external changes are made to this \tcode{surface} object's \underlyingsurface using a native pointer, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
No call to this function shall be required solely as a result of changes made to a surface using the functionality provided by \tcode{surface::map}.
\enternote
The \tcode{mapped_surface} type, which is used by \tcode{surface::map}, provides its own functionality for managing any such changes.
\exitnote

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mark_dirty}.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}
\indexlibrary{\idxcode{map}!\idxcode{surface}}
\begin{itemdecl}
void map(const function<void(mapped_surface&)>& action);
void map(const function<void(mapped_surface&, error_code&)>& action, error_code& ec);
void map(const function<void(mapped_surface&)>& action, const rectangle& extents);
void map(const function<void(mapped_surface&, error_code&)>& action,
  const rectangle& extents, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Creates a \tcode{mapped_surface} object and calls \tcode{action} using it.

\pnum
The \tcode{mapped_surface} object is created using \tcode{*this}, which allows direct manipulation of the \underlyingsurface.

\pnum
If called with a \tcode{const rectangle\& extents} argument, the \tcode{mapped_surface} object shall only allow manipulation of the portion of \tcode{*this} specified by the \term{bounding rectangle} \tcode{rectangle\{ round(extents.x()), round(extents.y()), round(extents.width()), round(extents.height())\}}. If any part of the bounding rectangle is outside of the bounds of \tcode{*this}, the call shall result in undefined behavior; no diagnostic is required.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
Whether changes are committed to the \underlyingsurface immediately or only when the \tcode{mapped_surface} object is destroyed is \unspecnorm.

\pnum
Calling this function on a \tcode{surface} object and then calling any function on the \tcode{surface} object or using the \tcode{surface} object before the call to this function has returned shall result in undefined behavior; no diagnostic is required.

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!map} or are produced by the user-provided function passed via the \tcode{action} argument.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{save}}
\indexlibrary{\idxcode{save}!\idxcode{surface}}
\begin{itemdecl}
virtual void save();
virtual void save(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Saves the state specified in \ref{surface.state.save} as if to an internal stack of saved states.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if the state cannot be saved.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{restore}}
\indexlibrary{\idxcode{restore}!\idxcode{surface}}
\begin{itemdecl}
virtual void restore();
virtual void restore(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Restores the state of \tcode{*this} to the values saved by the most recent call to \tcode{surface::save}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\remarks
\pnum
Because this function is only restoring previously saved state, except where the conditions for \tcode{io2d_error::invalid_restore} are met, implementations should not generate errors.

\pnum
\errors
\tcode{io2d_error::invalid_restore} if this function is called without a previous matching call to \tcode{surface::save}. Implementations shall not produce \tcode{io2d_error::invalid_restore} except under the conditions stated in this paragraph.

\pnum
Excluding the previously specified error, any errors produced by calling this function are \impldef{surface!restore}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{brush}}
\indexlibrary{\idxcode{brush}!\idxcode{surface}}
\begin{itemdecl}
void brush(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Current Brush (Table~\ref{tab:surface.state.listing}) to be a \tcode{brush} object that is the same as if it was the brush that is the default value of Current Brush \ref{surface.state.default}.

\pnum
\enternote
This function does not require that the Current Brush be set to the same \tcode{brush} object that was the original default value Current Brush \tcode{brush} object. That said, because this function is \tcode{noexcept}, implementers can (and likely should) keep a reference to the original, default value Current Brush \tcode{brush} object and use it when this function is called. Allocating a new \tcode{brush} object may result in errors due to memory constraints or other considerations.
\exitnote
\end{itemdescr}

\begin{itemdecl}
void brush(const experimental::io2d::brush& source);
void brush(const experimental::io2d::brush& source,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets \tcode{source} as the Current Brush (Table~\ref{tab:surface.state.listing}), ensuring that it shall not be destroyed and shall be recreated, if necessary, by the \underlyingrendandpresenttechs so that it shall be available for use at least until such time as it is no longer the Current Brush of any \tcode{surface} or \tcode{surface}-derived object.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!brush}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
void antialias(experimental::io2d::antialias a) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets General Antialiasing (Table~\ref{tab:surface.state.listing}) to the value of \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Dash Pattern (Table~\ref{tab:surface.state.listing}) to be the default value of Dash Pattern.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(const experimental::io2d::dashes& d);
void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Dash Pattern (Table~\ref{tab:surface.state.listing}) to the value of \tcode{d}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there is a problem caching the new Dash Pattern.

\pnum
\tcode{io2d_error::invalid_dash} if the new Dash Pattern contains a negative value or if it has values and all of them are \tcode{0.0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
void fill_rule(experimental::io2d::fill_rule fr) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Fill Rule (Table~\ref{tab:surface.state.listing}) to the value of \tcode{fr}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
void line_cap(experimental::io2d::line_cap lc) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Cap (Table~\ref{tab:surface.state.listing}) to the value of \tcode{lc}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
void line_join(experimental::io2d::line_join lj) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Join (Table~\ref{tab:surface.state.listing}) to the value of \tcode{lj}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_width}}
\indexlibrary{\idxcode{line_width}!\idxcode{surface}}
\begin{itemdecl}
void line_width(double width) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Width (Table~\ref{tab:surface.state.listing}) to \tcode{max(width, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
void miter_limit(double limit) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Miter Limit (Table~\ref{tab:surface.state.listing}) to the value of \tcode{limit} clamped to be within the range defined by the \impldef{Miter Limit!minimum} minimum value and the \impldef{Miter Limit!maximum} maximum value, inclusive.

\pnum
\remarks
The \impdef minimum value shall not be greater than \tcode{2.0} and the \impdef maximum value shall not be less than \tcode{10.0}.

\pnum
\realnotes
The Miter Limit only applies when the Line Join is set to \tcode{line_join::miter}.
\exitnote

\pnum
\remarks
The Miter Limit works as follow. The length of the miter is divided by the width of the line. If the resulting value is greater than the Miter Limit, the join will be beveled, otherwise it will be mitered.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
void compositing_operator(experimental::io2d::compositing_operator co)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Composition Operator to the value of \tcode{co}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip}}
\indexlibrary{\idxcode{clip}!\idxcode{surface}}
\begin{itemdecl}
void clip(const experimental::io2d::path& p);
void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Clip Area (Table~\ref{tab:surface.state.listing}) to be the intersection of the Clip Area and \tcode{p} where \tcode{p}'s area is determined in the same way as if \tcode{p} were filled according to the Fill Rule.

\pnum
\realnotes
The Clip Area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_immediate}}
\indexlibrary{\idxcode{clip_immediate}!\idxcode{surface}}
\begin{itemdecl}
void clip_immediate();
void clip_immediate(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Clip Area (Table~\ref{tab:surface.state.listing}) to be the intersection of the Clip Area and the Immediate Path (Table~\ref{tab:surface.state.listing}) where the Immediate Path's area is determined in the same way as if the Immediate Path were filled according to the Fill Rule.

\pnum
\realnotes
The Clip Area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{path}}
\indexlibrary{\idxcode{path}!\idxcode{surface}}
\begin{itemdecl}
void path(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Set's the Current Path (Table~\ref{tab:surface.state.listing}).

	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\begin{itemdecl}
void path(const experimental::io2d::path& p);
void path(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Set's Current Path (Table~\ref{tab:surface.state.listing}) to \tcode{p}.

\pnum
\remarks
Processing the path data so that it is properly transformed can be done at the time it is first set as a path on a \tcode{surface} object or any time before that. The untransformed \tcode{vector<path_data_item>} shall be retained to ensure that a path can be properly recreated at any time. The steps for converting an untransformed \tcode{vector<path_data_item>} to transformed path data are found at \ref{pathgeometries.processing}.
\end{itemdescr}

\rSec1 [surface.modifiers.immediatepath] {\tcode{surface} immediate path modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{immediate}}
\indexlibrary{\idxcode{immediate}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::path_factory& immediate() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A reference to the Immediate Path (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\rSec1 [surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{fill}}
\indexlibrary{\idxcode{fill}!\idxcode{surface}}
\begin{itemdecl}
void fill();
void fill(error_code& ec) noexcept;
void fill(const rgba_color& c);
void fill(const rgba_color& c, error_code& ec) noexcept;
void fill(const experimental::io2d::brush& b);
void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
void fill(const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
void fill(const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void fill(const surface& s, const matrix_2d& m, extend e = extend::none,
  filter f = filter::good);
void fill(const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Filling rendering and composing operation as specified by \ref{surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_immediate}}
\indexlibrary{\idxcode{fill_immediate}!\idxcode{surface}}
\begin{itemdecl}
void fill_immediate();
void fill_immediate(error_code& ec) noexcept;
void fill_immediate(const rgba_color& c);
void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
void fill_immediate(const experimental::io2d::brush& b);
void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
  noexcept;
void fill_immediate(const surface& s, const vector_2d& o = vector_2d{ }, 
  extend e = extend::none, filter f = filter::good);
void fill_immediate(const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void fill_immediate(const surface& s, const matrix_2d& m,
  extend e = extend::none, filter f = filter::good);
void fill_immediate(const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Filling rendering and composing operation as specified by \ref{surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!fill_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{paint}}
\indexlibrary{\idxcode{paint}!\idxcode{surface}}
\begin{itemdecl}
void paint();
void paint(error_code& ec) noexcept;
void paint(const rgba_color& c);
void paint(const rgba_color& c, error_code& ec) noexcept;
void paint(const experimental::io2d::brush& b);
void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
void paint(const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
void paint(const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void paint(const surface& s, const matrix_2d& m, extend e = extend::none,
  filter f = filter::good);
void paint(const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
void paint(double alpha);
void paint(double alpha, error_code& ec) noexcept;
void paint(const rgba_color& c, double alpha);
void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
void paint(const experimental::io2d::brush& b, double alpha);
void paint(const experimental::io2d::brush& b, double alpha,
  error_code& ec) noexcept;
void paint(const surface& s, double alpha,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good);
void paint(const surface& s, double alpha, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void paint(const surface& s, double alpha, const matrix_2d& m,
  extend e = extend::none, filter f = filter::good);
void paint(const surface& s, double alpha, const matrix_2d& m,
  error_code& ec, extend e = extend::none, filter f = filter::good)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Painting rendering and composing operation as specified by \ref{surface.painting}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!paint}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke}}
\indexlibrary{\idxcode{stroke}!\idxcode{surface}}
\begin{itemdecl}
void stroke();
void stroke(error_code& ec) noexcept;
void stroke(const rgba_color& c);
void stroke(const rgba_color& c, error_code& ec) noexcept;
void stroke(const experimental::io2d::brush& b);
void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
void stroke(const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
void stroke(const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
void stroke(const surface& s, const matrix_2d& m, extend e = extend::none,
  filter f = filter::good);
void stroke(const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Stroking rendering and composing operation as specified by \ref{surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_immediate}}
\indexlibrary{\idxcode{stroke_immediate}!\idxcode{surface}}
\begin{itemdecl}
void stroke_immediate();
void stroke_immediate(error_code& ec) noexcept;
void stroke_immediate(const rgba_color& c);
void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
void stroke_immediate(const experimental::io2d::brush& b);
void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
  noexcept;
void stroke_immediate(const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
void stroke_immediate(const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void stroke_immediate(const surface& s, const matrix_2d& m,
  extend e = extend::none, filter f = filter::good);
void stroke_immediate(const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Stroking rendering and composing operation as specified by \ref{surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!stroke_immediate}.
\end{itemdescr}

\rSec1 [surface.modifiers.maskrender] {\tcode{surface} mask render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{mask}}
\indexlibrary{\idxcode{mask}!\idxcode{surface}}
\begin{itemdecl}
void mask(const experimental::io2d::brush& mb);
void mask(const experimental::io2d::brush& mb, error_code& ec)
  noexcept;
void mask(const experimental::io2d::brush& mb, const rgba_color& c);
void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
  error_code& ec) noexcept;
void mask(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b);
void mask(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask(const experimental::io2d::brush& mb, const surface& s,
  const vector_2d& o = vector_2d{ }, extend e = extend::none, 
  filter f = filter::good);
void mask(const experimental::io2d::brush& mb, const surface& s,
  error_code& ec, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
void mask(const experimental::io2d::brush& mb, const surface& s,
  const matrix_2d& m, extend e = extend::none, filter f = filter::good);
void mask(const experimental::io2d::brush& mb, const surface& s,
  const matrix_2d& m, error_code& ec, extend e = extend::none,
  filter f = filter::good) noexcept;
void mask(const surface& ms);
void mask(const surface& ms, error_code& ec) noexcept;
void mask(const surface& ms, const rgba_color& c);
void mask(const surface& ms, const rgba_color& c, error_code& ec) noexcept;
void mask(const surface& ms, const experimental::io2d::brush& b);
void mask(const surface& ms, const experimental::io2d::brush& b, 
  error_code& ec) noexcept;
void mask(const surface& ms, const surface& s,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good);
void mask(const surface& ms, const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void mask(const surface& ms, const surface& s, const matrix_2d& m,
  extend e = extend::none, filter f = filter::good);
void mask(const surface& ms, const surface& s, const matrix_2d& m,
  error_code& ec, extend e = extend::none, filter f = filter::good)
  noexcept;
void mask(const surface& ms, const vector_2d& mo);
void mask(const surface& ms, const vector_2d& mo, error_code& ec) noexcept;
void mask(const surface& ms, const vector_2d& mo, const rgba_color& c);
void mask(const surface& ms, const vector_2d& mo, const rgba_color& c,
  error_code& ec) noexcept;
void mask(const surface& ms, const vector_2d& mo,
  const experimental::io2d::brush& b);
void mask(const surface& ms, const vector_2d& mo,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask(const surface& ms, const vector_2d& mo, const surface& s,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good);
void mask(const surface& ms, const vector_2d& mo, const surface& s,
  error_code& ec, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
void mask(const surface& ms, const vector_2d& mo, const surface& s,
  const matrix_2d& m, extend e = extend::none, filter f = filter::good);
void mask(const surface& ms, const vector_2d& mo, const surface& s,
  const matrix_2d& m, error_code& ec, extend e = extend::none,
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Masking rendering and composing operation as specified by \ref{surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mask}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mask_immediate}}
\indexlibrary{\idxcode{mask_immediate}!\idxcode{surface}}
\begin{itemdecl}
void mask_immediate(const experimental::io2d::brush& mb);
void mask_immediate(const experimental::io2d::brush& mb, error_code& ec)
  noexcept;
void mask_immediate(const experimental::io2d::brush& mb,
  const rgba_color& c);
void mask_immediate(const experimental::io2d::brush& mb,
  const rgba_color& c, error_code& ec) noexcept;
void mask_immediate(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b);
void mask_immediate(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good);
void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
  error_code& ec, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
  const matrix_2d& m, extend e = extend::none, filter f = filter::good);
void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
  const matrix_2d& m, error_code& ec, extend e = extend::none,
  filter f = filter::good) noexcept;
void mask_immediate(const surface& ms);
void mask_immediate(const surface& ms, error_code& ec) noexcept;
void mask_immediate(const surface& ms, const rgba_color& c);
void mask_immediate(const surface& ms, const rgba_color& c, error_code& ec) 
  noexcept;
void mask_immediate(const surface& ms, const experimental::io2d::brush& b);
void mask_immediate(const surface& ms, const experimental::io2d::brush& b,
  error_code& ec) noexcept;
void mask_immediate(const surface& ms, const surface& s,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good);
void mask_immediate(const surface& ms, const surface& s, error_code& ec,
  const vector_2d& o = vector_2d{ }, extend e = extend::none,
  filter f = filter::good) noexcept;
void mask_immediate(const surface& ms, const surface& s, const matrix_2d& m,
  extend e = extend::none, filter f = filter::good);
void mask_immediate(const surface& ms, const surface& s,
  const matrix_2d& m, error_code& ec, extend e = extend::none,
  filter f = filter::good) noexcept;
void mask_immediate(const surface& ms, const vector_2d& mo);
void mask_immediate(const surface& ms, const vector_2d& mo, error_code& ec)
  noexcept;
void mask_immediate(const surface& ms, const vector_2d& mo,
  const rgba_color& c);
void mask_immediate(const surface& ms, const vector_2d& mo,
  const rgba_color& c, error_code& ec) noexcept;
void mask_immediate(const surface& ms, const vector_2d& mo,
  const experimental::io2d::brush& b);
void mask_immediate(const surface& ms, const vector_2d& mo,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask_immediate(const surface& ms, const vector_2d& mo,
  const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
void mask_immediate(const surface& ms, const vector_2d& mo,
  const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
void mask_immediate(const surface& ms, const vector_2d& mo,
  const surface& s, const matrix_2d& m, extend e = extend::none,
  filter f = filter::good);
void mask_immediate(const surface& ms, const vector_2d& mo,
  const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Masking rendering and composing operation as specified by \ref{surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mask_immediate}.
\end{itemdescr}

\rSec1 [surface.modifiers.textrender] {\tcode{surface} text render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{render_text}}
\indexlibrary{\idxcode{render_text}!\idxcode{surface}}
\begin{itemdecl}
vector_2d render_text(const string& utf8, const vector_2d& pos);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const rgba_color& c);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const rgba_color& c, error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const experimental::io2d::brush& b);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, error_code& ec, const vector_2d& o = vector_2d{ },
  extend e = extend::none, filter f = filter::good) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, const matrix_2d& m, extend e = extend::none,
  filter f = filter::good);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, const matrix_2d& m, error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Typesetting rendering and composing operation as specified by \ref{surface.typesetting}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!render_text}.
\end{itemdescr}

\rSec1 [surface.modifiers.transform] {\tcode{surface} transformation modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{surface}}
\begin{itemdecl}
void matrix(const matrix_2d& m);
void matrix(const matrix_2d& m, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Transformation Matrix (Table~\ref{tab:surface.state.listing}) to the value of \tcode{m}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{io2d_error::invalid_matrix} if calling \tcode{!m.is_invertible()}.
\end{itemdescr}


\rSec1 [surface.modifiers.font] {\tcode{surface} font modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{font_face}}
\indexlibrary{\idxcode{font_face}!\idxcode{surface}}
\begin{itemdecl}
void font_face(const string& typeface, font_slant sl, font_weight w);
void font_face(const string& typeface, font_slant sl, font_weight w,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Font Face (Table~\ref{tab:surface.state.listing}) to the result of constructing a \tcode{simple_font_face} object using the arguments to this function.

\pnum
If an error occurs in constructing the \tcode{simple_font_face} object, Font Face shall retain the value it had prior to the execution of this function and that error shall be propagated back.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!font_face}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_face}}
\indexlibrary{\idxcode{font_face}!\idxcode{surface}}
\begin{itemdecl}
void font_face(const experimental::io2d::font_face& f);
void font_face(const experimental::io2d::font_face& f, error_code& ec)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Font Face (Table~\ref{tab:surface.state.listing}) to \tcode{f}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!font_face}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_size}}
\indexlibrary{\idxcode{font_size}!\idxcode{surface}}
\begin{itemdecl}
void font_size(double s);
void font_size(double s, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Font Matrix (Table~\ref{tab:surface.state.listing}) to the value of \tcode{matrix_2d::init_scale\{ \{ s, s \} \}}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{s <= 0.0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_matrix}}
\indexlibrary{\idxcode{font_matrix}!\idxcode{surface}}
\begin{itemdecl}
void font_matrix(const matrix_2d& m);
void font_matrix(const matrix_2d& m, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Font Matrix (Table~\ref{tab:surface.state.listing}) to the value of \tcode{m}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{io2d_error::invalid_matrix} if calling \tcode{!m.is_invertible()}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_options}}
\indexlibrary{\idxcode{font_options}!\idxcode{surface}}
\begin{itemdecl}
void font_options(const font_options& fo) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Font Options (Table~\ref{tab:surface.state.listing}) to \tcode{fo}.
\end{itemdescr}

\rSec1 [surface.observers.state] {\tcode{surface} state observers}

\indexlibrary{\idxcode{surface}!\idxcode{is_finished}}
\indexlibrary{\idxcode{is_finished}!\idxcode{surface}}
\begin{itemdecl}
bool is_finished() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If a call to \tcode{surface::finished} has previously been made, returns \tcode{true}; otherwise returns \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{content}}
\indexlibrary{\idxcode{content}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::content content() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The \tcode{content} enumerator (\ref{content.enumerators}) that appropriately describes the \underlyingsurface.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{brush}}
\indexlibrary{\idxcode{brush}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::brush brush() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Current Brush (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::antialias antialias() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of General Antialiasing (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::dashes dashes() const;
experimental::io2d::dashes dashes(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Dash Pattern (Table~\ref{tab:surface.state.listing}).

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
See \ref{surface.stroking} for more information about the \tcode{dashes} type.

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::fill_rule fill_rule() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Fill Rule (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::line_cap line_cap() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Cap (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::line_join line_join() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Join (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_width}}
\indexlibrary{\idxcode{line_width}!\idxcode{surface}}
\begin{itemdecl}
double line_width() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Width (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
double miter_limit() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Miter Limit (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::compositing_operator compositing_operator() const
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Composition Operator (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_extents}}
\indexlibrary{\idxcode{clip_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle clip_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains the Clip Area (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_clip}}
\indexlibrary{\idxcode{in_clip}!\idxcode{surface}}
\begin{itemdecl}
bool in_clip(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is outside of the Clip Area (Table~\ref{tab:surface.state.listing}), returns \tcode{false}; otherwise returns \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_rectangles}}
\indexlibrary{\idxcode{clip_rectangles}!\idxcode{surface}}
\begin{itemdecl}
vector<rectangle> clip_rectangles() const;
vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{vector<rectangle>} object which contains the rectangles which make up the Clip Area (Table~\ref{tab:surface.state.listing}).

\pnum
If an \tcode{error_code\&} argument is passed and the error \tcode{io2d_error::clip_not_representable} occurs, returns an empty \tcode{vector<rectangle>} object.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{io2d_error::clip_not_representable} if the Clip Area contains one or more areas that cannot be represented using rectangles.
\enterexample
This error would occur if the Clip Area contains arcs or curves.
\exitexample

\pnum
\tcode{errc::not enough memory} if a failure to allocate memory occurs.
\end{itemdescr}

\rSec1 [surface.observers.render] {\tcode{surface} render observers}

\indexlibrary{\idxcode{surface}!\idxcode{fill_extents}}
\indexlibrary{\idxcode{fill_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle fill_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::fill} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_extents_immediate}}
\indexlibrary{\idxcode{fill_extents_immediate}!\idxcode{surface}}
\begin{itemdecl}
rectangle fill_extents_immediate() const;
rectangle fill_extents_immediate(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{pathgeometries.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!fill_extents_immediate}.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::fill_immediate} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_fill}}
\indexlibrary{\idxcode{in_fill}!\idxcode{surface}}
\begin{itemdecl}
bool in_fill(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Filling operation areas.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::fill} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, the Clip Area, and the Transformation Matrix and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_fill_immediate}}
\indexlibrary{\idxcode{in_fill_immediate}!\idxcode{surface}}
\begin{itemdecl}
bool in_fill_immediate(const vector_2d& pt) const;
bool in_fill_immediate(const vector_2d& pt, error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Transformation Matrix, Clip Area, and the bound of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Filling operation areas.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{pathgeometries.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!in_fill_immediate}.

\pnum
\realnotes
The result does not mean that the point \tcode{pt} would be changed if \tcode{surface::fill} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, the Clip Area, and the Transformation Matrix and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_extents}}
\indexlibrary{\idxcode{stroke_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle stroke_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::stroke} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_extents_immediate}}
\indexlibrary{\idxcode{stroke_extents_immediate}!\idxcode{surface}}
\begin{itemdecl}
rectangle stroke_extents_immediate() const;
rectangle stroke_extents_immediate(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{pathgeometries.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!stroke_extents_immediate}.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::stroke_immediate} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_stroke}}
\indexlibrary{\idxcode{in_stroke}!\idxcode{surface}}
\begin{itemdecl}
bool in_stroke(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Stroking operation areas.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::stroke} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_stroke_immediate}}
\indexlibrary{\idxcode{in_stroke_immediate}!\idxcode{surface}}
\begin{itemdecl}
bool in_stroke_immediate(const vector_2d& pt) const;
bool in_stroke_immediate(const vector_2d& pt, error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Stroking operation areas.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{pathgeometries.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!in_stroke_immediate}.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::stroke_immediate} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_extents}}
\indexlibrary{\idxcode{font_extents}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::font_extents font_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{font_extents} object which specifies metrics for Font Face (Table~\ref{tab:surface.state.listing}). See the specification of the \tcode{font_extents} class (\ref{fontextents}) for more information.

\pnum
The Transformation Matrix is disregarded for purposes of calculating the metrics.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{text_extents}}
\indexlibrary{\idxcode{text_extents}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::text_extents text_extents(const string& utf8) const;
experimental::io2d::text_extents text_extents(const string& utf8,
  error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{text_extents} object which specifies metrics for \tcode{utf8} if it was rendered using Font Face (Table~\ref{tab:surface.state.listing}). See the specification of the \tcode{text_extents} class (\ref{textextents}) for more information.

\pnum
The Transformation Matrix is disregarded for purposes of calculating the metrics.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{utf8} is not a valid UTF-8 string.

\pnum
Other errors, if any, produced by this function are \impldef{surface!text_extents}.
\end{itemdescr}

\rSec1 [surface.observers.transform] {\tcode{surface} transformation observers}

\indexlibrary{\idxcode{surface}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{surface}}
\begin{itemdecl}
matrix_2d matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Transformation Matrix (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{user_to_surface}}
\indexlibrary{\idxcode{user_to_surface}!\idxcode{surface}}
\begin{itemdecl}
vector_2d user_to_surface(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of calling \tcode{matrix_2d::transform_point} on Transformation Matrix (Table~\ref{tab:surface.state.listing}) with \tcode{pt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{user_to_surface_distance}}
\indexlibrary{\idxcode{user_to_surface_distance}!\idxcode{surface}}
\begin{itemdecl}
vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of calling \tcode{matrix_2d::transform_distance} on Transformation Matrix (Table~\ref{tab:surface.state.listing}) with \tcode{dpt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{surface_to_user}}
\indexlibrary{\idxcode{surface_to_user}!\idxcode{surface}}
\begin{itemdecl}
vector_2d surface_to_user(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of creating a copy of Transformation Matrix (Table~\ref{tab:surface.state.listing}), calling \tcode{matrix_2d::invert} on that copy, and then calling \tcode{matrix_2d::transform_point} on the copy with \tcode{pt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{surface_to_user_distance}}
\indexlibrary{\idxcode{surface_to_user_distance}!\idxcode{surface}}
\begin{itemdecl}
vector_2d surface_to_user_distance(const vector_2d& dpt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of creating a copy of Transformation Matrix (Table~\ref{tab:surface.state.listing}), calling \tcode{matrix_2d::invert} on that copy, and then calling \tcode{matrix_2d::transform_distance} on the copy with \tcode{dpt} as the argument to that function.
\end{itemdescr}

\rSec1 [surface.observers.font] {\tcode{surface} font observers}

\indexlibrary{\idxcode{surface}!\idxcode{font_matrix}}
\indexlibrary{\idxcode{font_matrix}!\idxcode{surface}}
\begin{itemdecl}
matrix_2d font_matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Font Matrix (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_options}}
\indexlibrary{\idxcode{font_options}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::font_options font_options() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Font Options (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_face}}
\indexlibrary{\idxcode{font_face}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::font_face font_face() const;
experimental::io2d::font_face font_face(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Font Face (Table~\ref{tab:surface.state.listing}).
\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!font_face}.
\end{itemdescr}
