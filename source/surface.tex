%!TEX root = io2d.tex
\rSec0 [\iotwod.surface] {Class \tcode{surface}}

\rSec1 [\iotwod.surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}%
The \tcode{surface} class provides an interface for managing a graphics
data graphics resource.

\pnum
A \tcode{surface} object is a move-only object.

\pnum
The \tcode{surface} class provides two ways to modify its graphics resource:
\begin{itemize}
	\item Rendering and composing operations.
	\item Mapping.
\end{itemize}

\pnum
\begin{note}
While a \tcode{surface} object manages a graphics data graphics resource, the \tcode{surface} class does not provide well-defined semantics for the graphics resource. The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable.
\end{note}

\pnum
Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics data graphics resource or inherit well-defined semantics for the graphics data graphics resource from a base class.

\pnum
\begin{example}
The \tcode{image_surface} class and the \tcode{display_surface} class each specify that they manage a raster graphics data graphics resource and that the members they inherit from the \tcode{surface} class shall use that raster graphics data graphics resource as their graphics data graphics resource. Since, unlike graphics data, raster graphics data provides well-defined semantics, these classes meet the requirements for being directly instantiable.
\end{example}

\pnum
The definitions of the rendering and composing operations in \ref{\iotwod.surface.rendering} shall only be applicable when the graphics data graphics resource on which the \tcode{surface} members operate is a raster graphics data graphics resource. In all other cases, any attempt to invoke the rendering and composing operations shall result in undefined behavior.

\rSec1 [\iotwod.surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class surface {
  public:
    surface() = delete;
    
    // \ref{\iotwod.surface.modifiers.state}, state modifiers:
    void flush();
    void flush(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void map(const function<void(mapped_surface&)>& action);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const function<void(mapped_surface&)>& action,
      const rectangle& extents);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      const rectangle& extents, error_code& ec);

    // \ref{\iotwod.surface.modifiers.render}, render modifiers:
    void paint(const brush& b, const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void stroke(const brush& b, const path_builder<Allocator>& pb,
      const optional<brush_props>& bp = nullopt,
      const optional<stroke_props>& sp = nullopt,
      const optional<dashes>& d = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void stroke(const brush& b, const path_group& pg,
      const optional<brush_props>& bp = nullopt,
      const optional<stroke_props>& sp = nullopt,
      const optional<dashes>& d = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void fill(const brush& b, const path_builder<Allocator>& pb,
      const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void fill(const brush& b, const path_group& pg,
      const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void mask(const brush& b, const brush& mb,
      const optional<brush_props>& bp = nullopt,
      const optional<mask_props>& mp = nullopt,
      const optional<render_props>&rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void mask(const brush& b, const brush& mb,
      const optional<brush_props>& bp = nullopt,
      const optional<mask_props>& mp = nullopt,
      const optional<render_props>&rp = nullopt,
      const optional<clip_props>& cl = nullopt);
  };
}
\end{codeblock}

\rSec1 [\iotwod.surface.rendering] {Rendering and composing}

\rSec2 [\iotwod.surface.rendering.ops] {Operations}

\pnum
The \tcode{surface} class provides four fundamental rendering and composing operations:
\begin{libreqtab2}
 {\tcode{surface} rendering and composing operations}
 {tab:\iotwod.surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{surface::paint}
 \\
 Filling
 & \tcode{surface::fill}
 \\
 Stroking
 & \tcode{surface::stroke}
 \\
 Masking
 & \tcode{surface::mask}
 \\
\end{libreqtab2}

\rSec2 [\iotwod.surface.rendering.brushes] {Rendering and composing brushes}

\pnum
All rendering and composing operations use a Source Brush of type \tcode{brush}.

\pnum
The Masking rendering and composing operation uses a Mask Brush of type \tcode{brush}.

\rSec2 [\iotwod.surface.rendering.sourcepath] {Rendering and composing source path}

\pnum
In addition to brushes (\ref{\iotwod.surface.rendering.brushes}), all rendering and composing operation except for Painting use a Source Path of type \tcode{path_group}.

\rSec2 [\iotwod.surface.rendering.commonstate] {Common state data}

\pnum
All rendering and composing operations use the following state data:

\begin{libreqtab2}
 {\tcode{surface} rendering and composing common state data}
 {tab:\iotwod.surface.rendering.commonstate.listing}
 \\ \topline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Brush Properties
 & \tcode{brush_props}
 \\
 Surface Properties
 & \tcode{render_props}
 \\
 Clip Properties
 & \tcode{clip_props}
 \\
\end{libreqtab2}

\rSec2 [\iotwod.surface.rendering.specificstate] {Specific state data}

\pnum
In addition to the common state data (\ref{\iotwod.surface.rendering.commonstate}), certain rendering and composing operations use state data that is specific to each of them:

\begin{libiotwodtab3e}
 {\tcode{surface} rendering and composing specific state data}
 {tab:\iotwod.surface.rendering.specificstate.listing}
 \\ \topline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Stroking
 & Stroke Properties
 & \tcode{stroke_props}
 \\
 Masking
 & Mask Properties
 & \tcode{mask_props}
 \\
\end{libiotwodtab3e}

\rSec2 [\iotwod.surface.rendering.statedefaults] {State data default values}
\pnum
For all rendering and composing operations, the state data objects named above are provided using \tcode{optional<T>} class template arguments.

\pnum
If there is no contained value for a state data object, it is interpreted as-if the \tcode{optional<T>} argument contained a default constructed object of the relevant state data object.

\rSec1 [\iotwod.surface.coordinatespaces] {Standard coordinate spaces}

\pnum
There are four standard coordinate spaces relevant to the rendering and composing operations (\ref{\iotwod.surface.rendering}):
\begin{itemize}
\item the Brush Coordinate Space;
\item the Mask Coordinate Space;
\item the User Coordinate Space; and
\item the Surface Coordinate Space.
\end{itemize}

\pnum
The \term{Brush Coordinate Space} is the standard coordinate space of the Source Brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the Brush Properties' Brush Matrix (\ref{\iotwod.brushprops.summary}).

\pnum
The \term{Mask Coordinate Space} is the standard coordinate space of the Mask Brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the Mask Properties' Mask Matrix (\ref{\iotwod.maskprops.summary}).

\pnum
The \term{User Coordinate Space} is the standard coordinate space of \tcode{path_group} objects. Its transformation matrix is a default-constructed \tcode{matrix_2d}.

\pnum
The \term{Surface Coordinate Space} is the standard coordinate space of the \tcode{surface} object's \underlyingsurface. Its transformation matrix is the Surface Properties' Surface Matrix (\ref{\iotwod.renderprops.summary}).

\pnum
Given a point \tcode{pt}, a Brush Coordinate Space transformation matrix \tcode{bcsm}, a Mask Coordinate Space transformation matrix \tcode{mcsm}, a User Coordinate Space transformation matrix \tcode{ucsm}, and a Surface Coordinate Space transformation matrix \tcode{scsm}, the following table describes how to transform it from each of these standard coordinate spaces to the other standard coordinate spaces:

\begin{libiotwodreqtab3}
 {Point transformations}
 {tab:\iotwod.surface.pointtransforms.listing}
 \\ \topline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endhead
 Brush Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(bcsm.invert().transform_point(pt))}.
 \\
 Brush Coordinate Space
 & User Coordinate Space
 & \tcode{bcsm.invert().transform_point(pt)}.
 \\
 Brush Coordinate Space
 & Surface Coordinate Space
 & \tcode{scsm.transform_point(bcsm.invert().transform_point(pt))}.
 \\
 User Coordinate Space
 & Brush Coordinate Space
 & \tcode{bcsm.transform_point(pt)}.
 \\
 User Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(pt)}.
 \\
 User Coordinate Space
 & Surface Coordinate Space
 & \tcode{scsm.transform_point(pt)}.
 \\
 Surface Coordinate Space
 & Brush Coordinate Space
 & \tcode{bcsm.transform_point(scsm.invert().transform_point(pt))}.
 \\
 Surface Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(scsm.invert().transform_point(pt))}.
 \\
 Surface Coordinate Space
 & User Coordinate Space
 & \tcode{scsm.invert().transform_point(pt)}.
 \\
\end{libiotwodreqtab3}

\rSec1 [\iotwod.surface.painting] {\tcode{surface} painting}

\pnum
When a Painting operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (\tcode{clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{\iotwod.surface.coordinatespaces}) to the Brush Coordinate Space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (\ref{\iotwod.renderprops.summary}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the Composition Operator.
\end{enumerate}

\rSec1 [\iotwod.surface.filling] {\tcode{surface} filling}

\pnum
When a Filling operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{\iotwod.surface.coordinatespaces}) to the User Coordinate Space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $up$.
\item Using the Source Path (\ref{\iotwod.surface.rendering.sourcepath}) and the Fill Rule (\ref{\iotwod.brushprops.summary}), determine whether $up$ shall be filled; if so, proceed with the remaining steps.
\item Transform $up$ from the User Coordinate Space to the Brush Coordinate Space (\ref{\iotwod.surface.coordinatespaces} and Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (\ref{\iotwod.renderprops.summary}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the Composition Operator.
\end{enumerate}

\rSec1 [\iotwod.surface.stroking] {\tcode{surface} stroking}

\pnum
When a Stroking operation is initiated on a surface, the implementation shall carry out the Stroking operation for each path in the Source Path (\ref{\iotwod.surface.rendering}).

\pnum
The following rules shall apply when a Stroking operation is carried out on a pathy:
\begin{enumerate}
\item No part of the \underlyingsurface that is outside of the Clip Area shall be modified.

\item If the path only contains a degenerate path segment, then if the Line Cap value is either \tcode{line_cap::round} or \tcode{line_cap::square}, the line caps shall be rendered, resulting in a circle or a square, respectively. The remaining rules shall not apply.

\item If the path is a closed path, then the point where the end point of its final path segment meets the start point of the initial path segment shall be rendered as specified by the Line Join value; otherwise the start point of the initial path segment and end point of the final path segment shall each by rendered as specified by the Line Cap value. The remaining meetings between successive end points and start points shall be rendered as specified by the Line Join value.

\item If the Dash Pattern has its default value or if its \tcode{vector<double>} member is empty, the path segments shall be rendered as a continuous path.

\item If the Dash Pattern's \tcode{vector<double>} member contains only one value, that value shall be used to define a repeating pattern in which the path is shown then hidden. The ends of each shown portion of the path shall be rendered as specified by the Line Cap value.

\item If the Dash Pattern's \tcode{vector<double>} member contains two or more values, the values shall be used to define a pattern in which the path is alternatively rendered then not rendered for the length specified by the value. The ends of each rendered portion of the path shall be rendered as specified by the Line Cap value. If the Dash Pattern's \tcode{double} member, which specifies an offset value, is not \tcode{0.0}, the meaning of its value is \impldefplain{Dash Pattern!offset value}. If a rendered portion of the path overlaps a not rendered portion of the path, the rendered portion shall be rendered.
\end{enumerate}

\pnum
When a Stroking operation is carried out on a path, the width of each rendered portion shall be the Line Width. Ideally this means that the diameter of the stroke at each rendered point should be equal to the Line Width. However, because there is an infinite number of points along each rendered portion, implementations may choose an \unspecnorm method of determining minimum distances between points along each rendered portion and the diameter of the stroke between those points shall be the same.
\begin{note}
This concept is sometimes referred to as a tolerance. It allows for a balance between precision and performance, especially in situations where the end result is in a non-exact format such as raster graphics data.
\end{note}

\pnum
After all paths in the path group have been rendered but before the rendered result is composed to the \underlyingsurface, the rendered result shall be transformed from the User Coordinate Space (\ref{\iotwod.surface.coordinatespaces}) to the Surface Coordinate Space (\ref{\iotwod.surface.coordinatespaces}).
\begin{example}
If an open path consisting solely of a vertical line from \tcode{vector_2d(20.0, 20.0)} to \tcode{vector_2d(20.0, 60.0)} is to be composed to the \underlyingsurface, the Line Cap is \tcode{line_cap::none}, the Line Width is \tcode{12.0}, and the Transformation Matrix is \tcode{matrix_2d::init_scale(0.5, 1.0)}, then the line will end up being composed within the area \tcode{rectangle( \{ 7.0, 20.0 \}, \{ 13.0, 60.0 \} )} on the \underlyingsurface. The Transformation Matrix causes the center of the \xaxis of the line to move from \tcode{20.0} to \tcode{10.0} and then causes the horizontal width of the line to be reduced from \tcode{12.0} to \tcode{6.0}.
\end{example}

\rSec1 [\iotwod.surface.masking] {\tcode{surface} masking}

\pnum
A \term{Mask Brush} is composed of a graphics data graphics resource, a \tcode{wrap_mode} value, a \tcode{filter} value, and a \tcode{matrix_2d} object.

\pnum
When a Masking operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{\iotwod.surface.coordinatespaces}) to the Mask Coordinate Space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $mp$.
\item Sample the alpha channel from point $mp$ of the Mask Brush and store the result in $mac$; if the visual data format of the Mask Brush does not have an alpha channel, the value of $mac$ shall always be $1.0$.
\item Transform $sp$ from the Surface Coordinate Space to the Brush Coordinate Space, resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (\ref{\iotwod.renderprops.summary}), multiply each channel of the result produced by application of the Composition Operator by $map$ if the visual data format of the \underlyingsurface is a premultiplied format and if not then just multiply the alpha channel of the result by $map$, and modify the visual data of the \underlyingsurface at point $sp$ to reflect the multiplied result.
\end{enumerate}

\rSec1 [\iotwod.surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}%
\indexlibrary{\idxcode{flush}!\idxcode{surface}}%
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the surface's \underlyingsurface, this function does nothing.

\pnum
If the implementation does provide a native handle to the surface's \underlyingsurface, then the implementation performs every action necessary to ensure that all operations on the surface that produce observable effects occur.

\pnum
The implementation performs any other actions necessary to ensure that the surface will be usable again after a call to \tcode{surface::mark_dirty}.

\pnum
Once a call to \tcode{surface::flush} is made, \tcode{surface::mark_dirty} shall be called before any other member function of the surface is called or the surface is used as an argument to any other function.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists to allow the user to take control of the underlying surface using an implementation-provided native handle without introducing a race condition. The implementation's responsibility is to ensure that the user can safely use the underlying surface.

\pnum
\errors
The potential errors are \impldefplain{surface::flush errors}.

\pnum
Implementations should avoid producing errors here.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.

\pnum
\begin{note}
There are several purposes for \tcode{surface::flush} and \tcode{surface::mark_dirty}.

\pnum
One is to allow implementation wide latitude in how they implement the rendering and composing operations (\ref{\iotwod.surface.rendering}), such as batching calls and then sending them to the \underlyingrendandpresenttechs at appropriate times.

\pnum
Another is to give implementations the chance during the call to \tcode{surface::flush} to save any internal state that might be modified by the user and then restore it during the call to \tcode{surface::mark_dirty}.

\pnum
Other uses of this pair of calls are also possible.
\end{note}
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const rectangle& extents);
void mark_dirty(const rectangle& extents, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
	\item If called without a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the entire \underlyingsurface.
	\item If called with a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the \underlyingsurface within the bounds specified by the \term{bounding rectangle} \tcode{rectangle\{ round(extents.x()), round (extents.y()), round(extents.width()), round(extents.height())\}}. No part of the bounding rectangle shall be outside of the bounds of the \underlyingsurface; no diagnostic is required.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
After external changes are made to this \tcode{surface} object's \underlyingsurface using a native pointer, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
No call to this function shall be required solely as a result of changes made to a surface using the functionality provided by \tcode{surface::map}.
\begin{note}
The \tcode{mapped_surface} type, which is used by \tcode{surface::map}, provides its own functionality for managing any such changes.
\end{note}

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!mark_dirty}.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}%
\indexlibrary{\idxcode{map}!\idxcode{surface}}%
\begin{itemdecl}
void map(const function<void(mapped_surface&)>& action);
void map(const function<void(mapped_surface&, error_code&)>& action, error_code& ec);
void map(const function<void(mapped_surface&)>& action, const rectangle& extents);
void map(const function<void(mapped_surface&, error_code&)>& action,
  const rectangle& extents, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Creates a \tcode{mapped_surface} object and calls \tcode{action} using it.

\pnum
The \tcode{mapped_surface} object is created using \tcode{*this}, which allows direct manipulation of the \underlyingsurface.

\pnum
If called with a \tcode{const rectangle\& extents} argument, the \tcode{mapped_surface} object shall only allow manipulation of the portion of \tcode{*this} specified by the \term{bounding rectangle} \\
\tcode{rectangle\{ round(extents.x()), round(extents.y()), round(extents.width()), \\
round(extents.height())\}}. If any part of the bounding rectangle is outside of the bounds of \tcode{*this}, the call shall result in undefined behavior; no diagnostic is required.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
Whether changes are committed to the \underlyingsurface immediately or only when the \tcode{mapped_surface} object is destroyed is \unspecnorm.

\pnum
Calling this function on a \tcode{surface} object and then calling any function on the \tcode{surface} object or using the \tcode{surface} object before the call to this function has returned shall result in undefined behavior; no diagnostic is required.

\pnum
\errors
\tcode{errc::not_supported} if a \tcode{mapped_surface} object cannot be created for the \tcode{surface} object. The \tcode{surface} object is not modified if an error occurs.
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{paint}}%
\indexlibrary{\idxcode{paint}!\idxcode{surface}}%
\begin{itemdecl}
void paint(const brush& b, const optional<brush_props>& bp = nullopt,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Painting rendering and composing operation as specified by \ref{\iotwod.surface.painting}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!paint}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke}}%
\indexlibrary{\idxcode{stroke}!\idxcode{surface}}%
\begin{itemdecl}
template <class Allocator>
void stroke(const brush& b, const path_builder<Allocator>& pb,
  const optional<brush_props>& bp = nullopt,
  const optional<stroke_props>& sp = nullopt,
  const optional<dashes>& d = nullopt,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl = nullopt);
void stroke(const brush& b, const path_group& pg,
  const optional<brush_props>& bp = nullopt,
  const optional<stroke_props>& sp = nullopt,
  const optional<dashes>& d = nullopt,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Stroking rendering and composing operation as specified by \ref{\iotwod.surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill}}%
\indexlibrary{\idxcode{fill}!\idxcode{surface}}%
\begin{itemdecl}
template <class Allocator>
void fill(const brush& b, const path_builder<Allocator>& pb,
  const optional<brush_props>& bp = nullopt,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl = nullopt);
void fill(const brush& b, const path_group& pg,
  const optional<brush_props>& bp = nullopt,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Filling rendering and composing operation as specified by \ref{\iotwod.surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mask}}%
\indexlibrary{\idxcode{mask}!\idxcode{surface}}%
\begin{itemdecl}
template <class Allocator>
void mask(const brush& b, const brush& mb,
  const path_builder<Allocator>& pb,
  const optional<brush_props>& bp = nullopt,
  const optional<mask_props>& mp = nullopt,
  const optional<render_props>&rp = nullopt,
  const optional<clip_props>& cl = nullopt);
void mask(const brush& b, const brush& mb, const path_group& pg,
  const optional<brush_props>& bp = nullopt,
  const optional<mask_props>& mp = nullopt,
  const optional<render_props>&rp = nullopt,
  const optional<clip_props>& cl = nullopt);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Masking rendering and composing operation as specified by \ref{\iotwod.surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors

The errors, if any, produced by this function are \impldefplain{surface!mask}.
\end{itemdescr}
