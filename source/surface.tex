%!TEX root = io2d.tex
\rSec0 [surface] {Class \tcode{surface}}

\rSec1 [surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class surface {
  public:
    // \ref{surface.cons}, constructors, assignment operators, destructors:
    surface() = delete;
    surface(const surface&) = delete;
    surface& operator=(const surface&) = delete;
    surface(surface&& other) noexcept;
    surface& operator=(surface&& other) noexcept;
    virtual ~surface();

    // \ref{surface.modifiers.state}, state modifiers:
    virtual void finish() noexcept;
    void flush();
    void flush(error_code& ec) noexcept;
    shared_ptr<experimental::io2d::device> device();
    shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const rectangle& rect);
    void mark_dirty(const rectangle& rect, error_code& ec) noexcept;
    void map(const function<void(mapped_surface&)>& action);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      error_code& ec);
    void map(const function<void(mapped_surface&)>& action,
      const rectangle& extents);
    void map(const function<void(mapped_surface&, error_code&)>& action,
      const rectangle& extents, error_code& ec);
    virtual void save();
    virtual void save(error_code& ec) noexcept;
    virtual void restore();
    virtual void restore(error_code& ec) noexcept;
    void brush(experimental::nullopt_t) noexcept;
    void brush(const experimental::io2d::brush& source);
    void brush(const experimental::io2d::brush& source, error_code& ec)
      noexcept;
    void antialias(experimental::io2d::antialias a) noexcept;
    void dashes(experimental::nullopt_t) noexcept;
    void dashes(const experimental::io2d::dashes& d);
    void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
    void fill_rule(experimental::io2d::fill_rule fr) noexcept;
    void line_cap(experimental::io2d::line_cap lc) noexcept;
    void line_join(experimental::io2d::line_join lj) noexcept;
    void line_width(double width) noexcept;
    void miter_limit(double limit) noexcept;
    void compositing_operator(experimental::io2d::compositing_operator co)
      noexcept;
    void clip(const experimental::io2d::path& p);
    void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
    void clip_immediate();
    void clip_immediate(error_code& ec) noexcept;
    void path(experimental::nullopt_t) noexcept;
    void path(const experimental::io2d::path& p);
    void path(const experimental::io2d::path& p, error_code& ec) noexcept;

    // \ref{surface.modifiers.immediatepath}, immediate path modifiers:
    experimental::io2d::path_factory& immediate() noexcept;

    // \ref{surface.modifiers.render}, render modifiers:
    void fill();
    void fill(error_code& ec) noexcept;
    void fill(const rgba_color& c);
    void fill(const rgba_color& c, error_code& ec) noexcept;
    void fill(const experimental::io2d::brush& b);
    void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void fill(const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
      filter f = filter::good);
    void fill(const surface& s, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good) noexcept;
    void fill_immediate();
    void fill_immediate(error_code& ec) noexcept;
    void fill_immediate(const rgba_color& c);
    void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
    void fill_immediate(const experimental::io2d::brush& b);
    void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void fill_immediate(const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good);
    void fill_immediate(const surface& s, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good) noexcept;
    void paint();
    void paint(error_code& ec) noexcept;
    void paint(const rgba_color& c);
    void paint(const rgba_color& c, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b);
    void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void paint(const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
      filter f = filter::good);
    void paint(const surface& s, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good) noexcept;
    void paint(double alpha);
    void paint(double alpha, error_code& ec) noexcept;
    void paint(const rgba_color& c, double alpha);
    void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
    void paint(const experimental::io2d::brush& b, double alpha);
    void paint(const experimental::io2d::brush& b, double alpha,
      error_code& ec) noexcept;
    void paint(const surface& s, double alpha,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good);
    void paint(const surface& s, double alpha, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good)
      noexcept;
    void stroke();
    void stroke(error_code& ec) noexcept;
    void stroke(const rgba_color& c);
    void stroke(const rgba_color& c, error_code& ec) noexcept;
    void stroke(const experimental::io2d::brush& b);
    void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
    void stroke(const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
      filter f = filter::good);
    void stroke(const surface& s, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good) noexcept;
    void stroke_immediate();
    void stroke_immediate(error_code& ec) noexcept;
    void stroke_immediate(const rgba_color& c);
    void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
    void stroke_immediate(const experimental::io2d::brush& b);
    void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
      noexcept;
    void stroke_immediate(const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good);
    void stroke_immediate(const surface& s, error_code& ec,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.maskrender}, mask render modifiers:
    void mask(const experimental::io2d::brush& mb);
    void mask(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask(const experimental::io2d::brush& mb, const rgba_color& c);
    void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
      error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good);
    void mask(const experimental::io2d::brush& mb, const surface& s,
      error_code& ec, matrix m = matrix_2d::init_identity(),
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask(surface& ms,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask(surface& ms, error_code& ec, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask(surface& ms, const rgba_color& c,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask(surface& ms, const rgba_color& c, error_code& ec, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask(surface& ms, const experimental::io2d::brush& b, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask(surface& ms, const experimental::io2d::brush& b, error_code& ec,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask(surface& ms, const surface& s,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      const matrix_2d& m = matrix_2d::init_identity(),
      extend msExtend = extend::none, extend e = extend::none,
      filter msFilter = filter::good, filter f = filter::good);
    void mask(surface& ms, const surface& s, error_code& ec,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      const matrix_2d& m = matrix_2d::init_identity(),
      extend msExtend = extend::none, extend e = extend::none,
      filter msFilter = filter::good, filter f = filter::good) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb);
    void mask_immediate(const experimental::io2d::brush& mb, error_code& ec)
      noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c);
    void mask_immediate(const experimental::io2d::brush& mb,
      const rgba_color& c, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b);
    void mask_immediate(const experimental::io2d::brush& mb,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
      filter f = filter::good);
    void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), error_code& ec,
      extend e = extend::none, filter f = filter::good) noexcept;
    void mask_immediate(surface& ms,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask_immediate(surface& ms, error_code& ec, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask_immediate(surface& ms, const rgba_color& c, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask_immediate(surface& ms, const rgba_color& c, error_code& ec, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask_immediate(surface& ms, const experimental::io2d::brush& b, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good);
    void mask_immediate(surface& ms, const experimental::io2d::brush& b,
      error_code& ec, const matrix_2d& msMatrix = matrix_2d::init_identity(),
      extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
    void mask_immediate(surface& ms, const surface& s, 
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      const matrix_2d& m = matrix_2d::init_identity(),
      extend msExtend = extend::none, extend e = extend::none,
      filter msFilter = filter::good, filter f = filter::good);
    void mask_immediate(surface& ms, const surface& s, error_code& ec,
      const matrix_2d& msMatrix = matrix_2d::init_identity(),
      const matrix_2d& m = matrix_2d::init_identity(),
      extend msExtend = extend::none, extend e = extend::none,
      filter msFilter = filter::good, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.textrender}, text render modifiers:
    vector_2d render_text(const string& utf8, const vector_2d& pos);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const rgba_color& c, error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m = matrix_2d::init_identity(),
      extend e = extend::none, filter f = filter::good);
    vector_2d render_text(const string& utf8, const vector_2d& pos,
      const surface& s, const matrix_2d& m = matrix_2d::init_identity(),
      error_code& ec, extend e = extend::none,
      filter f = filter::good) noexcept;
    void render_glyph_run(const glyph_run& gr);
    void render_glyph_run(const glyph_run& gr, error_code& ec) noexcept;
    void render_glyph_run(const glyph_run& gr, const rgba_color& c);
    void render_glyph_run(const glyph_run& gr, const rgba_color& c,
      error_code& ec) noexcept;
    void render_glyph_run(const glyph_run& gr,
      const experimental::io2d::brush& b);
    void render_glyph_run(const glyph_run& gr,
      const experimental::io2d::brush& b, error_code& ec) noexcept;
    void render_glyph_run(const glyph_run& gr, const surface& s,
      const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
      filter f = filter::good);
    void render_glyph_run(const glyph_run& gr, const surface& s,
      error_code& ec, const matrix_2d& m = matrix_2d::init_identity(),
      extend e = extend::none, filter f = filter::good) noexcept;
    
    // \ref{surface.modifiers.transform}, transformation modifiers:
    void matrix(const matrix_2d& matrix);
    void matrix(const matrix_2d& matrix, error_code& ec) noexcept;
    
    // \ref{surface.modifiers.font}, font modifiers:
    void font_resource(const experimental::io2d::font_resource& f) noexcept;
    void font_resource(const ::std::string& family, double size,
      font_slant sl = font_slant::normal, font_weight w = font_weight::normal);
    void font_resource(const ::std::string& family, double size,
      error_code& ec, font_slant sl = font_slant::normal,
      font_weight w = font_weight::normal) noexcept;
    
    // \ref{surface.observers.state}, state observers:
    bool is_finished() const noexcept;
    experimental::io2d::content content() const noexcept;
    experimental::io2d::brush brush() const noexcept;
    experimental::io2d::antialias antialias() const noexcept;
    experimental::io2d::dashes dashes() const;
    experimental::io2d::dashes dashes(error_code& ec) const noexcept;
    experimental::io2d::fill_rule fill_rule() const noexcept;
    experimental::io2d::line_cap line_cap() const noexcept;
    experimental::io2d::line_join line_join() const noexcept;
    double line_width() const noexcept;
    double miter_limit() const noexcept;
    experimental::io2d::compositing_operator compositing_operator() const
      noexcept;
    rectangle clip_extents() const noexcept;
    bool in_clip(const vector_2d& pt) const noexcept;
    vector<rectangle> clip_rectangles() const;
    vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
    
    // \ref{surface.observers.render}, render observers:
    rectangle fill_extents() const noexcept;
    rectangle fill_extents_immediate() const;
    rectangle fill_extents_immediate(error_code& ec) const noexcept;
    bool in_fill(const vector_2d& pt) const noexcept;
    bool in_fill_immediate(const vector_2d& pt) const;
    bool in_fill_immediate(const vector_2d& pt, error_code& ec) const noexcept;
    rectangle stroke_extents() const noexcept;
    rectangle stroke_extents_immediate() const;
    rectangle stroke_extents_immediate(error_code& ec) const noexcept;
    bool in_stroke(const vector_2d& pt) const noexcept;
    bool in_stroke_immediate(const vector_2d& pt) const;
    bool in_stroke_immediate(const vector_2d& pt, error_code& ec) const 
      noexcept;
    experimental::io2d::font_extents font_extents() const noexcept;
    experimental::io2d::text_extents text_extents(const string& utf8) const;
    experimental::io2d::text_extents text_extents(const string& utf8,
      error_code& ec) const noexcept;
    
    // \ref{surface.observers.transform}, transformation observers:
    matrix_2d matrix() const noexcept;
    vector_2d user_to_surface(const vector_2d& pt) const noexcept;
    vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
    vector_2d surface_to_user(const vector_2d& pt) const noexcept;
    vector_2d surface_to_user_distance(const vector_2d& dpt) const noexcept;
    
    // \ref{surface.observers.font}, font observers:
    experimental::io2d::font_resource font_resource() const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}
The \tcode{surface} class provides an interface for managing a graphics
data graphics resource and its observable state data
(\ref{surface.state}).

\pnum
A \tcode{surface} object is a move-only object.

\pnum
The \tcode{surface} class provides two ways to modify its graphics resource:
\begin{itemize}
\item Rendering and composing operations.
\item Mapping.
\end{itemize}

\pnum
\enternote
While a \tcode{surface} object manages a graphics data graphics resource, the \tcode{surface} class does not provide well-defined semantics for the graphics resource. The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable.
\exitnote

\pnum
Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics data graphics resource or inherit well-defined semantics for the graphics data graphics resource from a base class.

\pnum
\enterexample
The \tcode{image_surface} class and the \tcode{display_surface} class each specify that they manage a raster graphics data graphics resource and that the members they inherit from the \tcode{surface} class shall use that raster graphics data graphics resource as their graphics data graphics resource. Since, unlike graphics data, raster graphics data provides well-defined semantics, these classes meet the requirements for being directly instantiable.
\exitexample

\pnum
The definitions of the rendering and composing operations in \ref{surface.rendering} shall only be applicable when the graphics data graphics resource on which the \tcode{surface} members operate is a raster graphics data graphics resource. In all other cases, any attempt to invoke the rendering and composing operations shall result in undefined behavior.

\rSec1 [surface.state] {\tcode{surface} state}

\pnum
Table~\ref{tab:surface.state.listing} specifies the name, type, function, and default value for each item of a surface's observable state.

\rSec2 [surface.state.default] {\tcode{surface} state default values}

\begin{libreqtab4b}
	{Surface observable state}
	{tab:surface.state.listing}
	\\ \topline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endfirsthead
	\continuedcaption\\
	\hline
	\lhdr{Name}   &   \chdr{Type}  &   \chdr{Function}  &   \rhdr{Default value}       \\ \capsep
	\endhead
	
	\term{Current Brush} &
	\tcode{brush} &
	This is the brush that shall be available for use when performing rendering and composing operations &
	\tcode{brush\{ \{ rgba_color::black() \} \}} \\ \rowsep

	\term{General Antialiasing} &
	\tcode{antialias} &
	This is the type of antialiasing that should be used when performing non-text rendering operations &
	\tcode{antialias::default_antialias}\\ \rowsep
	
	\term{Dash Pattern} &
	\tcode{dashes} &
	This specifies the pattern that shall be used when performing stroke rendering operations &
	\tcode{dashes\{ vector<double>(), 0.0 \}} \\ \rowsep
	
	\term{Fill Rule} &
	\tcode{fill_rule} &
	This controls which areas of paths shall be eligible to be filled when performing fill rendering operations &
	\tcode{fill_rule::winding} \\ \rowsep
	
	\term{Line Cap} &
	\tcode{line_cap} &
	This specifies how the end of a path segment that is not joined to another path segment shall be rendered when performing stroke rendering operations &
	\tcode{line_cap::butt} \\ \rowsep
	
	\term{Line Join} &
	\tcode{line_join} &
	This specifies how the join point of two path segments that are joined to each other shall be rendered when performing stroke rendering operations &
	\tcode{line_join::miter} \\ \rowsep
	
	\term{Line Width} &
	\tcode{double} &
	This is the width, in surface coordinate space units, that shall be used to determine the rendered width of path segments when performing a stroke rendering operation &
	\tcode{2.0} \\ \rowsep
	
	\term{Miter Limit} &
	\tcode{double} &
	This is the value that shall be used to calculate whether a line join shall be mitered or beveled when the value of Line Join is \tcode{line_join::miter}. &
	\tcode{10.0} \\ \rowsep
	
	\term{Composition Operator} &
	\tcode{compositing_operator} &
	This specifies the composition algorithm that shall be used when performing rendering operations &
	\tcode{compositing_operator::over} \\ \rowsep
	
	\term{Clip Area} &
	\unspec &
	The area or areas of the \underlyingsurface which are the only areas in which composing operations can have any effect. It is in the Surface Coordinate Space (\ref{surface.coordinatespaces}) &
	An unbounded area \\ \rowsep
	
	\term{Current Path} &
	\tcode{path} &
	This is the \tcode{path} object that shall be used when performing non-immediate rendering operations. It is in the User Coordinate Space (\ref{surface.coordinatespaces}) &
	\tcode{path\{ path_factory\{ \} \}} \\ \rowsep
	
	\term{Immediate Path} &
	\tcode{path_factory} &
	This is the \tcode{path_factory} object that shall be used when performing immediate rendering operations. It is in the User Coordinate Space (\ref{surface.coordinatespaces}) &
	\tcode{path_factory\{ \}} \\ \rowsep
	
	\term{Transformation Matrix} &
	\tcode{matrix_2d} &
	This is the \tcode{matrix_2d} object that shall be used to transform points to and from the Surface Coordinate Space (\ref{surface.coordinatespaces}) &
	\tcode{matrix_2d::init_identity\{ \}} \\ \rowsep
	
	\term{Font Resource} &
	\tcode{font_resource} &
	This is the font that shall be used when performing text rendering operations &
	\tcode{font_resource\{ font_resource_factory\{ \} \}} \\ \rowsep
	
\end{libreqtab4b}

\pnum
\enternote
The Clip Area may be modified by intersecting the current Clip Area with the areas of a \tcode{path} object that would be filled according to the current Fill Rule. The resulting Clip Area will only contain areas that were already in the Clip Area and does not need to be a valid \tcode{path} object since the Clip Area is only guaranteed to be observable by the effects it has on composing operations. For this reason, the Clip Area's type is unspecified. The Clip Area may also be modified by resetting it to its default value, which is the only way of enlarging the current Clip Area.
\exitnote

\rSec2 [surface.state.save] {\tcode{surface} saved state}

\pnum
A surface object provides an interface to save its current state and subsequently restore it.

\pnum
Save and restore operations are performed using \tcode{surface::save} and \tcode{surface::restore}, respectively.

\pnum
Save and restore operations may be nested.

\pnum
Each call to \tcode{surface::restore} restores a surface object's state to its values at the time of the most recent call to \tcode{surface::save}.

\pnum
The following list denotes each item of observable state that shall be saved by \tcode{surface::save} and restored by \tcode{surface::restore}, using the state item names listed in Table~\ref{tab:surface.state.listing}:

\begin{itemize}
	\item Current Brush
	\item General Antialiasing
	\item Dash Pattern
	\item Fill Rule
	\item Line Cap
	\item Line Join
	\item Line Width
	\item Miter Limit
	\item Compositing Operator
	\item Tolerance
	\item Clip Area
	\item Current Path
	\item Immediate Path
	\item Transformation Matrix
	\item Font Resource
\end{itemize}

\rSec1 [surface.rendering] {\tcode{surface} rendering and composing operations}

\pnum
The \tcode{surface} class provides five fundamental rendering and composing operations:
\begin{libreqtab2}
 {\tcode{surface} rendering and composing operations}
 {tab:surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{surface::paint}
 \\
 Filling
 & \tcode{surface::fill}, \tcode{surface::fill_immediate}
 \\
 Stroking
 & \tcode{surface::stroke}, \tcode{surface::stroke_immediate}
 \\
 Masking
 & \tcode{surface::mask}, \tcode{surface::mask_immediate}
 \\
 Typesetting
 & \tcode{surface::render_text}, \tcode{surface::render_glyph_run}
 \\
\end{libreqtab2}

\pnum
The filling, stroking, masking, and typesetting operations each provide two functions, not including overloads, for invoking their functionality.

\pnum
Certain rendering and composing operations require a \term{Source Path}, which is a path geometry graphics resource.

\pnum
The rendering and composing operations invoked by the \tcode{surface::fill}, \tcode{surface::stroke}, and \tcode{surface::mask} functions shall use the \tcode{surface} object's Current Path as their Source Path.

\pnum
The rendering and composing operations invoked by the \tcode{surface::fill_immediate}, \tcode{surface::stroke_immediate}, and \tcode{surface::mask_immediate} functions shall use as their Source Path a path geometry graphics resource formed in the manner specified by \ref{paths.processing} from the (\textit{const} reference to) \tcode{vector<path_data_item>} returned by calling the \tcode{path_factory::data_ref} member function on the surface's Immediate Path.

\pnum
Provided that none of the function calls results in an error, given a \tcode{surface} object \tcode{s}, there shall be no observable difference in the results of:
\begin{itemize}
	\item calling \tcode{surface::fill_immediate} on \tcode{s} versus calling \tcode{surface::fill} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	
	\item calling \tcode{surface::stroke_immediate} on \tcode{s} versus calling \tcode{surface::stroke} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function;
	
	\item calling \tcode{surface::mask_immediate} on \tcode{s} versus calling \tcode{surface::mask} on \tcode{s} with the same arguments immediately after creating a \tcode{path} object from the result of calling \tcode{surface::immediate} on \tcode{s} and then immediately setting that \tcode{path} object as the Current Path by calling \tcode{surface::path} on \tcode{s} using that \tcode{path} object as the argument to that function.
\end{itemize}

\pnum
The painting operation is a single-part operation consisting of a composing operation. Each of the other operations is a multi-part operation consisting of a rendering operation followed by a composing operation.

\pnum
The surface's Clip Area shall always apply to all composing operations. This is true even if no mention is made of the Clip Area in the description of a composing operation or if the description of a composing operation uses phraseology that could otherwise be read as being unconstrained.
\enternote
Because of this, mention of the applicability of the Clip Area will be omitted in the descriptions of the composing operation portions of the rendering and composing operations that follow.
\exitnote

\pnum
Each of the five fundamental rendering and composing operations has its own set of minimum arguments.
\begin{enumerate}
	\item The Painting operation has no minimum arguments.
	\item The Filling operation has no minimum arguments.
	\item The Stroking operation has no minimum arguments.
	\item The Masking operation has a Mask Brush (\ref{surface.masking}) which can be composed of one or four minimum arguments: if the first argument to the Masking operation is of type \tcode{brush}, it has one minimum argument (that \tcode{brush} object); otherwise the first argument is of type \tcode{surface} and other three arguments are the first \tcode{matrix_2d} argument, the first \tcode{extend} argument, and the first \tcode{filter} argument, resulting in four minimum arguments.
	\item The Typesetting operation has one or two minimum arguments: if the Typesetting operation is invoked using \tcode{surface::render_text}, it has two minimum arguments, an object of type \tcode{string} that is used as the text that is rendered and composed to the surface and an object of type \tcode{vector_2d} that is used to specify the coordinates at which the origin of the first character of the text is positioned (see \ref{surface.typesetting}); if the Typesetting operation is invoked using \tcode{surface::render_glyph_run}, it has one minimum argument, an object of type \tcode{glyph_run} that specifies the glyphs that shall be rendered, the coordinates at which each of those glyphs shall be rendered, and the \tcode{font_resource} object that shall be used to render those glyphs.
\end{enumerate}

\pnum
If a reference to an \tcode{error_code} object (see \ref{\iotwod.err.report}) is passed to a rendering and composing operation, it shall be considered part of the set of minimum arguments for that operation.

\pnum
For the Masking operation, where a \tcode{surface} object is used as the Mask Brush argument, it may be immediately followed by an argument of type \tcode{vector_2d} which shall be used as the origin of the \tcode{surface} object used as the Mask Brush (see \ref{surface.masking}) and it shall be considered part of the set of minimum arguments for that operation.

\rSec1 [surface.sourcebrush]{Source Brush for rendering and composing operations}

\pnum
A \term{Source Brush} is composed of a graphics data graphics resource, an \tcode{extend} value, a \tcode{filter} value, and a \tcode{matrix_2d} object.

\pnum
A \tcode{brush} object provides all of the components of a Source Brush. As such, \tcode{brush} objects will commonly be used as Source Brushes.

\pnum
The rendering and composing operations require a Source Brush each time they are invoked. The following paragraphs specify how the Source Brush shall be determined.

\pnum
A Source Brush can be provided as a \tcode{brush} object or as an identified set of arguments which, together, provide all of the components of a Source Brush.

\pnum
When a rendering and composing operation is invoked with only those arguments that are part of its set of minimum arguments, the \tcode{surface} object's Current Brush shall be the Source Brush.

\pnum
When a rendering and composing operation is invoked with \term{extra arguments}, which are additional arguments beyond those that are part of its set of minimum arguments, the Source Brush shall be as follows, with any errors reported as specified in Error reporting (\ref{\iotwod.err.report}):
\begin{itemize}
	\item Where there is one extra argument and it is a \tcode{brush} object, the Source Brush shall be that \tcode{brush} object.
	\item Where there is one extra argument and it is an \tcode{rgba_color} object, the Source Brush shall be the same as if it were a \tcode{brush} object constructed from a \tcode{solid_color_brush_factory} constructed from the extra argument and sampling from it shall be as specified by \ref{brush.sampling} and \ref{brush.sampling.solidcolor}.
	\item Where there is more than one extra argument, including default arguments, and the first extra argument is a \tcode{surface} object, the Source Brush shall be the same as if it were a \tcode{brush} object \tcode{b} constructed from a \tcode{surface_brush_factory} constructed from the \tcode{surface} object extra argument and sampling from it shall be as specified by \ref{brush.sampling} and \ref{brush.sampling.surface}, subject to the following adjustments:
	\begin{enumerate}
		\item The \tcode{surface} object extra argument should be used directly; no copy of it should be made. This differs from the \tcode{surface_brush_factory} class, which requires that a copy of the surface be made and that only the copy be used.
		\item The Source Brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::extend} was called on \tcode{b} with the \tcode{extend} object extra argument passed to \tcode{brush::extend} as an argument.
		\item The Source Brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::filter} was called on \tcode{b} with the \tcode{filter} object extra argument passed to \tcode{brush::filter} as an argument.
		\item The Source Brush shall produce the same observable results that \tcode{b} would produce after \tcode{brush::matrix} was called on \tcode{b} with the \tcode{matrix} object extra argument passed to \tcode{brush::matrix} as an argument.
	\end{enumerate}
\end{itemize}

\pnum
\enternote
The rendering and composing operations each have the same combinations of extra arguments, all of which are covered by the above requirements that determine the Source Brush when extra arguments are present.
\exitnote

\pnum
A \tcode{surface} object shall not be used as a Mask Brush or as a Source Brush for any rendering and composing operations invoked on that \tcode{surface} object; no diagnostic is required.
\enternote
When a \tcode{brush} object \tcode{b} is created from a \tcode{surface} object \tcode{s} using the \tcode{surface_brush_factory} class, \tcode{b} can be used as a Mask Brush or as a Source Brush for rendering and composing operations invoked on \tcode{s} because the \tcode{surface_brush_factory} class creates a copy of \tcode{s} (see \ref{surfacebrushfact}), thereby avoiding the aliasing problems and potential race conditions that would otherwise exist.
\exitnote

\rSec1 [surface.coordinatespaces] {Standard coordinate spaces}

\pnum
There are four standard coordinate spaces relevant to the rendering and composing operations (\ref{surface.rendering}):
\begin{itemize}
\item the Brush Coordinate Space;
\item the Mask Coordinate Space; ***FIXME*** the Font Coordinate Space(?)
\item the User Coordinate Space; and
\item the Surface Coordinate Space.
\end{itemize}

\pnum
The \term{Brush Coordinate Space} is the standard coordinate space of the Source Brush (\ref{surface.sourcebrush}). Its transformation matrix is as if it was a copy of the Source Brush's \tcode{matrix_2d} object.

\pnum
The \term{Mask Coordinate Space} is the standard coordinate space of the Mask Brush (\ref{surface.masking}). Its transformation matrix is as if it was a copy of the Mask Brush's \tcode{matrix_2d} object.

\pnum
The \term{User Coordinate Space} is the standard coordinate space of \tcode{surface} object. Its transformation matrix is the return value of \tcode{matrix_2d::init_identity}.% without regard to the Transformation Matrix (Table~\ref{tab:surface.state.listing}).

\pnum
The \term{Surface Coordinate Space} is the standard coordinate space of the \tcode{surface} object's \underlyingsurface. Its transformation matrix is the return value of calling \tcode{s.matrix()} where \tcode{s} is the \tcode{surface} object.

\pnum
Given a point \tcode{pt}, a Brush Coordinate Space transformation matrix \tcode{bcsm}, a Mask Coordinate Space transformation matrix \tcode{mcsm}, a User Coordinate Space transformation matrix \tcode{ucsm}, and a Surface Coordinate Space transformation matrix \tcode{scsm}, the following table describes how to transform it from each of these standard coordinate spaces to the other standard coordinate spaces:

\begin{libiotwodreqtab3}
 {Point transformations}
 {tab:surface.pointtransforms.listing}
 \\ \topline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endhead
 Brush Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(bcsm.invert().transform_point(pt))}.
 \\
 Brush Coordinate Space
 & User Coordinate Space
 & \tcode{bcsm.invert().transform_point(pt)}.
 \\
 Brush Coordinate Space
 & Surface Coordinate Space
 & \tcode{scsm.transform_point(bcsm.invert().transform_point(pt))}.
 \\
 User Coordinate Space
 & Brush Coordinate Space
 & \tcode{bcsm.transform_point(pt)}.
 \\
 User Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(pt)}.
 \\
 User Coordinate Space
 & Surface Coordinate Space
 & \tcode{scsm.transform_point(pt)}.
 \\
 Surface Coordinate Space
 & Brush Coordinate Space
 & \tcode{bcsm.transform_point(scsm.invert().transform_point(pt))}.
 \\
 Surface Coordinate Space
 & Mask Coordinate Space
 & \tcode{mcsm.transform_point(scsm.invert().transform_point(pt))}.
 \\
 Surface Coordinate Space
 & User Coordinate Space
 & \tcode{scsm.invert().transform_point(pt)}.
 \\
\end{libiotwodreqtab3}

\rSec1 [surface.painting] {\tcode{surface} painting}

\pnum
When a Painting operation is initiated on a surface, the implementation shall produce results as if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (Table~\ref{tab:surface.state.listing}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{surface.coordinatespaces}) to the Brush Coordinate Space (Table~\ref{tab:surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{surface.sourcebrush}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (Table~\ref{tab:surface.state.listing}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the Composition Operator.
\end{enumerate}

\rSec1 [surface.filling] {\tcode{surface} filling}

\pnum
When a Filling operation is initiated on a surface, the implementation shall produce results as if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (Table~\ref{tab:surface.state.listing}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{surface.coordinatespaces}) to the User Coordinate Space (Table~\ref{tab:surface.pointtransforms.listing}), resulting in point $up$.
\item Using the Source Path (\ref{surface.rendering}) and the Fill Rule (Table~\ref{tab:surface.state.listing}), determine whether $up$ shall be filled; if so, proceed with the remaining steps.
\item Transform $up$ from the User Coordinate Space to the Brush Coordinate Space (\ref{surface.coordinatespaces} and Table~\ref{tab:surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{surface.sourcebrush}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (Table~\ref{tab:surface.state.listing}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the Composition Operator.
\end{enumerate}

\rSec1 [surface.stroking] {\tcode{surface} stroking}

\pnum
When a Stroking operation is initiated on a surface, the implementation shall carry out the Stroking operation for each path geometry in the Source Path (\ref{surface.rendering}).

\pnum
The following rules shall apply when a Stroking operation is carried out on a path geometry:
\begin{enumerate}
\item No part of the \underlyingsurface that is outside of the Clip Area shall be modified.

\item If the path geometry only contains a degenerate path segment, then if the Line Cap value is either \tcode{line_cap::round} or \tcode{line_cap::square}, the line caps shall be rendered, resulting in a circle or a square, respectively. The remaining rules shall not apply.

\item If the path geometry is a closed path geometry, then the point where the end point of its final path segment meets the start point of the initial path segment shall be rendered as specified by the Line Join value; otherwise the start point of the initial path segment and end point of the final path segment shall each by rendered as specified by the Line Cap value. The remaining meetings between successive end points and start points shall be rendered as specified by the Line Join value.

\item If the Dash Pattern has its default value or if its \tcode{vector<double>} member is empty, the path segments shall be rendered as a continuous path.

\item If the Dash Pattern's \tcode{vector<double>} member contains only one value, that value shall be used to define a repeating pattern in which the path is shown then hidden. The ends of each shown portion of the path shall be rendered as specified by the Line Cap value.

\item If the Dash Pattern's \tcode{vector<double>} member contains two or more values, the values shall be used to define a pattern in which the path is alternatively rendered then not rendered for the length specified by the value. The ends of each rendered portion of the path shall be rendered as specified by the Line Cap value. If the Dash Pattern's \tcode{double} member, which specifies an offset value, is not \tcode{0.0}, the meaning of its value is \impldef{Dash Pattern!offset value}. If a rendered portion of the path overlaps a not rendered portion of the path, the rendered portion shall be rendered.
\end{enumerate}

\pnum
When a Stroking operation is carried out on a path geometry, the width of each rendered portion shall be the Line Width. Ideally this means that the diameter of the stroke at each rendered point should be equal to the Line Width. However, because there is an infinite number of points along each rendered portion, implementations may choose an \unspecnorm method of determining minimum distances between points along each rendered portion and the diameter of the stroke between those points shall be the same.
\enternote
This concept is sometimes referred to as a tolerance. It allows for a balance between precision and performance, especially in situations where the end result is in a non-exact format such as raster graphics data.
\exitnote

\pnum
After all path geometries have been rendered but before the rendered result is composed to the \underlyingsurface, the rendered result shall be transformed from the User Coordinate Space (\ref{surface.coordinatespaces}) to the Surface Coordinate Space (\ref{surface.coordinatespaces}).
\enterexample
If an open path geometry consisting solely of a vertical line from \tcode{vector_2d(20.0, 20.0)} to \tcode{vector_2d(20.0, 60.0)} is to be composed to the \underlyingsurface, the Line Cap is \tcode{line_cap::butt}, the Line Width is \tcode{12.0}, and the Transformation Matrix is \tcode{matrix_2d::init_scale(0.5, 1.0)}, then the line will end up being composed within the area \tcode{rectangle( \{ 7.0, 20.0 \}, \{ 13.0, 60.0 \} )} on the \underlyingsurface. The Transformation Matrix causes the center of the \xaxis of the line to move from \tcode{20.0} to \tcode{10.0} and then causes the horizontal width of the line to be reduced from \tcode{12.0} to \tcode{6.0}.
\exitexample

\rSec1 [surface.masking] {\tcode{surface} masking}

\pnum
The Masking operation uses a \term{Mask Brush} as described in \ref{surface.rendering}.

\pnum
When a Masking operation is initiated on a surface, the implementation shall produce results as if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the Clip Area (Table~\ref{tab:surface.state.listing}); if so, proceed with the remaining steps.
\item Transform $sp$ from the Surface Coordinate Space (\ref{surface.coordinatespaces}) to the Mask Coordinate Space (Table~\ref{tab:surface.pointtransforms.listing}), resulting in point $mp$.
\item Sample the alpha channel from point $mp$ of the Mask Brush and store the result in $mac$; if the visual data format of the Mask Brush does not have an alpha channel, the value of $mac$ shall always be $1.0$.
\item Transform $sp$ from the Surface Coordinate Space to the Brush Coordinate Space, resulting in point $bp$.
\item Sample from point $bp$ of the Source Brush (\ref{surface.sourcebrush}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current Composition Operator (Table~\ref{tab:surface.state.listing}), multiply each channel of the result produced by application of the Composition Operator by $map$ if the visual data format of the \underlyingsurface is a premultiplied format and if not then just multiply the alpha channel of the result by $map$, and modify the visual data of the \underlyingsurface at point $sp$ to reflect the multiplied result.
\end{enumerate}

\rSec1 [surface.typesetting] {\tcode{surface} typesetting}

\pnum
This section is forthcoming in a future revision.

\rSec1 [surface.cons] {\tcode{surface} constructors, assignment operators, and destructors}

\indexlibrary{\idxcode{surface}!destructor}
\begin{itemdecl}
virtual ~surface();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Destroys an object of class \tcode{surface}.
\end{itemdescr}

\rSec1 [surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{finish}}
\indexlibrary{\idxcode{finish}!\idxcode{surface}}
\begin{itemdecl}
virtual void finish() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Releases all resources managed by the \tcode{surface} object \tcode{s} if \tcode{!s.is_finished()}, otherwise does nothing.

\pnum
\postconditions
\tcode{s.is_finished()} shall return \tcode{true}.

\pnum
\remarks
Once this function has been called, the surface is \term{finished}. The only valid operations on a finished surface are destruction, calling \tcode{finish()}, and calling \tcode{is_finished()}. Except as otherwise noted, any other operation on a finished surface or any attempt to use a finished \tcode{surface} or \tcode{surface}-derived object as an argument to a function produces undefined behavior; no diagnostic is required.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{flush}}
\indexlibrary{\idxcode{flush}!\idxcode{surface}}
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
	\item Any pending rendering and composing operations (\ref{surface.rendering}) shall be performed on the \tcode{surface} object.
	\enternote
	As long as the observable effect is the same as if they were performed immediately, it does not matter whether they are executed, batched, or otherwise committed to the \underlyingrendandpresenttechs.
	\exitnote
	\item The implementation may then modify the \tcode{surface} object's observable state (\ref{surface.state}). 
	\item The \tcode{surface} object's observable state shall then be undefined.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists to allow the user to take control of the underlying surface using an implementation-provided native handle without introducing a race condition. The implementation's responsibility is to ensure that the user can safely use the underlying surface.

\pnum
\errors
The potential errors are \impldef{surface::flush errors}.

\pnum
Implementations should avoid producing errors here.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.

\pnum
\realnotes
Because the \tcode{surface} object's observable state can change as a result of calling this function, users will typically want to call \tcode{surface::save} before calling this function. When the user is done using the \tcode{surface} object's native handle, he or she must call \tcode{surface::mark_dirty} if changes were made to the \underlyingsurface using the native handle as per that function's semantics. Once that is done, or immediately after access using the native handle is finished if no changes were made, the user needs to then call \tcode{surface::restore} (assuming a previous, valid call to {surface::save}). Otherwise the user must set every item of observable state before using the \tcode{surface} object in any other way.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{device}}
\indexlibrary{\idxcode{device}!\idxcode{surface}}
\begin{itemdecl}
shared_ptr<experimental::io2d::device> device();
shared_ptr<experimental::io2d::device> device(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A shared pointer to the \tcode{device} object for this \tcode{surface}. If a \tcode{device} object does not already exist for this \tcode{surface}, a shared \tcode{device} object shall be allocated and returned.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if a \tcode{device} object needs to be created and not enough memory exists to do so.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mark_dirty}}
\indexlibrary{\idxcode{mark_dirty}!\idxcode{surface}}
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const rectangle& extents);
void mark_dirty(const rectangle& extents, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
	\item If called without a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the entire \underlyingsurface.
	\item If called with a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the \underlyingsurface within the bounds specified by the \term{bounding rectangle} \tcode{rectangle\{ round(extents.x()), round (extents.y()), round(extents.width()), round(extents.height())\}}. No part of the bounding rectangle shall be outside of the bounds of the \underlyingsurface; no diagnostic is required.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
After external changes are made to this \tcode{surface} object's \underlyingsurface using a native pointer, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
No call to this function shall be required solely as a result of changes made to a surface using the functionality provided by \tcode{surface::map}.
\enternote
The \tcode{mapped_surface} type, which is used by \tcode{surface::map}, provides its own functionality for managing any such changes.
\exitnote

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mark_dirty}.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{map}}
\indexlibrary{\idxcode{map}!\idxcode{surface}}
\begin{itemdecl}
void map(const function<void(mapped_surface&)>& action);
void map(const function<void(mapped_surface&, error_code&)>& action, error_code& ec);
void map(const function<void(mapped_surface&)>& action, const rectangle& extents);
void map(const function<void(mapped_surface&, error_code&)>& action,
  const rectangle& extents, error_code& ec);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Creates a \tcode{mapped_surface} object and calls \tcode{action} using it.

\pnum
The \tcode{mapped_surface} object is created using \tcode{*this}, which allows direct manipulation of the \underlyingsurface.

\pnum
If called with a \tcode{const rectangle\& extents} argument, the \tcode{mapped_surface} object shall only allow manipulation of the portion of \tcode{*this} specified by the \term{bounding rectangle} \tcode{rectangle\{ round(extents.x()), round(extents.y()), round(extents.width()), round(extents.height())\}}. If any part of the bounding rectangle is outside of the bounds of \tcode{*this}, the call shall result in undefined behavior; no diagnostic is required.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
Whether changes are committed to the \underlyingsurface immediately or only when the \tcode{mapped_surface} object is destroyed is \unspecnorm.

\pnum
Calling this function on a \tcode{surface} object and then calling any function on the \tcode{surface} object or using the \tcode{surface} object before the call to this function has returned shall result in undefined behavior; no diagnostic is required.

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!map} or are produced by the user-provided function passed via the \tcode{action} argument.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{save}}
\indexlibrary{\idxcode{save}!\idxcode{surface}}
\begin{itemdecl}
virtual void save();
virtual void save(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Saves the state specified in \ref{surface.state.save} as if to an internal stack of saved states.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if the state cannot be saved.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{restore}}
\indexlibrary{\idxcode{restore}!\idxcode{surface}}
\begin{itemdecl}
virtual void restore();
virtual void restore(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Restores the state of \tcode{*this} to the values saved by the most recent call to \tcode{surface::save}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\remarks
\pnum
Because this function is only restoring previously saved state, except where the conditions for \tcode{io2d_error::invalid_restore} are met, implementations should not generate errors.

\pnum
\errors
\tcode{io2d_error::invalid_restore} if this function is called without a previous matching call to \tcode{surface::save}. Implementations shall not produce \tcode{io2d_error::invalid_restore} except under the conditions stated in this paragraph.

\pnum
Excluding the previously specified error, any errors produced by calling this function are \impldef{surface!restore}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{brush}}
\indexlibrary{\idxcode{brush}!\idxcode{surface}}
\begin{itemdecl}
void brush(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Current Brush (Table~\ref{tab:surface.state.listing}) to be a \tcode{brush} object that is the same as if it was the brush that is the default value of Current Brush \ref{surface.state.default}.

\pnum
\enternote
This function does not require that the Current Brush be set to the same \tcode{brush} object that was the original default value Current Brush \tcode{brush} object. That said, because this function is \tcode{noexcept}, implementers can (and likely should) keep a reference to the original, default value Current Brush \tcode{brush} object and use it when this function is called. Allocating a new \tcode{brush} object may result in errors due to memory constraints or other considerations.
\exitnote
\end{itemdescr}

\begin{itemdecl}
void brush(const experimental::io2d::brush& source);
void brush(const experimental::io2d::brush& source,
  error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets \tcode{source} as the Current Brush (Table~\ref{tab:surface.state.listing}), ensuring that it shall not be destroyed and shall be recreated, if necessary, by the \underlyingrendandpresenttechs so that it shall be available for use at least until such time as it is no longer the Current Brush of any \tcode{surface} or \tcode{surface}-derived object.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!brush}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
void antialias(experimental::io2d::antialias a) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets General Antialiasing (Table~\ref{tab:surface.state.listing}) to the value of \tcode{a}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Dash Pattern (Table~\ref{tab:surface.state.listing}) to be the default value of Dash Pattern.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
void dashes(const experimental::io2d::dashes& d);
void dashes(const experimental::io2d::dashes& d, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Dash Pattern (Table~\ref{tab:surface.state.listing}) to the value of \tcode{d}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::not_enough_memory} if there is a problem caching the new Dash Pattern.

\pnum
\tcode{io2d_error::invalid_dash} if the new Dash Pattern contains a negative value or if it has values and all of them are \tcode{0.0}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
void fill_rule(experimental::io2d::fill_rule fr) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Fill Rule (Table~\ref{tab:surface.state.listing}) to the value of \tcode{fr}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
void line_cap(experimental::io2d::line_cap lc) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Cap (Table~\ref{tab:surface.state.listing}) to the value of \tcode{lc}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
void line_join(experimental::io2d::line_join lj) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Join (Table~\ref{tab:surface.state.listing}) to the value of \tcode{lj}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_width}}
\indexlibrary{\idxcode{line_width}!\idxcode{surface}}
\begin{itemdecl}
void line_width(double width) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Line Width (Table~\ref{tab:surface.state.listing}) to \tcode{max(width, 0.0)}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
void miter_limit(double limit) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Miter Limit (Table~\ref{tab:surface.state.listing}) to the value of \tcode{limit} clamped to be within the range defined by the \impldef{Miter Limit!minimum} minimum value and the \impldef{Miter Limit!maximum} maximum value, inclusive.

\pnum
\remarks
The \impdef minimum value shall not be greater than \tcode{2.0} and the \impdef maximum value shall not be less than \tcode{10.0}.

\pnum
\realnotes
The Miter Limit only applies when the Line Join is set to \tcode{line_join::miter}.
\exitnote

\pnum
\remarks
The Miter Limit works as follow. The length of the miter is divided by the width of the line. If the resulting value is greater than the Miter Limit, the join will be beveled, otherwise it will be mitered.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
void compositing_operator(experimental::io2d::compositing_operator co)
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Composition Operator to the value of \tcode{co}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip}}
\indexlibrary{\idxcode{clip}!\idxcode{surface}}
\begin{itemdecl}
void clip(const experimental::io2d::path& p);
void clip(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Clip Area (Table~\ref{tab:surface.state.listing}) to be the intersection of the Clip Area and \tcode{p} where \tcode{p}'s area is determined in the same way as if \tcode{p} were filled according to the Fill Rule.

\pnum
\realnotes
The Clip Area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_immediate}}
\indexlibrary{\idxcode{clip_immediate}!\idxcode{surface}}
\begin{itemdecl}
void clip_immediate();
void clip_immediate(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets the Clip Area (Table~\ref{tab:surface.state.listing}) to be the intersection of the Clip Area and the Immediate Path (Table~\ref{tab:surface.state.listing}) where the Immediate Path's area is determined in the same way as if the Immediate Path were filled according to the Fill Rule.

\pnum
\realnotes
The Clip Area never increases as a result of this function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{path}}
\indexlibrary{\idxcode{path}!\idxcode{surface}}
\begin{itemdecl}
void path(nullopt_t) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Set's the Current Path (Table~\ref{tab:surface.state.listing}).

	\pnum
	\realnotes
	The empty \tcode{path} object is not supplied by the user. The implementation is expected to provide an empty \tcode{path} object. Since a \tcode{path} object is immutable, an implementation should create an empty path object in advance for maximum efficiency.
\end{itemdescr}

\begin{itemdecl}
void path(const experimental::io2d::path& p);
void path(const experimental::io2d::path& p, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Set's Current Path (Table~\ref{tab:surface.state.listing}) to \tcode{p}.

\pnum
\remarks
Processing the path data so that it is properly transformed can be done at the time it is first set as a path on a \tcode{surface} object or any time before that. The untransformed \tcode{vector<path_data_item>} shall be retained to ensure that a path can be properly recreated at any time. The steps for converting an untransformed \tcode{vector<path_data_item>} to transformed path data are found at \ref{paths.processing}.
\end{itemdescr}

\rSec1 [surface.modifiers.immediatepath] {\tcode{surface} immediate path modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{immediate}}
\indexlibrary{\idxcode{immediate}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::path_factory& immediate() noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A reference to the Immediate Path (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\rSec1 [surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{fill}}
\indexlibrary{\idxcode{fill}!\idxcode{surface}}
\begin{itemdecl}
void fill();
void fill(error_code& ec) noexcept;
void fill(const rgba_color& c);
void fill(const rgba_color& c, error_code& ec) noexcept;
void fill(const experimental::io2d::brush& b);
void fill(const experimental::io2d::brush& b, error_code& ec) noexcept;
void fill(const surface& s, const matrix_2d& m = matrix_2d::init_identity(), 
  extend e = extend::none, filter f = filter::good);
void fill(const surface& s, error_code& ec,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Filling rendering and composing operation as specified by \ref{surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_immediate}}
\indexlibrary{\idxcode{fill_immediate}!\idxcode{surface}}
\begin{itemdecl}
void fill_immediate();
void fill_immediate(error_code& ec) noexcept;
void fill_immediate(const rgba_color& c);
void fill_immediate(const rgba_color& c, error_code& ec) noexcept;
void fill_immediate(const experimental::io2d::brush& b);
void fill_immediate(const experimental::io2d::brush& b, error_code& ec)
  noexcept;
void fill_immediate(const surface& s, 
  const matrix_2d& m = matrix_2d::init_identity(),
  extend e = extend::none, filter f = filter::good);
void fill_immediate(const surface& s, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(),
  extend e = extend::none, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Filling rendering and composing operation as specified by \ref{surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!fill_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{paint}}
\indexlibrary{\idxcode{paint}!\idxcode{surface}}
\begin{itemdecl}
void paint();
void paint(error_code& ec) noexcept;
void paint(const rgba_color& c);
void paint(const rgba_color& c, error_code& ec) noexcept;
void paint(const experimental::io2d::brush& b);
void paint(const experimental::io2d::brush& b, error_code& ec) noexcept;
void paint(const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good);
void paint(const surface& s, error_code& ec,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good) noexcept;
void paint(double alpha);
void paint(double alpha, error_code& ec) noexcept;
void paint(const rgba_color& c, double alpha);
void paint(const rgba_color& c, double alpha, error_code& ec) noexcept;
void paint(const experimental::io2d::brush& b, double alpha);
void paint(const experimental::io2d::brush& b, double alpha,
  error_code& ec) noexcept;
void paint(const surface& s, double alpha,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good);
void paint(const surface& s, double alpha, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Painting rendering and composing operation as specified by \ref{surface.painting}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!paint}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke}}
\indexlibrary{\idxcode{stroke}!\idxcode{surface}}
\begin{itemdecl}
void stroke();
void stroke(error_code& ec) noexcept;
void stroke(const rgba_color& c);
void stroke(const rgba_color& c, error_code& ec) noexcept;
void stroke(const experimental::io2d::brush& b);
void stroke(const experimental::io2d::brush& b, error_code& ec) noexcept;
void stroke(const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good);
void stroke(const surface& s, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Stroking rendering and composing operation as specified by \ref{surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_immediate}}
\indexlibrary{\idxcode{stroke_immediate}!\idxcode{surface}}
\begin{itemdecl}
void stroke_immediate();
void stroke_immediate(error_code& ec) noexcept;
void stroke_immediate(const rgba_color& c);
void stroke_immediate(const rgba_color& c, error_code& ec) noexcept;
void stroke_immediate(const experimental::io2d::brush& b);
void stroke_immediate(const experimental::io2d::brush& b, error_code& ec)
  noexcept;
void stroke_immediate(const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good);
void stroke_immediate(const surface& s, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Stroking rendering and composing operation as specified by \ref{surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!stroke_immediate}.
\end{itemdescr}

\rSec1 [surface.modifiers.maskrender] {\tcode{surface} mask render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{mask}}
\indexlibrary{\idxcode{mask}!\idxcode{surface}}
\begin{itemdecl}
void mask(const experimental::io2d::brush& mb);
void mask(const experimental::io2d::brush& mb, error_code& ec)
  noexcept;
void mask(const experimental::io2d::brush& mb, const rgba_color& c);
void mask(const experimental::io2d::brush& mb, const rgba_color& c, 
  error_code& ec) noexcept;
void mask(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b);
void mask(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask(const experimental::io2d::brush& mb, const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good);
void mask(const experimental::io2d::brush& mb, const surface& s, error_code& ec,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good) noexcept;
void mask(surface& ms,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask(surface& ms, error_code& ec, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask(surface& ms, const rgba_color& c,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask(surface& ms, const rgba_color& c, error_code& ec, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask(surface& ms, const experimental::io2d::brush& b, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask(surface& ms, const experimental::io2d::brush& b, error_code& ec,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask(surface& ms, const surface& s,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  const matrix_2d& m = matrix_2d::init_identity(),
  extend msExtend = extend::none, extend e = extend::none,
  filter msFilter = filter::good, filter f = filter::good);
void mask(surface& ms, const surface& s, error_code& ec,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  const matrix_2d& m = matrix_2d::init_identity(),
  extend msExtend = extend::none, extend e = extend::none,
  filter msFilter = filter::good, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Masking rendering and composing operation as specified by \ref{surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mask}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{mask_immediate}}
\indexlibrary{\idxcode{mask_immediate}!\idxcode{surface}}
\begin{itemdecl}
void mask_immediate(const experimental::io2d::brush& mb);
  void mask_immediate(const experimental::io2d::brush& mb, 
  error_code& ec) noexcept;
void mask_immediate(const experimental::io2d::brush& mb,
  const rgba_color& c);
void mask_immediate(const experimental::io2d::brush& mb,
  const rgba_color& c, error_code& ec) noexcept;
void mask_immediate(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b);
void mask_immediate(const experimental::io2d::brush& mb,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void mask_immediate(const experimental::io2d::brush& mb, const surface& s, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good);
void mask_immediate(const experimental::io2d::brush& mb, const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), error_code& ec,
  extend e = extend::none, filter f = filter::good) noexcept;
void mask_immediate(surface& ms,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask_immediate(surface& ms, error_code& ec, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask_immediate(surface& ms, const rgba_color& c, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask_immediate(surface& ms, const rgba_color& c, error_code& ec, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask_immediate(surface& ms, const experimental::io2d::brush& b, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good);
void mask_immediate(surface& ms, const experimental::io2d::brush& b,
  error_code& ec, const matrix_2d& msMatrix = matrix_2d::init_identity(),
  extend msExtend = extend::none, filter msFilter = filter::good) noexcept;
void mask_immediate(surface& ms, const surface& s, 
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  const matrix_2d& m = matrix_2d::init_identity(),
  extend msExtend = extend::none, extend e = extend::none,
  filter msFilter = filter::good, filter f = filter::good);
void mask_immediate(surface& ms, const surface& s, error_code& ec,
  const matrix_2d& msMatrix = matrix_2d::init_identity(),
  const matrix_2d& m = matrix_2d::init_identity(),
  extend msExtend = extend::none, extend e = extend::none,
  filter msFilter = filter::good, filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Masking rendering and composing operation as specified by \ref{surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!mask_immediate}.
\end{itemdescr}

\rSec1 [surface.modifiers.textrender] {\tcode{surface} text render modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{render_text}}
\indexlibrary{\idxcode{render_text}!\idxcode{surface}}
\begin{itemdecl}
vector_2d render_text(const string& utf8, const vector_2d& pos);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const rgba_color& c);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const rgba_color& c, error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const experimental::io2d::brush& b);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, const matrix_2d& m = matrix_2d::init_identity(), 
  extend e = extend::none, filter f = filter::good);
vector_2d render_text(const string& utf8, const vector_2d& pos,
  const surface& s, error_code& ec,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good) noexcept;
void render_glyph_run(const glyph_run& gr);
void render_glyph_run(const glyph_run& gr, error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr, const rgba_color& c);
void render_glyph_run(const glyph_run& gr, const rgba_color& c,
  error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr,
  const experimental::io2d::brush& b);
void render_glyph_run(const glyph_run& gr,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr, const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good);
void render_glyph_run(const glyph_run& gr, const surface& s, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Typesetting rendering and composing operation as specified by \ref{surface.typesetting}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\returns
A \tcode{vector_2d} object that provides the origin point for the next character of text that would have been drawn  if \tcode{utf8} had possessed an additional character of text.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!render_text}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{render_glyph_run}}
\indexlibrary{\idxcode{render_text_run}!\idxcode{surface}}
\begin{itemdecl}
void render_glyph_run(const glyph_run& gr);
void render_glyph_run(const glyph_run& gr, error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr, const rgba_color& c);
void render_glyph_run(const glyph_run& gr, const rgba_color& c,
  error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr,
  const experimental::io2d::brush& b);
void render_glyph_run(const glyph_run& gr,
  const experimental::io2d::brush& b, error_code& ec) noexcept;
void render_glyph_run(const glyph_run& gr, const surface& s,
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none,
  filter f = filter::good);
void render_glyph_run(const glyph_run& gr, const surface& s, error_code& ec, 
  const matrix_2d& m = matrix_2d::init_identity(), extend e = extend::none, 
  filter f = filter::good) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the Typesetting rendering and composing operation as specified by \ref{surface.typesetting}.

\pnum
The meanings of the parameters are specified by \ref{surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!render_glyph_run}.
\end{itemdescr}

\rSec1 [surface.modifiers.transform] {\tcode{surface} transformation modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{surface}}
\begin{itemdecl}
void matrix(const matrix_2d& m);
void matrix(const matrix_2d& m, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Sets Transformation Matrix (Table~\ref{tab:surface.state.listing}) to the value of \tcode{m}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{io2d_error::invalid_matrix} if calling \tcode{!m.is_invertible()}.
\end{itemdescr}


\rSec1 [surface.modifiers.font] {\tcode{surface} font modifiers}

\indexlibrary{\idxcode{surface}!\idxcode{font_resource}}
\indexlibrary{\idxcode{font_resource}!\idxcode{surface}}
\begin{itemdecl}
void font_resource(const experimental::io2d::font_resource& f) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
***FIXME*** Sets Font Face (Table~\ref{tab:surface.state.listing}) to \tcode{f}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_resource}}
\indexlibrary{\idxcode{font_resource}!\idxcode{surface}}
\begin{itemdecl}
void font_resource(const ::std::string& family, double size,
  font_slant sl = font_slant::normal, font_weight w = font_weight::normal);
void font_resource(const ::std::string& family, double size, error_code& ec,
  font_slant sl = font_slant::normal,
  font_weight w = font_weight::normal) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
***FIXME***Sets Font Face (Table~\ref{tab:surface.state.listing}) to the result of constructing a \tcode{simple_font_face} object using the arguments to this function.

\pnum
If an error occurs in constructing the \tcode{simple_font_face} object, Font Face shall retain the value it had prior to the execution of this function and that error shall be propagated back.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{surface!font_resource}.
\end{itemdescr}

\rSec1 [surface.observers.state] {\tcode{surface} state observers}

\indexlibrary{\idxcode{surface}!\idxcode{is_finished}}
\indexlibrary{\idxcode{is_finished}!\idxcode{surface}}
\begin{itemdecl}
bool is_finished() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If a call to \tcode{surface::finished} has previously been made, returns \tcode{true}; otherwise returns \tcode{false}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{content}}
\indexlibrary{\idxcode{content}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::content content() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The \tcode{content} enumerator (\ref{content.enumerators}) that appropriately describes the \underlyingsurface.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{brush}}
\indexlibrary{\idxcode{brush}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::brush brush() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Current Brush (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{antialias}}
\indexlibrary{\idxcode{antialias}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::antialias antialias() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of General Antialiasing (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{dashes}}
\indexlibrary{\idxcode{dashes}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::dashes dashes() const;
experimental::io2d::dashes dashes(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Dash Pattern (Table~\ref{tab:surface.state.listing}).

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
See \ref{surface.stroking} for more information about the \tcode{dashes} type.

\pnum
\errors
\tcode{errc::not_enough_memory} if there was a failure to allocate memory.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_rule}}
\indexlibrary{\idxcode{fill_rule}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::fill_rule fill_rule() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Fill Rule (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_cap}}
\indexlibrary{\idxcode{line_cap}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::line_cap line_cap() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Cap (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_join}}
\indexlibrary{\idxcode{line_join}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::line_join line_join() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Join (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{line_width}}
\indexlibrary{\idxcode{line_width}!\idxcode{surface}}
\begin{itemdecl}
double line_width() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Line Width (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{miter_limit}}
\indexlibrary{\idxcode{miter_limit}!\idxcode{surface}}
\begin{itemdecl}
double miter_limit() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Miter Limit (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{compositing_operator}}
\indexlibrary{\idxcode{compositing_operator}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::compositing_operator compositing_operator() const
  noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The value of Composition Operator (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_extents}}
\indexlibrary{\idxcode{clip_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle clip_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains the Clip Area (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_clip}}
\indexlibrary{\idxcode{in_clip}!\idxcode{surface}}
\begin{itemdecl}
bool in_clip(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is outside of the Clip Area (Table~\ref{tab:surface.state.listing}), returns \tcode{false}; otherwise returns \tcode{true}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{clip_rectangles}}
\indexlibrary{\idxcode{clip_rectangles}!\idxcode{surface}}
\begin{itemdecl}
vector<rectangle> clip_rectangles() const;
vector<rectangle> clip_rectangles(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{vector<rectangle>} object which contains the rectangles which make up the Clip Area (Table~\ref{tab:surface.state.listing}).

\pnum
If an \tcode{error_code\&} argument is passed and the error \tcode{io2d_error::clip_not_representable} occurs, returns an empty \tcode{vector<rectangle>} object.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{io2d_error::clip_not_representable} if the Clip Area contains one or more areas that cannot be represented using rectangles.
\enterexample
This error would occur if the Clip Area contains arcs or curves.
\exitexample

\pnum
\tcode{errc::not enough memory} if a failure to allocate memory occurs.
\end{itemdescr}

\rSec1 [surface.observers.render] {\tcode{surface} render observers}

\indexlibrary{\idxcode{surface}!\idxcode{fill_extents}}
\indexlibrary{\idxcode{fill_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle fill_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::fill} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{fill_extents_immediate}}
\indexlibrary{\idxcode{fill_extents_immediate}!\idxcode{surface}}
\begin{itemdecl}
rectangle fill_extents_immediate() const;
rectangle fill_extents_immediate(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{paths.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!fill_extents_immediate}.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::fill_immediate} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_fill}}
\indexlibrary{\idxcode{in_fill}!\idxcode{surface}}
\begin{itemdecl}
bool in_fill(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Filling operation areas.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::fill} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, the Clip Area, and the Transformation Matrix and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_fill_immediate}}
\indexlibrary{\idxcode{in_fill_immediate}!\idxcode{surface}}
\begin{itemdecl}
bool in_fill_immediate(const vector_2d& pt) const;
bool in_fill_immediate(const vector_2d& pt, error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Filling operation (\ref{surface.filling}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}) and the value of Fill Rule, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Transformation Matrix, Clip Area, and the bound of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Filling operation areas.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{paths.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!in_fill_immediate}.

\pnum
\realnotes
The result does not mean that the point \tcode{pt} would be changed if \tcode{surface::fill} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, the Clip Area, and the Transformation Matrix and thus could contain areas that would not actually be affected by a call to \tcode{surface::fill}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_extents}}
\indexlibrary{\idxcode{stroke_extents}!\idxcode{surface}}
\begin{itemdecl}
rectangle stroke_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::stroke} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{stroke_extents_immediate}}
\indexlibrary{\idxcode{stroke_extents_immediate}!\idxcode{surface}}
\begin{itemdecl}
rectangle stroke_extents_immediate() const;
rectangle stroke_extents_immediate(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{rectangle} that specifies the smallest bounding box which contains all areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern. The Clip Area and the bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. When the final values for the return value are calculated, they shall be transformed using \tcode{surface::surface_to_user} and the \tcode{rectangle} that is returned shall be composed of those transformed values.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{paths.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!stroke_extents_immediate}.

\pnum
\realnotes
The resulting bounding box is not the same as the area that would be changed if \tcode{surface::stroke_immediate} was called since it is calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_stroke}}
\indexlibrary{\idxcode{in_stroke}!\idxcode{surface}}
\begin{itemdecl}
bool in_stroke(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Current Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the coordinates of the Current Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Stroking operation areas.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::stroke} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{in_stroke_immediate}}
\indexlibrary{\idxcode{in_stroke_immediate}!\idxcode{surface}}
\begin{itemdecl}
bool in_stroke_immediate(const vector_2d& pt) const;
bool in_stroke_immediate(const vector_2d& pt, error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
If the point \tcode{pt} is not within any of the areas in which a Stroking operation (\ref{surface.stroking}) can have an effect using the Immediate Path (Table~\ref{tab:surface.state.listing}), the Line Cap, the Line Join, the Line Width, the Miter Limit, and the Dash Pattern, this function returns \tcode{false}; otherwise it returns \tcode{true}. The Clip Area and bounds of the \underlyingsurface shall be disregarded for purposes of calculating the return value.

\pnum
For purposes of calculating the return value, the processed coordinates of the Immediate Path shall be transformed using \tcode{surface::user_to_surface} before any other calculations are performed. The value of \tcode{pt} shall also be transformed using \tcode{surface::user_to_surface} prior to determining whether or not it is within any of the Stroking operation areas.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function requires that the Immediate Path be processed into a usable form as if in the manner specified in \ref{paths.processing}.

\pnum
\errors
\tcode{io2d_error::no_current_point} if, when processing the Immediate Path's path geometries, an operation was encountered which required a current point and the current path geometry had no current point.

\pnum
\tcode{io2d_error::invalid_matrix} if, when processing the Immediate Path's path geometries, an operation was encountered which required the current transformation matrix to be invertible and the matrix was not invertible.

\pnum
Other errors, if any, produced by this function are \impldef{surface!in_stroke_immediate}.

\pnum
\realnotes
The result does not mean that the content at the point \tcode{pt} would be changed if \tcode{surface::stroke_immediate} was called since the areas are calculated without regard to the Current Brush, the Composition Operator, and the Clip Area and thus could contain areas that would not actually be affected by a call to \tcode{surface::stroke_immediate}.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{font_extents}}
\indexlibrary{\idxcode{font_extents}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::font_extents font_extents() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{font_extents} object which specifies metrics for Font Face (Table~\ref{tab:surface.state.listing}). See the specification of the \tcode{font_extents} class (\ref{fontextents}) for more information.

\pnum
The Transformation Matrix is disregarded for purposes of calculating the metrics.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{text_extents}}
\indexlibrary{\idxcode{text_extents}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::text_extents text_extents(const string& utf8) const;
experimental::io2d::text_extents text_extents(const string& utf8,
  error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A \tcode{text_extents} object which specifies metrics for \tcode{utf8} if it was rendered using Font Face (Table~\ref{tab:surface.state.listing}). See the specification of the \tcode{text_extents} class (\ref{textextents}) for more information.

\pnum
The Transformation Matrix is disregarded for purposes of calculating the metrics.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
\tcode{errc::invalid_argument} if \tcode{utf8} is not a valid UTF-8 string.

\pnum
Other errors, if any, produced by this function are \impldef{surface!text_extents}.
\end{itemdescr}

\rSec1 [surface.observers.transform] {\tcode{surface} transformation observers}

\indexlibrary{\idxcode{surface}!\idxcode{matrix}}
\indexlibrary{\idxcode{matrix}!\idxcode{surface}}
\begin{itemdecl}
matrix_2d matrix() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The Transformation Matrix (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{user_to_surface}}
\indexlibrary{\idxcode{user_to_surface}!\idxcode{surface}}
\begin{itemdecl}
vector_2d user_to_surface(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of calling \tcode{matrix_2d::transform_point} on Transformation Matrix (Table~\ref{tab:surface.state.listing}) with \tcode{pt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{user_to_surface_distance}}
\indexlibrary{\idxcode{user_to_surface_distance}!\idxcode{surface}}
\begin{itemdecl}
vector_2d user_to_surface_distance(const vector_2d& dpt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of calling \tcode{matrix_2d::transform_distance} on Transformation Matrix (Table~\ref{tab:surface.state.listing}) with \tcode{dpt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{surface_to_user}}
\indexlibrary{\idxcode{surface_to_user}!\idxcode{surface}}
\begin{itemdecl}
vector_2d surface_to_user(const vector_2d& pt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of creating a copy of Transformation Matrix (Table~\ref{tab:surface.state.listing}), calling \tcode{matrix_2d::invert} on that copy, and then calling \tcode{matrix_2d::transform_point} on the copy with \tcode{pt} as the argument to that function.
\end{itemdescr}

\indexlibrary{\idxcode{surface}!\idxcode{surface_to_user_distance}}
\indexlibrary{\idxcode{surface_to_user_distance}!\idxcode{surface}}
\begin{itemdecl}
vector_2d surface_to_user_distance(const vector_2d& dpt) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The result of creating a copy of Transformation Matrix (Table~\ref{tab:surface.state.listing}), calling \tcode{matrix_2d::invert} on that copy, and then calling \tcode{matrix_2d::transform_distance} on the copy with \tcode{dpt} as the argument to that function.
\end{itemdescr}

\rSec1 [surface.observers.font] {\tcode{surface} font observers}

\indexlibrary{\idxcode{surface}!\idxcode{font_resource}}
\indexlibrary{\idxcode{font_resource}!\idxcode{surface}}
\begin{itemdecl}
experimental::io2d::font_resource font_resource() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
***FIXME*** The Font Matrix (Table~\ref{tab:surface.state.listing}).
\end{itemdescr}
