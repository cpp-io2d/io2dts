%!TEX root = io2d.tex
\rSec0 [\iotwod.surface] {Class \tcode{surface}}

\rSec1 [\iotwod.surface.intro] {\tcode{surface} description}

\pnum
\indexlibrary{\idxcode{surface}}%
The \tcode{surface} class provides an interface for managing a graphics
data graphics resource.

\pnum
A \tcode{surface} object is a move-only object.

\pnum
The \tcode{surface} class modifies its graphics resource through rendering and composing operations.

\pnum
\begin{note}
While a \tcode{surface} object manages a graphics data graphics resource, the \tcode{surface} class does not provide well-defined semantics for the graphics resource. The \tcode{surface} class is intended to serve only as a base class and as such is not directly instantiable.
\end{note}

\pnum
Directly instantiable types which derive, directly or indirectly, from the \tcode{surface} class shall either provide well-defined semantics for the graphics data graphics resource or inherit well-defined semantics for the graphics data graphics resource from a base class.

\pnum
\begin{example}
The \tcode{image_surface} class and the \tcode{display_surface} class each specify that they manage a raster graphics data graphics resource and that the members they inherit from the \tcode{surface} class shall use that raster graphics data graphics resource as their graphics data graphics resource. Since, unlike graphics data, raster graphics data provides well-defined semantics, these classes meet the requirements for being directly instantiable.
\end{example}

\pnum
The definitions of the rendering and composing operations in \ref{\iotwod.surface.rendering} shall only be applicable when the graphics data graphics resource on which the \tcode{surface} members operate is a raster graphics data graphics resource. In all other cases, any attempt to invoke the rendering and composing operations shall result in undefined behavior.

\rSec1 [\iotwod.surface.synopsis] {\tcode{surface} synopsis}

\begin{codeblock}
namespace std::experimental::io2d::v1 {
  class surface {
  public:
    surface() = delete;
    
    // \ref{\iotwod.surface.modifiers.state}, state modifiers:
    void flush();
    void flush(error_code& ec) noexcept;
    void mark_dirty();
    void mark_dirty(error_code& ec) noexcept;
    void mark_dirty(const bounding_box& extents);
    void mark_dirty(const bounding_box& extents, error_code& ec) noexcept;

    // \ref{\iotwod.surface.modifiers.render}, render modifiers:
    void paint(const brush& b, const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void stroke(const brush& b, const path_builder<Allocator>& pb,
      const optional<brush_props>& bp = nullopt,
      const optional<stroke_props>& sp = nullopt,
      const optional<dashes>& d = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void stroke(const brush& b, const interpreted_path& pg,
      const optional<brush_props>& bp = nullopt,
      const optional<stroke_props>& sp = nullopt,
      const optional<dashes>& d = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void fill(const brush& b, const path_builder<Allocator>& pb,
      const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void fill(const brush& b, const interpreted_path& pg,
      const optional<brush_props>& bp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    template <class Allocator>
    void mask(const brush& b, const brush& mb,
      const optional<brush_props>& bp = nullopt,
      const optional<mask_props>& mp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
    void mask(const brush& b, const brush& mb,
      const optional<brush_props>& bp = nullopt,
      const optional<mask_props>& mp = nullopt,
      const optional<render_props>& rp = nullopt,
      const optional<clip_props>& cl = nullopt);
  };
}
\end{codeblock}

\rSec1 [\iotwod.surface.rendering] {Rendering and composing}

\rSec2 [\iotwod.surface.rendering.ops] {Operations}

\pnum
The \tcode{surface} class provides four fundamental rendering and composing operations:
\begin{libreqtab2}
 {\tcode{surface} rendering and composing operations}
 {tab:\iotwod.surface.rendering.operations}
 \\ \topline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{Operation}
 & \rhdr{Function(s)}
 \\ \capsep
 \endhead
 Painting
 & \tcode{surface::paint}
 \\
 Filling
 & \tcode{surface::fill}
 \\
 Stroking
 & \tcode{surface::stroke}
 \\
 Masking
 & \tcode{surface::mask}
 \\
\end{libreqtab2}

\pnum
All composing operations shall happen in a linear color space, regardless of the color space of the graphics data that is involved.

\pnum
\begin{note}
While a color space such as sRGB helps produce expected, consistent results when graphics data are viewed by people, composing operations only produce expected results when the channel data in the graphics data involved are uniformly (i.e. linearly) spaced. 
\end{note}

\rSec2 [\iotwod.surface.rendering.brushes] {Rendering and composing brushes}

\pnum
All rendering and composing operations use a \term{source brush} of type \tcode{brush}.

\pnum
The masking operation uses a \term{mask brush} of type \tcode{brush}.

\rSec2 [\iotwod.surface.rendering.sourcepath] {Rendering and composing source path}

\pnum
In addition to brushes (\ref{\iotwod.surface.rendering.brushes}), all rendering and composing operation except for painting and masking use a \term{source path}. The source path is either a \tcode{path_builder<Allocator>} object or an \tcode{interpreted_path} object. If it is a \tcode{path_builder<Allocator>} object, it is interpreted (\ref{\iotwod.paths.interpretation}) before it is used as the source path.

\rSec2 [\iotwod.surface.rendering.commonstate] {Common state data}

\pnum
All rendering and composing operations use the following state data:

\begin{libreqtab2}
 {\tcode{surface} rendering and composing common state data}
 {tab:\iotwod.surface.rendering.commonstate.listing}
 \\ \topline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Brush properties
 & \tcode{brush_props}
 \\
 Surface properties
 & \tcode{render_props}
 \\
 Clip properties
 & \tcode{clip_props}
 \\
\end{libreqtab2}

\rSec2 [\iotwod.surface.rendering.specificstate] {Specific state data}

\pnum
In addition to the common state data (\ref{\iotwod.surface.rendering.commonstate}), certain rendering and composing operations use state data that is specific to each of them:

\begin{libiotwodtab3e}
 {\tcode{surface} rendering and composing specific state data}
 {tab:\iotwod.surface.rendering.specificstate.listing}
 \\ \topline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endfirsthead
 \hline
 \lhdr{Operation}
 & \chdr{Name}
 & \rhdr{Type}
 \\ \capsep
 \endhead
 Stroking
 & Stroke properties
 & \tcode{stroke_props}
 \\
 Stroking
 & Dashes
 & \tcode{dashes}
 \\
 Masking
 & Mask properties
 & \tcode{mask_props}
 \\
\end{libiotwodtab3e}

\rSec2 [\iotwod.surface.rendering.statedefaults] {State data default values}

\pnum
For all rendering and composing operations, the state data objects named above are provided using \tcode{optional<T>} class template arguments.

\pnum
If there is no contained value for a state data object, it is interpreted as-if the \tcode{optional<T>} argument contained a default constructed object of the relevant state data object.

\rSec1 [\iotwod.surface.coordinatespaces] {Standard coordinate spaces}

\pnum
There are four standard coordinate spaces relevant to the rendering and composing operations (\ref{\iotwod.surface.rendering}):
\begin{itemize}
\item the brush coordinate space;
\item the mask coordinate space;
\item the user coordinate space; and
\item the surface coordinate space.
\end{itemize}

\pnum
The \term{brush coordinate space} is the standard coordinate space of the source brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the brush properties' brush matrix (\ref{\iotwod.brushprops.summary}).

\pnum
The \term{mask coordinate space} is the standard coordinate space of the mask brush (\ref{\iotwod.surface.rendering.brushes}). Its transformation matrix is the mask properties' mask matrix (\ref{\iotwod.maskprops.summary}).

\pnum
The \term{user coordinate space} is the standard coordinate space of \tcode{interpreted_path} objects. Its transformation matrix is a default-constructed \tcode{matrix_2d}.

\pnum
The \term{surface coordinate space} is the standard coordinate space of the \tcode{surface} object's \underlyingsurface. Its transformation matrix is the surface properties' surface matrix (\ref{\iotwod.renderprops.summary}).

\pnum
Given a point \tcode{pt}, a brush coordinate space transformation matrix \tcode{bcsm}, a mask coordinate space transformation matrix \tcode{mcsm}, a user coordinate space transformation matrix \tcode{ucsm}, and a surface coordinate space transformation matrix \tcode{scsm}, the following table describes how to transform it from each of these standard coordinate spaces to the other standard coordinate spaces:

\begin{libiotwodreqtab3}
 {Point transformations}
 {tab:\iotwod.surface.pointtransforms.listing}
 \\ \topline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endfirsthead
 \continuedcaption\\
 \hline
 \lhdr{From}
 & \chdr{To}
 & \rhdr{Transform}
 \\ \capsep
 \endhead
 brush coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(bcsm.invert().transform_pt(pt))}.
 \\
 brush coordinate space
 & user coordinate space
 & \tcode{bcsm.invert().transform_pt(pt)}.
 \\
 brush coordinate space
 & surface coordinate space
 & \tcode{scsm.transform_pt(bcsm.invert().transform_pt(pt))}.
 \\
 user coordinate space
 & brush coordinate space
 & \tcode{bcsm.transform_pt(pt)}.
 \\
 user coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(pt)}.
 \\
 user coordinate space
 & surface coordinate space
 & \tcode{scsm.transform_pt(pt)}.
 \\
 surface coordinate space
 & brush coordinate space
 & \tcode{bcsm.transform_pt(scsm.invert().transform_pt(pt))}.
 \\
 surface coordinate space
 & mask coordinate space
 & \tcode{mcsm.transform_pt(scsm.invert().transform_pt(pt))}.
 \\
 surface coordinate space
 & user coordinate space
 & \tcode{scsm.invert().transform_pt(pt)}.
 \\
\end{libiotwodreqtab3}

\rSec1 [\iotwod.surface.painting] {\tcode{surface} painting}

\pnum
When a painting operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the clip area (\tcode{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the brush coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current \term{compositing operator} (\ref{\iotwod.renderprops.summary}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the compositing operator.
\end{enumerate}

\rSec1 [\iotwod.surface.filling] {\tcode{surface} filling}

\pnum
When a filling operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the \term{clip area} (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the user coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $up$.
\item Using the source path (\ref{\iotwod.surface.rendering.sourcepath}) and the fill rule (\ref{\iotwod.brushprops.summary}), determine whether $up$ shall be filled; if so, proceed with the remaining steps.
\item Transform $up$ from the user coordinate space to the brush coordinate space (\ref{\iotwod.surface.coordinatespaces} and Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current compositing operator (\ref{\iotwod.renderprops.summary}), and modify the visual data of the \underlyingsurface at point $sp$ to reflect the result produced by application of the compositing operator.
\end{enumerate}

\rSec1 [\iotwod.surface.stroking] {\tcode{surface} stroking}

\pnum
When a stroking operation is initiated on a surface, it is carried out for each figure in the source path (\ref{\iotwod.surface.rendering}).

\pnum
The following rules shall apply when a stroking operation is carried out on a figure:
\begin{enumerate}
\item No part of the \underlyingsurface that is outside of the clip area shall be modified.

\item If the figure only contains a degenerate segment, then if the \term{line cap} value (see: \ref{\iotwod.strokeprops.summary} and \ref{\iotwod.surface.rendering.specificstate}) is either \tcode{line_cap::round} or \tcode{line_cap::square}, the line caps shall be rendered, resulting in a circle or a square, respectively. The remaining rules shall not apply.

\item If the figure is a closed figure, then the point where the end point of its final segment meets the start point of the initial segment shall be rendered as specified by the \term{line join} value (see: \ref{\iotwod.strokeprops.summary} and \ref{\iotwod.surface.rendering.specificstate}); otherwise the start point of the initial segment and end point of the final segment shall each by rendered as specified by the line cap value. The remaining meetings between successive end points and start points shall be rendered as specified by the line join value.

\item If the dash pattern (Table~\ref{tab:\iotwod.surface.rendering.specificstate.listing}) has its default value or if its \tcode{vector<float>} member is empty, the segments shall be rendered as a continuous path.

\item If the dash pattern's \tcode{vector<float>} member contains only one value, that value shall be used to define a repeating pattern in which the path is shown then hidden. The ends of each shown portion of the path shall be rendered as specified by the line cap value.

\item If the dash pattern's \tcode{vector<float>} member contains two or more values, the values shall be used to define a pattern in which the figure is alternatively rendered then not rendered for the length specified by the value. The ends of each rendered portion of the figure shall be rendered as specified by the line cap value. If the dash pattern's \tcode{float} member, which specifies an offset value, is not \tcode{0.0f}, the meaning of its value is \impldefplain{dash pattern!offset value}. If a rendered portion of the figure overlaps a not rendered portion of the figure, the rendered portion shall be rendered.
\end{enumerate}

\pnum
When a stroking operation is carried out on a figure, the width of each rendered portion shall be the \term{line width} (see: \ref{\iotwod.strokeprops.summary} and \ref{\iotwod.surface.rendering.specificstate}). Ideally this means that the diameter of the stroke at each rendered point should be equal to the line width. However, because there are an infinite number of points along each rendered portion, implementations may choose an \unspecnorm method of determining minimum distances between points along each rendered portion and the diameter of the stroke between those points shall be the same.
\begin{note}
This concept is sometimes referred to as a tolerance. It allows for a balance between precision and performance, especially in situations where the end result is in a non-exact format such as raster graphics data.
\end{note}

\pnum
After all figures in the path have been rendered but before the rendered result is composed to the \underlyingsurface, the rendered result shall be transformed from the user coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}).

\rSec1 [\iotwod.surface.masking] {\tcode{surface} masking}

\pnum
A \term{mask brush} is composed of a graphics data graphics resource, a \tcode{wrap_mode} value, a \tcode{filter} value, and a \tcode{matrix_2d} object.

\pnum
When a masking operation is initiated on a surface, the implementation shall produce results as-if the following steps were performed:

\begin{enumerate}
\item For each integral point $sp$ of the \underlyingsurface, determine if $sp$ is within the clip area (\ref{\iotwod.clipprops.summary}); if so, proceed with the remaining steps.
\item Transform $sp$ from the surface coordinate space (\ref{\iotwod.surface.coordinatespaces}) to the mask coordinate space (Table~\ref{tab:\iotwod.surface.pointtransforms.listing}), resulting in point $mp$.
\item Sample the alpha channel from point $mp$ of the mask brush and store the result in $mac$; if the visual data format of the mask brush does not have an alpha channel, the value of $mac$ shall always be $1.0$.
\item Transform $sp$ from the surface coordinate space to the brush coordinate space, resulting in point $bp$.
\item Sample from point $bp$ of the source brush (\ref{\iotwod.surface.rendering.brushes}), combine the resulting visual data with the visual data at point $sp$ in the \underlyingsurface in the manner specified by the surface's current compositing operator (\ref{\iotwod.renderprops.summary}), multiply each channel of the result produced by application of the compositing operator by $map$ if the visual data format of the \underlyingsurface is a premultiplied format and if not then just multiply the alpha channel of the result by $map$, and modify the visual data of the \underlyingsurface at point $sp$ to reflect the multiplied result.
\end{enumerate}

\rSec1 [\iotwod.surface.modifiers.state] {\tcode{surface} state modifiers}

\indexlibrarymember{flush}{surface}%
\begin{itemdecl}
void flush();
void flush(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the surface's \underlyingsurface, this function does nothing.

\pnum
If the implementation does provide a native handle to the surface's \underlyingsurface, then the implementation performs every action necessary to ensure that all operations on the surface that produce observable effects occur.

\pnum
The implementation performs any other actions necessary to ensure that the surface will be usable again after a call to \tcode{surface::mark_dirty}.

\pnum
Once a call to \tcode{surface::flush} is made, \tcode{surface::mark_dirty} shall be called before any other member function of the surface is called or the surface is used as an argument to any other function.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
This function exists to allow the user to take control of the underlying surface using an implementation-provided native handle without introducing a race condition. The implementation's responsibility is to ensure that the user can safely use the underlying surface.

\pnum
\errors
The potential errors are \impldefplain{surface::flush errors}.

\pnum
Implementations should avoid producing errors here.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.

\pnum
\begin{note}
There are several purposes for \tcode{surface::flush} and \tcode{surface::mark_dirty}.

\pnum
One is to allow implementation wide latitude in how they implement the rendering and composing operations (\ref{\iotwod.surface.rendering}), such as batching calls and then sending them to the \underlyingrendandpresenttechs at appropriate times.

\pnum
Another is to give implementations the chance during the call to \tcode{surface::flush} to save any internal state that might be modified by the user and then restore it during the call to \tcode{surface::mark_dirty}.

\pnum
Other uses of this pair of calls are also possible.
\end{note}
\end{itemdescr}

\indexlibrarymember{mark_dirty}{surface}%
\begin{itemdecl}
void mark_dirty();
void mark_dirty(error_code& ec) noexcept;
void mark_dirty(const bounding_box& extents);
void mark_dirty(const bounding_box& extents, error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall do nothing.

\pnum
If the implementation does provide a native handle to the \tcode{surface} object's \underlyingsurface, then:
\begin{itemize}
\item If called without a \tcode{rect} argument, informs the implementation that external changes using a native handle were potentially made to the entire \underlyingsurface.
\item If called with a \tcode{bounding_box} argument, informs the implementation that external changes using a native handle were potentially made to the \underlyingsurface within the bounds specified by the \term{bounding rectangle} \tcode{bounding_box\{ round(extents.x()), round (extents.y()), round(extents.width()), round(extents.height())\}}. No part of the bounding rectangle shall be outside of the bounds of the \underlyingsurface; no diagnostic is required.
\end{itemize}

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
After external changes are made to this \tcode{surface} object's \underlyingsurface using a native pointer, this function shall be called before using this \tcode{surface} object; no diagnostic is required.

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!mark_dirty}.

\pnum
If the implementation does not provide a native handle to the \tcode{surface} object's \underlyingsurface, this function shall not produce any errors.
\end{itemdescr}

\rSec1 [\iotwod.surface.modifiers.render] {\tcode{surface} render modifiers}

\indexlibrarymember{paint}{surface}%
\begin{itemdecl}
void paint(const brush& b, const optional<brush_props>& bp,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the painting rendering and composing operation as specified by \ref{\iotwod.surface.painting}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!paint}.
\end{itemdescr}

\indexlibrarymember{stroke}{surface}%
\begin{itemdecl}
template <class Allocator>
void stroke(const brush& b, const path_builder<Allocator>& pb,
  const optional<brush_props>& bp,
  const optional<stroke_props>& sp,
  const optional<dashes>& d,
  const optional<render_props>& rp = nullopt,
  const optional<clip_props>& cl);
void stroke(const brush& b, const interpreted_path& pg,
  const optional<brush_props>& bp,
  const optional<stroke_props>& sp,
  const optional<dashes>& d,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the stroking rendering and composing operation as specified by \ref{\iotwod.surface.stroking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!stroke}.
\end{itemdescr}

\indexlibrarymember{fill}{surface}%
\begin{itemdecl}
template <class Allocator>
void fill(const brush& b, const path_builder<Allocator>& pb,
  const optional<brush_props>& bp,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
void fill(const brush& b, const interpreted_path& pg,
  const optional<brush_props>& bp,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the filling rendering and composing operation as specified by \ref{\iotwod.surface.filling}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldefplain{surface!fill}.
\end{itemdescr}

\indexlibrarymember{mask}{surface}%
\begin{itemdecl}
template <class Allocator>
void mask(const brush& b, const brush& mb,
  const optional<brush_props>& bp,
  const optional<mask_props>& mp,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
void mask(const brush& b, const brush& mb,
  const optional<brush_props>& bp,
  const optional<mask_props>& mp,
  const optional<render_props>& rp,
  const optional<clip_props>& cl);
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Performs the masking rendering and composing operation as specified by \ref{\iotwod.surface.masking}.

\pnum
The meanings of the parameters are specified by \ref{\iotwod.surface.rendering}.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors

The errors, if any, produced by this function are \impldefplain{surface!mask}.
\end{itemdescr}
