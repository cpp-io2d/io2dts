%!TEX root = io2d.tex
\rSec0 [mappedsurface] {Class \tcode{mapped_surface}}

\rSec1 [mappedsurface.synopsis] {\tcode{mapped_surface} synopsis}

\begin{codeblock}
namespace std { namespace experimental { namespace io2d { inline namespace v1 {
  class mapped_surface {
  public:
    // \ref{mappedsurface.cons}, construct/copy/move/destroy:
    mapped_surface() = delete;
    mapped_surface(const mapped_surface&) = delete;
    mapped_surface& operator=(const mapped_surface&) = delete;
    mapped_surface(mapped_surface&& other) = delete;
    mapped_surface& operator=(mapped_surface&& other) = delete;
    ~mapped_surface();
    
    // \ref{mappedsurface.modifiers}, modifiers:
    void commit_changes();
    void commit_changes(error_code& ec) noexcept;
    void commit_changes(const rectangle& area);
    void commit_changes(const rectangle& area, error_code& ec) noexcept;
    unsigned char* data();
    unsigned char* data(error_code& ec) noexcept;
    
    // \ref{mappedsurface.observers}, observers:
    const unsigned char* data() const;
    const unsigned char* data(error_code& ec) const noexcept;
    experimental::io2d::format format() const noexcept;
    int width() const noexcept;
    int height() const noexcept;
    int stride() const noexcept;
  };
} } } }
\end{codeblock}

\rSec1 [mappedsurface.intro] {\tcode{mapped_surface} Description}

\pnum
\indexlibrary{\idxcode{mapped_surface}}
The \tcode{mapped_surface} class provides access to inspect and modify the pixel data of a \tcode{surface} object's \underlyingsurface or a subsection thereof.

\pnum
A \tcode{mapped_surface} can only be created by the \tcode{surface::map} function. It cannot be copied or moved.

\pnum
The pixel data is presented as an array in the form of a pointer to (possibly \tcode{const}) \tcode{unsigned char}.

\pnum
The actual format of the pixel data depends on the \tcode{format} enumerator returned by calling \tcode{mapped_surface::format} and is native-endian. For more information, see the description of the \tcode{format} enum class (\ref{format}).

\pnum
The pixel data array is presented as a series of horizontal rows of pixels with row \tcode{0} being the top row of pixels of the \underlyingsurface and the bottom row being the row at \tcode{mapped_surface::height() - 1}.

\pnum
Each horizontal row of pixels begins with the leftmost pixel and proceeds right to \tcode{mapped_surface::width() - 1}.

\pnum
The width in bytes of each horizontal row is provided by \tcode{mapped_surface::stride}. This value may be larger than the result of multiplying the width in pixels of each horizontal row by the size in bytes of the pixel's format (most commonly as a result of implementation-dependent memory alignment requirements).

\pnum
Whether the pixel data array provides direct access to the \underlyingsurface's memory or provides indirect access as if through a proxy or a copy is \unspecnorm.

\pnum
Changes made to the pixel data array are considered to be \term{uncommitted} so long as those changes are not reflected in the \underlyingsurface.

\pnum
Changes made to the pixel data array are considered to be \term{committed} once they are reflected in the \underlyingsurface.

\rSec1 [mappedsurface.cons] {\tcode{mapped_surface} constructors and assignment operators}

\indexlibrary{\idxcode{mapped_surface}!destructor}
\begin{itemdecl}
~mapped_surface();
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Destroys an object of type \tcode{mapped_surface}. 

\pnum
\remarks
Whether any uncommitted changes are committed during destruction of the \tcode{mapped_surface} object is \unspecnorm.

\pnum
Uncommitted changes shall not be committed during destruction of the \tcode{mapped_surface} object if doing so would result in an exception.

\pnum
\realnotes
It is recommended that users use the \tcode{mapped_surface::commit_changes} function to commit changes prior to the destruction of the \tcode{mapped_surface} object to ensure consistent behavior.
\end{itemdescr}

\rSec1 [mappedsurface.modifiers]{\tcode{mapped_surface} modifiers}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{commit_changes}}
\indexlibrary{\idxcode{commit_changes}!\idxcode{mapped_surface}}
\begin{itemdecl}
void commit_changes();
void commit_changes(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\effects
Any uncommitted changes shall be committed.

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\errors
The errors, if any, produced by this function are \impldef{mapped_surface!commit_changes}.
\end{itemdescr}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{data}}
\indexlibrary{\idxcode{data}!\idxcode{mapped_surface}}
\begin{itemdecl}
unsigned char* data();
unsigned char* data(error_code& ec) noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A native-endian pointer to the pixel data array.
\enterexample
Given the following code:

\begin{codeblock}
image_surface imgsfc{ format::argb32, 100, 100 };
imgsfc.paint(rgba_color::red());
imgsfc.flush();
imgsfc.map([](mapped_surface& mapsfc) -> void {
    auto pixelData = mapsfc.data();
    auto p0 = static_cast<uint32_t>(pixelData[0]);
    auto p1 = static_cast<uint32_t>(pixelData[1]);
    auto p2 = static_cast<uint32_t>(pixelData[2]);
    auto p3 = static_cast<uint32_t>(pixelData[3]);
    printf("%X %X %X %X\n", p0, p1, p2, p3);
});
\end{codeblock}

In a little-endian environment, \tcode{p0 == 0x0}, \tcode{p1 == 0x0}, \tcode{p2 == 0xFF}, and \tcode{p3 == 0xFF}.

In a big-endian environment, \tcode{p0 == 0xFF}, \tcode{p1 == 0xFF}, \tcode{p2 == 0x0}, \tcode{p3 == 0x0}.
\exitexample

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
The bounds of the pixel data array range from \tcode{a}, where \tcode{a} is the address returned by this function, to \tcode{a + this->stride() * this->height()}. Given a height \tcode{h} where \tcode{h} is any value from \tcode{0} to \tcode{this->height() - 1}, any attempt to read or write a byte with an address that is not within the range of addresses defined by \tcode{a + this->stride() * h} shall result in undefined behavior; no diagnostic is required.

\pnum
\errors
\tcode{io2d_error::null_pointer} if \tcode{this->format() == experimental::io2d::format::unknown || this->format() == experimental::io2d::format::invalid}.
\end{itemdescr}

\rSec1 [mappedsurface.observers]{\tcode{mapped_surface} observers}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{data}}
\indexlibrary{\idxcode{data}!\idxcode{mapped_surface}}
\begin{itemdecl}
const unsigned char* data() const;
const unsigned char* data(error_code& ec) const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
A const native-endian pointer to the pixel data array.
\enterexample
Given the following code:

\begin{codeblock}
image_surface imgsfc{ format::argb32, 100, 100 };
imgsfc.paint(rgba_color::red());
imgsfc.flush();
imgsfc.map([](mapped_surface& mapsfc) -> void {
    auto pixelData = mapsfc.data();
    auto p0 = static_cast<uint32_t>(pixelData[0]);
    auto p1 = static_cast<uint32_t>(pixelData[1]);
    auto p2 = static_cast<uint32_t>(pixelData[2]);
    auto p3 = static_cast<uint32_t>(pixelData[3]);
    printf("%X %X %X %X\n", p0, p1, p2, p3);
});
\end{codeblock}

In a little-endian environment, \tcode{p0 == 0x0}, \tcode{p1 == 0x0}, \tcode{p2 == 0xFF}, and \tcode{p3 == 0xFF}.

In a big-endian environment, \tcode{p0 == 0xFF}, \tcode{p1 == 0xFF}, \tcode{p2 == 0x0}, \tcode{p3 == 0x0}.
\exitexample

\pnum
\throws
As specified in Error reporting (\ref{\iotwod.err.report}).

\pnum
\remarks
The bounds of the pixel data array range from \tcode{a}, where \tcode{a} is the address returned by this function, to \tcode{a + this->stride() * this->height()}. Given a height \tcode{h} where \tcode{h} is any value from \tcode{0} to \tcode{this->height() - 1}, any attempt to read a byte with an address that is not within the range of addresses defined by \tcode{a + this->stride() * h} shall result in undefined behavior; no diagnostic is required.

\pnum
\errors
\tcode{io2d_error::null_pointer} if \tcode{this->format() == experimental::io2d::format::unknown || this->format() == experimental::io2d::format::invalid}.
\end{itemdescr}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{format}}
\indexlibrary{\idxcode{format}!\idxcode{mapped_surface}}
\begin{itemdecl}
experimental::io2d::format format() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The pixel format of the mapped surface.

\pnum
\remarks
If the mapped surface is invalid, this function shall return \tcode{experimental::io2d::format::invalid}.
\end{itemdescr}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{width}}
\indexlibrary{\idxcode{width}!\idxcode{mapped_surface}}
\begin{itemdecl}
int width() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The number of pixels per horizontal line of the mapped surface.

\pnum
\remarks
This function shall return the value \tcode{0} if \tcode{this->format() == experimental::io2d::format::unknown || this->format() == experimental::io2d::format::invalid}.
\end{itemdescr}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{height}}
\indexlibrary{\idxcode{height}!\idxcode{mapped_surface}}
\begin{itemdecl}
int height() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The number of horizontal lines of pixels in the mapped surface.

\pnum
\remarks
This function shall return the value \tcode{0} if \tcode{this->format() == experimental::io2d::format::unknown || this->format() == experimental::io2d::format::invalid}.
\end{itemdescr}

\indexlibrary{\idxcode{mapped_surface}!\idxcode{stride}}
\indexlibrary{\idxcode{stride}!\idxcode{mapped_surface}}
\begin{itemdecl}
int stride() const noexcept;
\end{itemdecl}
\begin{itemdescr}
\pnum
\returns
The length, in bytes, of a horizontal line of the mapped surface.
\enternote
This value is at least as large as the width in pixels of a horizontal line multiplied by the number of bytes per pixel but may be larger as a result of padding.
\exitnote

\pnum
\remarks
This function shall return the value \tcode{0} if \tcode{this->format() == experimental::io2d::format::unknown || this->format() == experimental::io2d::format::invalid}.
\end{itemdescr}
